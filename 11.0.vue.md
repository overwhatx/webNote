# VUE2
## 简介
- 组件式开发 
- 不操作任何dom
- 数据双向绑定
## vue 的MVVM 含义 
- mvvm是 Model-View-ViewModel 的缩写，即 模型-视图-视图模型。
- Model：数据模型，后端传递的数据。(data，props，computed等部分）                              数据模型
- View：代表 UI 组件，它负责将数据模型转化成 UI 展现出来。（template部分）                      页面模板
- ViewModel：是一个同步View 和 Model的对象。是MVVM模式的核心，它是连接Model和View的桥梁。      连接同步 数据模型 和 页面模板的桥梁 
## 第一个vue
- `{{value}}` 插值表达式 需要注意 **在插值表达式中 null 和undefined 无法渲染出来 其余都可以**
- demo
    ```html
    <body>
    <div id='app'>
        <!--  v-model="texts" 指令  vue自定义标签属性v-开头  属性值是一个js的表达式  -->
        <input type="text" v-model="texts">

        <!-- 插值 双大括号表达式 动态显示数据  显示数据  {{xxx}} -->
        <p>hello {{texts}}</p>
    </div>
    <p id="test2">{{test2}}</p>

    </body>
    //引入 vue.js 文件
    <script src='js/vue.js'></script>
    <script>
    //配置对象 属性名是特定的名称 每个属性就是一个选项
    var vm = new Vue({
        //el 指定element选择器
        el: '#app', //el:元素的挂载位置 （值可以是css选择器或者dom元素）  选择器字符串 用于指定模板的根元素
        data: { // 包含一些数据属性的对象 为模板提供数据   data 初始化数据 页面可以访问
            texts: 'world'
        }
    })
    var vm = new Vue({
        data: {
            test2: 'test2'
        }
    }).$mount('#test2')  //.$mount('#app'); //不写el 使用 $mount() 也可以
    </script>
    ```
## 指令
- v-model 指令 双向数据绑定 **只能绑定在表单元素上 在其他元素上将报错**
  - 单向数据绑定: 数据流向 data ==> template 模板页面
  - 双向数据绑定: 数据流向 data `<==>` template 模板页面
- v-bind: 指令 属性绑定 属性值是一个动态值 缩写在属性值前面添加 “ : 冒号 ”
  - demo
    ```html
        <a v-bind:href="url" target="__blank">百度一下 方式1</a><br />
        <!-- 缩写方式 -->
        <a :href="url" target="__blank">百度一下 方式2 在属性值前面添加 “ :冒号 ”</a>
       <script>
        var vm = new Vue({
        el: '#app',
        data: {
            url: 'https://www.baidu.com'
        }
        })
        </script>
    ```
- v-on:事件类型  绑定事件监听器  **监视 监听 一定有回调函数** 缩写 事件前加 @
  - demo
    ```html
   <button v-on:click="test1">绑定事件监听 方式1</button>
   <button @click="test1">绑定事件监听缩写 方式2</button>
    <script>
    // 监视 监听 一定有回调函数
    var vm = new Vue({
        methods: {
            test1(event) {
                // 获取到按钮的文本
                console.log(event.target.innerText);
            }
        },
    })
    </script>

   ```
- v-cloak 解决vue插值表达式 闪动问题
  - ` <div id='app' v-cloak></div>  [v-cloak]{display:none}` v-cloak指令 配合  样式
  - 原理：先进行隐藏 等待数据发生变化在进行显示  是给自定义属性添加样式 不是给挂载的元素设置样式
- v-once 只编译一次 响应完一次 就不再具备响应式功能
- v-text 填充纯文本：相比插值表达式更加简洁 不存在闪动问题
- v-html 填充html片段：存在安全问题、本网站内部的数据可以使用，来自第三方的数据不可用
- v-pre 填充原始信息：显示原始信息，跳过编译过程（分析编译过程）
- v-show 条件渲染 显示隐藏
    - v-show 不支持 <teplate></teplate> 元素 也不支持 v-else
- v-if v-else-if v-else 判断是否渲染元素 但凡复合 判断条件 则渲染该元素
  - if判断但凡进入条件 则不在继续判断
  - demo
    ```html
    <div id='app'>
        <p v-if="score>=90"> 优秀</p>
        <p v-else-if="score<90&&score>=60"> 良</p>
        <p v-else="score<60"> 不及格</p>
    </div>
    <script>
        var vm = new Vue({
            el: '#app',
            data: {
                score: 59
            },
            methods: {},
        })
    </script>
  ```
- v-for 循环指令
  - 循环语句中 v-for 必须搭配key 帮助区分不同元素 提高性能  (vue 是虚拟dom)
    - 当循环数组的时候 不要使用 index 下标 而是使用 item.id
    - 当循环对象的时候 使用 index  或item.id 都可以
    ```html
        <div id='app'>
        <ul>
            <!-- 数组 是子项和下标 key值是 子项的id  items-元素 index-下标-->
            <li v-for="(items,index) in arr" :key="items.id">{{items}}--{{index}}</li>
            <!-- 对象是键值对 key值是index  key-键 values-值 index-下标-->
            <li v-for="(key,values,index) in obj" :key="index">{{values}}-{{key}}-{{index}}</li>
        </ul>
    </div>
    <script>
        var vm = new Vue({
            el: '#app',
            data: {
                arr: ['a', 'b', 'c'],
                obj: {
                    a: 'aa',
                    b: 'bb',
                    c: 'cc'
                }
            },
            methods: {},
        })
    </script>
    ```

### 分支v-if else渲染 和 v-show
- v-if  是真正条件上的渲染 但是只有当条件为真的时候 才会开始渲染满足的条件块 进行重排操作
- v-show 不管条件是否满足 元素依然会被渲染 只是简单基于css进行切换 进行重绘操作
- 当一条语句上 两者同时出现 v-if 的优先级更高 因为 当条件不成立不渲染 v-show无法操作
## 实例方法
- vm.$mount  实例方法 手动地挂载一个未挂载的实例
## @keyup 键盘事件 以及自定义
- @keyup.enter 键盘回车触发
- @keyup.delete 键盘退格或delete触发
- 自定义修饰符
  - 可以使用@keyup事件 配合 event.keyCode 获取到键盘的值
  - demo
    ```html
        <div id='app'>
        <input @keyup="code">
        <input @keyup.115="codef4">
        </div>
        <script>
        var vm = new Vue({
            el: '#app',
            data: {},
            methods: {
                code: function () {
                    //获取到键盘值
                    console.log(event.keyCode);
                },
                codef4: function () {
                    console.log('点击了f4');
                }
            },
        })
    </script>
    ```
## class和style样式绑定
### :class
- v-bind:class 数组形式 、对象形式 、 对象与数组混合形式 、 简写形式
  - demo
    ```html
     <div id='app'>
    <p v-bind:class="{active:show}">对象形式</p>
    <button v-on:click='handle'>切换状态</button>
    <p :class="[isActive,isBg]">数组形式</p>
    <p :class="allar">数组形式 简写</p>
    <p :class="objarr">对象形式 简写</p>
     
    </div>
    <script>
        var vm = new Vue({
            el: '#app',
            data: {
                show: true,  //为true 表示添加样式 false 删除样式
                isActive: 'active', //值为 class类名
                isBg: 'bg',
                allar: ['active', 'bg'], //简写数组形式 数组包裹class类名
                objarr: {//简写对象形式 
                    active: true,
                    bg: true
                }
            },
            methods: {
                handle() {
                    this.show = !this.show
                }
            },
        })
    </script>
    ```
### :style 抒写的是行内样式
- demo
  ```html
        <div id='app'>
        <p :style="{color:iscolor,background:isbg}">文字</p>
        <button v-on:click='handle'>切换状态</button>
        <div :style="allobj">style 对象简写</div>
        <div :style="allarr">style 数组简写</div>
         </div>
        <script>
        var vm = new Vue({
            el: '#app',
            data: {
                iscolor: 'red',
                isbg: 'blue',
                allobj: {
                    width: '100px',
                    height: '100px',
                    background: 'lightblue'
                },
                allarr: [{
                    width: '100px',
                    height: '100px',
                    background: 'lightpink'
                }]
            },
            methods: {
                handle() {
                    this.iscolor = 'green'
                }
            },
        })
    </script>
  ```
- show ` <p :class="{active:show}">文字</p>`  控制样式 显示 控制属性名是否存在 在 data数据中可以进行控制为 true或false
### scoped 让样式在局部生效，防止冲突 写法：`<style scoped>`
## 修饰符
- .prevent 阻止默认事件
- .stop 阻止冒泡
- .capture 开启捕获模式
- .once 只触发一次回调
- .self 只当事件是从侦听器绑定的元素本身触发时才触发回调
- .passive 监听滚动事件 立即触发
### 表单修饰符
- .lazy 输入框失去焦点才进行响应 将input事件转换为 change事件
- .number 将输入的值通过 parseFloat 进行转换 
- .trim  去除表单首尾空格
## 自定义指令 Vue.directive
-  全局注册指令 Vue.directive
   -  定义的时候不加 v- 使用时加 命名时单词和单词之间使用 -隔开不要使用驼峰 directive中使用的时有带-的命名 使用''包裹
   -   钩子函数 inserted **一旦渲染在父级中 则立即触发**
       - 被绑定的元素插入父节点时调用 （仅保证父节点存在 但不一定已被插入文档中）  
   -  demo 定义一个自动聚焦输入框的全局指令
    ```js
        Vue.directive('focus', {
            // 当被绑定的元素插入到 DOM 中时……
            inserted: function (el) {
                // 聚焦元素
                el.focus()  // 页面加载完成之后自动让输入框获取到焦点的小功能
            }
        })

         //自定义指令传参
        <input type="text" v-focus="{color:'lightpink'}">
        Vue.directive('focus', {
            // 当被绑定的元素插入到 DOM 中时……
            inserted: function (el, binding) {
                // el 绑定的指定的元素
                // binding  指令名称 不包含 v-
                // value 传入的值
                console.log(el);

                el.style.background = binding.value.color

            }
        })

    ```
- demo （函数形式）自定义一个big指令 使用后 放大当前数字的10倍
  ```js
    <template>
      <div>
        <h1>一个数{{ num }}</h1>
        <h2>放大十倍的num值： <span v-big="num"></span></h2>
        <button @click="num++">点击触发自定义事件</button>
      </div>
    </template>
    <script>
    export default {
      name: "Vue2TestApp",
      data() {
        return {
          num: 0,
        };
      },
      directives: {
        // big函数何时被调用：1.指令与元素成功绑定时 2.指令所在的模板被重新解析时
        // element 为真实dom  binding为对象（得到被绑定元素所有信息） 主要使用其中的value
        big(element, binding) {
          console.log(element, binding);
          console.dir(element);
          // 判断是否是真实DOM
          console.log(element instanceof HTMLElement);
          console.log(binding.value);
          element.innerText = binding.value * 10;
        },
      },
    };
    </script>
  ```
- demo （对象形式）自定义一个fbing指令 使用后 自动对焦输入框并把绑定的数据放大10倍
  ```js
    <template>
      <div>
        <router-view />
        <h1>一个数{{ num }}</h1>
        <input type="text" v-fbing:value="num" />
        <button @click="num++">点击触发自定义事件</button>
      </div>
    </template>

    <script>
    export default {
      name: "Vue2TestApp",
      data() {
        return {
          num: 0,
        };
      },
      directives: {
        // 自定义 fbing指令 实现进入页面input框自动对焦输入框 获取num值
        // 因为 使用函数方法只有两个时机触发调用 导致刚进入页面时 无法获取焦点（具体原因为vue模板元素并没有渲染）
        /*  fbing(element, binding) {
          console.log(element, binding);
          element.value = binding.value;
          element.focus();
        }, */
        fbing: {
          // 指令与元素成功绑定时 触发
          bind(element, binding) {
            console.log("bind");
            element.value = binding.value;
            element.focus();
          },
          // 指令所在元素被插入页面时 触发
          inserted(element) {
            console.log("inserted");
            element.focus();
          },
          // 指令所在模板被重新解析时 触发
          update(element, binding) {
            console.log("update");
            element.value = binding.value * 10;
            element.focus();
          },
        },
      },
    };
    </script>
  ```
## 计算属性 computed
- computed:{} 计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例
    - 根据依赖关系进行缓存的计算，只有在它的相关依赖发生改变时才会进行更新 
- watch:{} 选项|数据  一个对象，键是需要观察的表达式，值是对应回调函数
- vm.$watch(){}实例方法  观察 Vue 实例上的一个表达式或者一个函数计算结果的变化
- 什么时候使用计算属性: 如果要显示的数据可以根据现有的数据产生那就使用计算属性
- demo
   ```html
    // 需求：
    // 1．给p添加一个新的属性: fullName= firstName + '-' + lastName
    // 2．如果修改了firstName/lastName,furllName自动改变为对应的值
    // 3．如果修改了fullName，firstName和lastName也自动改变为对应的值
    <div id="app">
        firstName: <input type="text" v-model="firstName">
        lastName:<input type="text" v-model="lastName">
        fullName1单向绑定:<input type="text" v-model="fullName1">
        fullName2双向绑定:<input type="text" v-model="fullName2">
        fullName3单向绑定watch:<input type="text" v-model="fullName3">
    </div>
    <script>
    var vm = new Vue({
        el: '#app',
        data: {
            //初始化数据
            firstName: 'A',
            lastName: 'B',
            fullName3: 'A-B'
        },
        // 计算属性
        computed: {

            // 简写显示 等同于单独写了getter
            // 初始显示 执行了一次
            // 依赖的数据发生改变 会进行执行
            fullName1() {
                console.log(this);
                return this.firstName + "-" + this.lastName
            },
            fullName2: {
                get() {  //监视依赖数据
                    return this.firstName + "-" + this.lastName;
                },
                set(value) { //监视自身 当自身发生改变的时候 进行后续处理
                    const names = value.split('-')
                    this.firstName = names[0]
                    this.lastName = names[1]
                }
            }

        },
        //   watch方式1 监听firsName
        watch: {
            // 当firsName发生改变的时候执行 并改变 fullname3
            firstName(value) {
                this.fullName3 = value + '-' + this.lastName;
            }
        }
    })

    // watch方式2 首先 声明定义vue模板
    // 当lastName发生改变的时候执行 并改变 fullname3
    vm.$watch('lastName', function (value) {
        this.fullName3 = this.firstName + "-" + value;
    })

    /*
    1.veu控制的所有回调的this都是 vm|组件对象
    2.vue给vm定义一些与data中属性对应的属性  条件 同名

        getter方法 当通过 vm.xxx读取属性值时，读取data对象中同名属性的值
        setter方法 当通过 vm.xxx=value 指定新的值时，值就保存data中对应的属性上
    数据代理 vm.data=xxx ===> vm.xxx 通过vm代理对vm内部的data对象的属性的操作 读|写 
    */
    </script>
   ```
- 计算属性 对于逻辑比较复杂的地方 使用计算属性 使得模板更加的简洁
- demo
  ```html
     <div id='app'>
        <p>{{msg}}</p>
        <p>{{trans}}</p>
    </div>
    <script>
        var vm = new Vue({
            el: '#app',
            data: {
                msg: '你好哇'
            },
            // 事件方法
            methods: {},
            // 触发逻辑上的业务
            computed: {
                trans() {
                    return this.msg.slice(0, 2).split(' ').reverse().join()
                }
            }
        })
    </script>
  ```
### computed计算属性 和 methods方法的区别
  - computed 计算属性 是基于其他的依赖进行缓存的
  - methods 方法 是不存在缓存的
## watch 侦听器
- 监听的数据发生改变 侦听器绑定的方法就会触发 
- 侦听器 适用于数据变化时执行异步或开销（耗时）较大的操作
  - demo 案例1
    ```html
        <div id='app'>
        <p>姓：<input type="text" v-model="fistName"></p>
        <p>名：<input type="text" v-model="lastName"></p>
        <p>{{names}}</p>
        </div>
        <script>
        var vm = new Vue({
            el: '#app',
            data: {
                fistName: '阿姨',
                lastName: '洗铁路',
                names: '阿姨 洗铁路'
            },
            methods: {},
            watch: {
                fistName(v) {
                    this.names = v + " " + this.lastName;
                },
                lastName(v) {
                    this.names = this.fistName + " " + v;
                }
            },
        })
         </script>
    ```
    - demo 案例2  模拟进行后天校验
      ```html
        <div id='app'>
        <p><input type="text" v-model.lazy="userName"> {{msg}}</p>
        </div>
        <script>
        /**
         * 通过v-model 实现数据绑定
         * 需要提供提示信息
         * 需要侦听监听输入信息的变化
         * 需要修改触发的事件     
        */
        var vm = new Vue({
            el: '#app',
            data: {
                userName: '',
                msg: '',
            },
            methods: {
                serverUser(val) {
                    let that = this;
                    setTimeout(function () {
                        if (val == 'admin') {
                            that.msg = '用户名已存在'
                            return;
                        } else {
                            that.msg = '可以使用'
                        }
                    }, 2000)
                }
            },
            watch: {
                userName(val) {
                    this.serverUser(val)
                    this.msg = '后台验证中。。。。。'
                },
            },
        })
        </script>
      ```
## filter 过滤器 
- 将指定的数据进行处理 否则执行原数据
- 将数据进行处理 得到新的数据
- 多个过滤器 后面的会覆盖前面的
### 全局过滤 和局部过滤
- demo
  ```html
  
     <div id='app'>
        <input type="text" v-model='msg'>
        <!-- 将首字母转为小写  lower-->
        <div>{{msg | lower}} </div>
        <!-- 将首字母转为小写 在转换为大写 后面的过滤会覆盖前面的 -->
        <div>{{msg | lower | upper}} </div>
        <!-- 同时也可也作用于其他地方的过滤操作  -->
        <div :class="msg|upper"></div>
     </div>
    <script>
        // 定义一个全局过滤
        Vue.filter('lower', function (val) {
            return val.charAt(0).toLowerCase() + val.slice(1)
        })
        // Vue.filter('upper', function (val) {
        //     return val.charAt(0).toUpperCase() + val.slice(1)
        // })
        // 多个过滤器 后面的会覆盖前面的
        var vm = new Vue({
            el: '#app',
            data: {
                msg: ''
            },
            methods: {},
            //局部过滤
            filters: {
                upper: function (val) {
                    return val.charAt(0).toUpperCase() + val.slice(1)
                }
            }
        })
    </script>
  ```
### 带参数的过滤
- demo
  ```html
    <div id='app'>
        <!-- 渲染指定格式的数据 -->
        <div>{{datatime | time('yyy-mm-dd')}} </div>
    </div>

    <script src='../js/vue.js'></script>
    <script>
        // 将数据进行处理 得到新的数据
        // 定义一个全局过滤
        Vue.filter('time', function (val, text) {
            if (text == 'yyy-mm-dd') {
                var res = ''
                // 将时间拼接为 需要的格式
                res += val.getFullYear() + "-" + (val.getMonth() + 1) + "-" + val.getDate();
            }
            return res
        })
        // 多个过滤器 后面的会覆盖前面的
        var vm = new Vue({
            el: '#app',
            data: {
                msg: '',
                datatime: new Date(), //声明一个时间
            },
            methods: {},
        })
    </script>
  ```
## **生命周期 生命周期钩子 (vue2 总11个)**
### **4个阶段 8个生命周期函数**
- 生命周期执行顺序 init->beforeCreate->created->beformMounted->mounted->init->beforeUpdate->updated->beforeDestroy->destroyed
  - init 为初始化 在 挂载后在init 初始化
- 1.创建   
  - beforeCreate  实例化创建前  (在数据检测 数据代理之前)
  - created        实例化创建后 (在数据检测 数据代理之后)
- 2.挂载
  - beforeMount   模板、节点 挂载前
  - mounted       模板、节点 挂载完成
- 3.更新
  - beforeUpdate  （元素/组件的变更操作） 箭头data中数据 发生改变前
  - updated        元素/组件的变更操作） 箭头data中数据 发生改变后
- 4.销毁 在这个阶段可以访问数据 等 但无法改变数据
  - beforeDestroy 销毁相关的属性前
  - destroyed     销毁相关的属性后
- demo
  ```html
       <div id='app'>
        <p>{{msg}}</p>
        <!-- 使用input 双向绑定 修改值 触发变更 -->
        <input type="text" v-model="msg">
        <button @click="destroy">销毁</button>
    </div>
    <script src='../js/vue.js'></script>
    <script>
        var vm = new Vue({
            el: '#app',
            data: {
                msg: 'abc'
            },
            methods: {
                // 销毁当前vue实例
                destroy: function () {
                    this.$destroy();
                }
            },
            beforeCreate: function () {
                console.log('beforeCreate 实例化创建前触发');
            },
            created: function () {
                console.log('created 实例化创建后触发');
            },
            beforeMount: function () {
                console.log('beforeMount 挂载前触发');
            },
            mounted: function () {
                console.log('mounted 挂载完成触发');
            },
            beforeUpdate: function () {
                console.log('beforeUpdate 变更前触发');
            },
            updated: function () {
                console.log('updated 变更后触发');
            },
            beforeDestroy: function () {
                console.log('beforeDestroy 销毁前触发');
            },
            destroyed: function () {
                console.log('destroyed 销毁后触发');
            },
        })
        </script>
  ``` 
- vm.$destroy() 完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器
### 其他vue2 生命周期钩子 3个
- activated 被 keep-alive 缓存的组件激活时调用 该钩子在服务器端渲染期间不被调用
- deactivated 被 keep-alive 缓存的组件失活时调用 该钩子在服务器端渲染期间不被调用
- errorCaptured 在捕获一个来自后代组件的错误时被调用（vue2.5新增）
## 数据变更方法
- push()
- pop()
- shift()
- unshift()
- splice()
- sort()
- reverse()
- 不会改变原有数组的方法
  - filter、concat、slice、map、join、forEach、find、findIndex、isArray、includes、indexOf、concat
### 修改响应式数据方法
- 参数1 数组名或对象  参数2 要处理的数组的下标或对象名 参数3 新的数组值或对象值
- Vue.set(vm.arr, 0, 10)
- vm.$set(vm.arr, 1, 8)
- demo
  ```html
     <div id='app'>
        <input type="text" v-model="cont">
        <div v-for="item in arr" :key="item.id">{{item}}</div>
        <button @click="add">尾部添加</button>
        <button @click="remo">尾部删除</button>
        <button @click="slice">尾部删除一项 slice</button>
        <div v-for="item in obj" :key="item.id">{{item}}</div>
    </div>
    <script>
        var vm = new Vue({
            el: '#app',
            data: {
                cont: '',
                arr: [1, 2, 3],
                obj: {
                    a: '苹果',
                    b: '榴莲',
                    c: '香蕉',
                }
            },
            methods: {
                remo() {
                    this.arr.pop();//尾部删除
                },
                add() {
                    this.arr.push(this.cont)//尾部添加
                },
                slice() {
                    this.arr = this.arr.slice(0, 2) //尾部删除一项
                },
            },
        })
        // 通过索引去改变值
        Vue.set(vm.arr, 0, '改变的数据1')
        vm.$set(vm.arr, 1, '改变的数据2')

        // 拖过键名去改变值
        Vue.set(vm.obj, 'a', '西红柿')
        vm.$set(vm.obj, 'b', '西红柿')

        vm.obj.d = '黄瓜'; //直接添加
  ```

## **组件  Vue.component**
- 注册全局组件语法：
   ```js
        Vue.component('组件名称', {
            data: 组件数据,
            template: 组件模板内容
        })
   ```
### 组件的使用全局注册组件
- 组件里面的data数据集 必须是函数形式 里面的数据 必须通过返回值返回
- 组件使用的数据和方法 是组件自身存在的 不是使用 vue实例里面的
- 每个子组件之间是相互独立的数据
- **组件模板内容必须是单个根元素** 可以是嵌套关系但不能是同级
- demo
  ```html
    <div id='app'>
        <button-btn></button-btn>
        <button-btn></button-btn>
        <button-btn></button-btn>
    </div>
    <script>
      
        Vue.component('button-btn', {
            data() { //data 必须是函数
                return { con: 0 };
            },
            // 组件模板内容必须是单个根元素 可以是嵌套关系但不能是同级
            // template: '<button @click="con++">点击次数：{{con}}</button>', 
            // template: '<button @click="jiajia">点击次数：{{con}}</button>',
            template: `
            <div>
                <button @click="jiajia">点击次数：{{con}}</button>
                <button >使用模板字符串</button>
            </div>`,
            methods: {
                jiajia() {
                    this.con += 2
                }
            }
        })
        var vm = new Vue({
            el: '#app',
            data: {},
            methods: {},
        })
    </script>
  ```
### 组件命名规范
-  组件的命名方式  使用短横线 hello-world  和 驼峰命名方式 
   - 如果使用了 驼峰命名 helloWorld  在使用该组件的时候 只在字符串模板中有效 但在普通标签中（渲染该元素）无效 
   - 但可以进行修改 将大写全改为小写 单词之间使用横杠连接 hello-world
   - 在其他组件中的字符模板中不受影响 可以直接使用驼峰
-  **根本原因是因为 html对大小写字母不敏感 不会进行区分 所以要将驼峰改为短横线命名方式** 
- demo
  ```html
      <div id='app'>
        <my-jerry></my-jerry> 
        <!-- 输出  my is Jerry-->
        <my-tom></my-tom>
        <!-- 输出 my is Tom my is Jerry-->
    </div>
    <script>
    Vue.component('myJerry', { //组件1
            data() { 
                return { con: 'my is Jerry' };
            },
            template: ` <div> {{con}}  </div>`,
        })

        Vue.component('myTom', {//组件2
            data() { 
                return { con: 'my is Tom' };
            },
            template: ` <div> 
                {{con}}  
                <myJerry></myJerry> //使用组件1
                </div>`,
        })
        var vm = new Vue({
            el: '#app',
            data: {},
            methods: {},
        })
    </script>
  ```
### 局部组件的注册  components:{} 复数加s
- 局部组件可以调用全局组件 全局无法调用局部 
- 外层定义模板 实例定义组件
- 局部组件只能在 注册他的父级组件中 进行调用
- 如果局部组件在全局组件中定义 才可以在全局组件中使用
- demo
  ```html
    <div id='app'>
        全局组件
        <button-btn></button-btn>
        局部组件
        <hello-world></hello-world>
    </div>
    <script>
        //创建一个局部组件的模板
        let helloWorld = {
            data() {
                return {
                    con: '一条语句 helloWorld'
                }
            }, template: `<div>{{con}}
                <buttonBtn></buttonBtn> //调用了全局组件
                </div>`,
        }
        Vue.component('buttonBtn', {
            data() {
                return { con: 0 }
            },
            template: `
           <div>
            <button @click='con++'>点击次数：{{con}}</button>
            <button @click='double'>点击次数+2：{{con}}</button>
            </div>
            `,
            methods: {
                double() {
                    this.con += 2
                }
            },
        })
        var vm = new Vue({
            el: '#app',
            data: {},
            methods: {},
            // 局部组件
            components: {
                'helloWorld': helloWorld, //引入局部组件
            }
        })
    </script>
  ```
### 组件间的传值 父传子 子传父
#### 父组件向子组件传值 props
- 父组件向 子组件传递参数 使用 props[] 接收传值
- 父组件中的自定义 data的属性名称必须跟子组件间传入的属性值对应
- props接收的参数是只读的 如果需要将数据进行改变 应该复制一层到data中在进行处理
- props 命名规范
- 子组件中的props中的属性是数组形式，可以接受父组件传入的多个值
  - 在props中使用驼峰形式，模板中需要使用短横线的形式 否则会产生警告提示
  - 在字符串模板中 没有这个限制 （在其他组件中可以使用驼峰）
  - 规范写法就是 key:'value' 当想传入的为Number类型时记得添加v-bind或简写: 否则传入的为字符串
- props 传递类型可以是 string number boolen array object
- demo
  ```html
     <div id='app'>
        <!-- :num="222" 不加冒号 :也就是不使用 v-bind： 数据类型为 string  纯数字使用时为 number类型  -->
        <hello-tom str="字符串类型" :num="222" :trfa="true" :arrs="arrs" :objs="objs" :my-tom='myTom'></hello-tom>
    </div>
    <script>
        Vue.component('hello-tom', {
            props: ['str', 'num', 'trfa', 'arrs', 'objs','myTom'],
            data() {
                return {
                    msg: 'hello-tom'
                };
            },
            template: `
            <div>  
                <div>{{str}}</div>
                <div>{{typeof num}}</div>
                <div>{{ trfa}}</div>
                <ul>
                <li :key='index' v-for='(item,index) in arrs'>{{item}}</li>
                 </ul>
                 <div>{{objs.a}}</div>
                 <div>{{objs.b}}</div>
                 <div>{{myTom}}</div>
                
            </div>`,


        })

        var vm = new Vue({
            el: '#app',
            data: {
                ms: 'ms 动态父组件数据',
                arrs: ['one', 'two', 'therr'],
                objs: {
                    a: '张三',
                    b: '李四',
                    c: '王五',
                },
                myTom:'是个人才',
            },
            methods: {},
        })
  ```
- demo props接收的三种方式
  ```js
    // 简单接收
  // props: ["names", "age", "city"],

  // 对象接收 进行规定接收参数的类型
  // props: {
  //   names: String,
  //   age: Number,
  //   city: String,
  // },

  // 接收的同时对数据 进行类型限制 默认值指定 必要性限制
  props: {
    names: {
      type: String, //names的类型必须字符串
      required: true, //names是必要的
    },
    age: {
      type: Number, //age的类型必须数字
      default: 99, //当不传入的时候 使用默认值
    },
    city: {
      type: String,
      required: true,
    },
  },
  ```
#### 子组件向父组件传值 $emit()
-  通过自定义事件 向 父组件进行传值  $emit() 方法
- 父组件需要监听子组件的事件
#### 带参传递
- 子组件自定义方法中 可以传入多个参数
- 父组件监听的方法 通过$event 进行获取
- demo
  ```html
    <div id='app'>
        全局组件
        <button-btn :arr="arr" @chichichi="chichichi($event)"></button-btn>
    </div>
    <script>
        Vue.component('buttonBtn', {
            props: ['arr'],
            template: `
           <div>
           <ul>
            <li v-for='(item,index) in arr' :key='index'>{{item}}</li>
            </ul>
           <button @click='add'>按钮1</button>
           <button @click='arr.push("糖醋排骨")'>按钮2</button>
           <button @click='$emit("chichichi","就知道吃")'>按钮3</button> </div>`,
            methods: {
                add() {
                    this.arr.push('糖醋里脊')
                }
            },
        })
        var vm = new Vue({
            el: '#app',
            data: {
                abc: '父组件传递的数据',
                myJerry: 'my is jerry',
                arr: ['one', 'two', 'three'],
                myTom: {
                    names: 'tom',
                    age: 18
                }
            },
            methods: {
                chichichi(val) {
                    this.arr.push('红烧鱼')
                    console.log(val);
                }
            },
        })
    </script>
  ```
### 非父子组件传值
- 单独的事件中心管理组件间的通信   var eventHub=new Vue()
- 监听事件 和销毁事件
  - 监听事件 eventHub.$on()
  - 销毁事件 eventHub.$off()
- demo 兄弟组件间的传递
  ```html
    <div id='app'>
        <button @click="deljerry">销毁事件 销毁jerry</button>
        <button @click="deljadd">全部销毁</button>
        <hello-tom></hello-tom>
        <hello-jerry></hello-jerry>

    </div>
    <script>
        // 创建一个事件管理中心
        let hub = new Vue();
        // 子组件1
        Vue.component('hello-tom', {
            data() {
                return { num: 0 }
            },
            template: `
            <div>  
                <div>{{num}}</div>
                 <button @click='handle'>给兄弟组件jerry传值</button>
            </div>`,
            methods: {
                handle() {
                    // 通过事件中心触发 组件二中的数据
                    hub.$emit('event-jerry', 1)
                }
            },
            // 模板节点挂载完成 
            mounted() { //生命周期
                // 监听事件 自定义监听事件名 event-tom
                hub.$on('event-tom', (val) => {
                    this.num += val;
                })
            },
        })
        // 子组件2
        Vue.component('hello-jerry', {
            data() {
                return { num: 0 }
            },
            template: `
            <div>  
                <div>{{num}}</div>
                 <button @click='handle'>给兄弟组件tom传值</button>
            </div>`,
            methods: {
                handle() {
                    hub.$emit('event-tom', 2)
                }
            },
            // 模板节点挂载完成 
            mounted() { //生命周期
                // 监听事件 自定义监听事件名 event-tom
                hub.$on('event-jerry', (val) => {
                    this.num += val;
                })
            },
        })
        var vm = new Vue({
            el: '#app',
            data: {
                msg: '父组件中的内容',
                fontSize: 10,
            },
            methods: {
                deljerry() {
                    hub.$off('event-jerry')
                },
                deljadd() {
                    hub.$off('event-jerry')
                    hub.$off('event-tom')
                },
            },
        })
    </script>
  ```

## 插槽
- 作用域插槽和单个插槽和具名插槽的区别：
  - 因为单个插槽和具名插槽不绑定数据，所以父组件是提供的模板要既包括样式又包括内容的。而作用域插槽，父组件只需要提供一套样式
### 组件插槽 (默认插槽)
- `<slot></slot>` 是固定的 用于命名插槽
- 父组件向子组件传递内容
- 当父组件没有填入数据的时候 自动使用默认数据填充 （在有设置默认的情况下）
- demo
  ```html
    //父组件
    <template>
    <Son><p>父组件传递给子组件slot的值</p></Son>
    </template>

    //子组件
     <template>
     <slot>子组件中slot的默认值</slot>
    </template>
  ```
### 具名插槽 (命名插槽)
- `<slot></slot>`
- 通过给模板设置 slot 类名来区分 板块
- 在父组件中 带有相匹配的slot值 会被渲染到指定结构中
- demo
  ```html
   父组件中：
   <Category>
       <template slot="center">
         <div>html结构1</div>
       </template>

       <template v-slot:footer>
          <div>html结构2</div>
       </template>
   </Category>
   子组件中：
   <template>
       <div>
          <!-- 定义插槽 -->
          <slot name="center">插槽默认内容...</slot>
          <slot name="footer">插槽默认内容...</slot>
       </div>
   </template>
  ```
### 作用域插槽
- 作用域插槽其实就是带数据的插槽，即带参数的插槽，
- 简单的来说就是子组件提供给父组件的参数，该参数仅限于插槽中使用，
- 父组件可根据子组件传过来的插槽数据来进行不同的方式展现和填充插槽内容。
- demo
  ```html
     <div id='app'>
        <!-- id 为1 的改变了字体颜色并且使用strong标签渲染  其余的不符合条件使用了a元素渲染 -->
        <!-- slot-scope 获取到子组件的值  -->
        <list :lists="lists">
            <!-- <template slot-scope="aaa"> -->
            <template v-slot:default="aaa">
                <strong v-if="aaa.info.id==1" :style="{color:'lightblue'}">{{aaa.info.name}}</strong>
                <a href="" v-else>{{aaa.info.name}}</a>
            </template>
        </list>
    </div>

    <script src='../js/vue.js'></script>
    <script>
        // slot-scope 在2.6，0版本已经废弃 可以使用 v-slot:default 插槽名 (可选，默认值是 default)
        // 作用域插槽 场景 父组件对子组件的内容进行加工处理
        Vue.component('list', {
            props: ['lists'],
            template: `
            
            <ul>
             <li v-for='item in lists' :key="item.id">
            <slot :info='item'>{{item.name}}</slot>    
            </li>    
            </ul>
            `
        })
        var vm = new Vue({
            el: '#app',
            data: {
                lists: [
                    {
                        id: 0,
                        name: '张三'
                    },
                    {
                        id: 1,
                        name: '李四'
                    },
                    {
                        id: 2,
                        name: '王五'
                    },
                ]
            },
            methods: {},
        })
    </script>
  ```
## ref 属性
1. 被用来给元素或子组件注册引用信息（id的替代者）
2. 应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）
3. 使用方式：
   1. 语法打标识 普通标签<p ref="tagP">一些文字</p>  组件<Son ref="son" />   
   2. 获取：this.$refs.xxx
## 混入 mixin
1. 功能：可以把多个组件共用的配置提取成一个混入对象（类似于封装 提高复用性）
2. 使用方式：
   第一步定义混合：
       {
           data(){....},
           methods:{....}
           ....
       }
   第二步使用混入：
   使用前需要调用文件
  全局混入：Vue.mixin(xxx)
	局部混入：mixins:['xxx']
- 注意事项
  - 如果引入的混入与当前组件发生数据冲突 当前组件的优先级更高
  - 相同的类型 以当前组件数据为主 没有的数据则进行引入
## 组件的自定义事件
1. 一种组件间通信的方式，适用于：子组件 ===> 父组件
2. 使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（事件的回调在A中）。
3. 绑定自定义事件：
   1. 第一种方式，在父组件中：<Demo @atguigu="test"/>  或 <Demo v-on:atguigu="test"/>
   2. 第二种方式，在父组件中：
          ```js
          <Demo ref="demo"/>
          ......
          mounted(){
             this.$refs.xxx.$on('atguigu',this.test)
          }
          ```
   3. 若想让自定义事件只能触发一次，可以使用once修饰符，或$once方法。
4. 触发自定义事件：this.$emit('atguigu',数据)		
5. 解绑自定义事件this.$off('atguigu')
6. 组件上也可以绑定原生DOM事件，需要使用native修饰符。
7. 注意：通过this.$refs.xxx.$on('atguigu',回调)绑定自定义事件时，回调要么配置在methods中，要么用箭头函数，否则this指向会出问题！
## 全局事件总线（GlobalEventBus）
1. 一种组件间通信的方式，适用于任意组件间通信。
2. 安装全局事件总线： (在 main.js 中进行安装)
      ```js
         new Vue({
       	......
       	beforeCreate() {
       		Vue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm
       	},
           ......
       }) 
      ```
3. 使用事件总线：
   1. 接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身。
         ```js
            methods(){
            demo(data){......}
          }
          ......
          mounted() {
            this.$bus.$on('xxxx',this.demo)
          }
         ```
   2. 提供数据：`this.$bus.$emit('xxxx',数据)`
4. 最好在beforeDestroy钩子中，用$off去解绑当前组件所用到的事件。

## 消息订阅与发布（pubsub）
## nextTick
- 语法：this.$nextTick(回调函数)
- 作用：在下一次 DOM 更新结束后执行其指定的回调。
- 什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行

## 基于promise的ajax
- demo
  ```js
        function promiseAjax(url) {
        let pm = new Promise((res, rej) => {
            let xhr = new XMLHttpRequest();
            xhr.onreadystatechange = () => {
                if (xhr.readyState != 4) return; //当状态不等于4的时候 直接退出 
                if (xhr.readyState == 4 && xhr.status == 200) {
                    // 处理正常的情况
                    res(xhr.responseText)
                } else {
                    // 处理异常情况
                    rej('服务器错误！')
                }
            }
            xhr.open('get', url);
            xhr.send();
        })
        return pm;
    }
    promiseAjax('http://localhost:3000/database1')
        .then(function (data) {
            console.log(data);
        }, function (info) {
            console.log(info);
        })
  ```
### 基于promise发送多次ajax
- demo
  ```js
         // 发送多个ajax请求 并保证请求的顺序
    promiseAjax('http://localhost:3000/database')
        .then(function (data) {
            console.log(data);
            // return 的是一个新的Promise实例对象
            // 下一个then的调用者就是上一个then return的promise实例对象
            // data 接收的是上一个异步任务处理完的结果
            return promiseAjax('http://localhost:3000/database1');
        }).then((data) => {
            console.log(data);
            return promiseAjax('http://localhost:3000/database2');
        }).then((data) => {
            console.log(data);
        })
  ```
### 使用Promise对象方法
- demo
  ```js
    // Promise.all() 并发处理多个异步任务，所有任务都执行完成才能得到结果
    // Promise.race() 并发处理多个异步任务， 只要有一个任务执行完成就能得到结果
    let p1 = promiseAjax('http://localhost:3000/a1');
    let p2 = promiseAjax('http://localhost:3000/a2');
    let p3 = promiseAjax('http://localhost:3000/a3');
    let all = Promise.all([p1, p2, p3]).then((data) => {
        console.log(data);
    })
    let ra = Promise.race([p1, p2, p3]).then((data) => {
        console.log(data);
    })
  ```
## 接口调用 fetch 方法
- text() 方法属于 fetch api的一部分 它返回一个Promise实例对象 用于获取后台返回的数据
- json() 方法 接收 JSON格式的数据
- demo 基本用法get
  ```js
   // 默认是发丝get请求
    // 方式1传参方式 传统url
    fetch('http://localhost:3000/fetch2?id=123', {
        method: 'get' //发送请求类型 get post put  delete
    }).then((data) => {
        // text() 方法属于 fetch api的一部分 它返回一个Promise实例对象 用于获取后台返回的数据
        console.log(data);
        return data.text();
    }).then(data => {
        console.log(data);
    })
    // 方式2 需要服务器端设置 接收方式
    /*
    app.get('/fetch3:id', (req, res) => {
    res.send('fetch3 Restful形式的url传递参数 id=' + req.params.id)
        })
    **/
    fetch('http://localhost:3000/fetch3:456', {
        method: 'get' //发送请求类型 get post put  delete
    }).then((data) => {
        // text() 方法属于 fetch api的一部分 它返回一个Promise实例对象 用于获取后台返回的数据
        return data.text();
    }).then(data => {
        console.log(data);
    })
    //接收数据格式
    /* 服务器设置返回数据格式为json app.get('/fetch5', (req, res) => {res.json({name: '张三',sex: '男',age: 18,})})*/
    fetch('http://localhost:3000/fetch5').then((data) => {
    // return data.text();
    return data.json();
    }).then(data => {
        // let jo = JSON.parse(data) //当使用text() 接收返回值的时候为字符串格式 转换为JSON格式
        // console.log(jo);
        console.log(data);
    })
  ```
- demo post请求方式
  ```js
     fetch('http://localhost:3000/fetch4', {
         method: 'post', //发送请求类型 get post put  delete
         body: 'name=张三&age=18',
         headers: {
             'Content-Type': 'application/x-www-form-urlencoded'
         }
     }).then((data) => {
         // text() 方法属于 fetch api的一部分 它返回一个Promise实例对象 用于获取后台返回的数据
         return data.text();
     }).then(data => {
         console.log(data);
     })


    // json 格式 需要改变body 传递方式  和 请求头 改为json

    // 使用JSON时候的报错 Uncaught (in promise) TypeError: Failed to fetch
    // 服务器解决跨域问题 res.header("Access-Control-Allow-Headers", "X-Requested-With,Content-Type,mytoken");
    fetch('http://localhost:3000/fetch4', {
        method: 'post', //发送请求类型 get post put  delete
        body: JSON.stringify({
            name: '李四',
            age: '19',
        }),
        headers: {
            'Content-Type': 'application/json'
        }
    }).then((data) => {
        // text() 方法属于 fetch api的一部分 它返回一个Promise实例对象 用于获取后台返回的数据
        return data.text();
    }).then(data => {
        console.log(data);
    })
  ```
## 接口调用 axios 方法
- demo
  ```js
    //基础使用方法
        axios.get('http://localhost:3000/axios1')
        .then(res => {
            // 注意data属性是固定的用法 用于获取后台的实际数据
            console.log(res.data)
        })
        .catch(err => {
            console.error(err);
        })
        //通过 params 传参
        axios.get('http://localhost:3000/axios2', {
        params: {
            id: 789,
        }
        })
        .then(res => {
            // 注意data属性是固定的用法 用于获取后台的实际数据
            console.log(res.data)
        })
        .catch(err => {
            console.error(err);
        })
    //  传统url传参
    axios.get('http://localhost:3000/axios2?id=123')
        .then(res => {
            console.log(res.data)
        })
        .catch(err => {
            console.error(err);
        })
        // 后台使用 restful 接收参
        /** 后台 app.get('/axios3:id', (req, res) => { res.send('hello axios id=' + req.params.id)})*/
     axios.get('http://localhost:3000/axios3:789')
         .then(res => {
             console.log(res.data)
         })
         .catch(err => {
             console.error(err);
         })
           //  post
        axios.post('http://localhost:3000/axios4', {
            names: '张三',
            age: 18,
        })
            .then(res => {
                // 注意data属性是固定的用法 用于获取后台的实际数据
                console.log(res.data)
            })
            .catch(err => {
                console.error(err);
            })
         // 通过 URlSearchParams 传递参数  (application/x-www-form-urlencoded)格式
        const params = new URLSearchParams();
        params.append('names', '李四')
        params.append('age', 18)
        axios.post('http://localhost:3000/axios4', params)
        .then(res => {
            console.log(res.data)
        })
        .catch(err => {
            console.error(err);
        })

  ```
### axios 配置
- 配置请求的基准url地址
  - ` axios.defaults.baseURL = 'http://localhost:3000/';`
    - 调用的时候  `axios.get('axios5')` 省略前缀
- 设置请求头 `axios.defaults.headers['mytoken'] = 'hello world' //设置请求头`
- 设置响应超时时间 `axios.defaults.timeout=200;`
### 拦截器
- 请求拦截 在请求发出之前设置一些信息
  - demo
    ```js
            axios.interceptors.request.use(config => {
            // 在请求发出之前进行一些信息的设置
            return config;
        }, error => {
            // 处理响应错误的信息
            return Promise.reject(error);
        });
    
        axios.get('http://localhost:3000/axios5')
            .then(res => {
                console.log(res.data)
                console.log(res.data.names)
            })
            .catch(err => {
                console.error(err);
            })
    ```
- 响应拦截 在获取数据之前对数据做一些加工处理
  - demo
    ```js
        axios.interceptors.response.use(res => {
        // 在这里对返回的数据进行处理
        var data = res.data;
        return data; //直接返回data数据 
    }, error => {
        // 处理响应错误的信息
        return Promise.reject(error);
    });
    axios.get('http://localhost:3000/axios5')
        .then(data => {
            // 经过拦截器处理后 可以直接使用data获取数据 不用res.
            console.log(data)
            console.log(data.names)
        })
        .catch(err => {
            console.error(err);
        })
    ```
### async和await
- async 关键字用于函数上 async函数的返回值是promise 实例对象
- await 关键字用于async函数当中 await可以得到异步的结果
- demo
  ```js
    //基础用法
    axios.defaults.baseURL = 'http://localhost:3000/'
    async function tests() {
        let ret = await axios.get('axios5')
        return ret.data
        // console.log(ret.data.names);
    }
    tests().then(ret => {
        console.log(ret.names);
    })

    //async和await多个异步任务处理方式
    axios.defaults.baseURL = 'http://localhost:3000/'
    async function tests() {
        let async1 = await axios.get('async1');
        let async2 = await axios.get('async2?async1=' + async1.data); //将接口返回的值 在传给接口二进行处理
        return async2.data
        // console.log(ret.data.names);
    }
    tests().then(data => {
        console.log(data);
    })
  ```
### 关于响应
- data 实际响应回来的数据
- headers 响应头信息
- status 响应状态码
- statusText 响应状态信息
## promise封装 axios
- demo 举例 
  ```js
  //需求：获取到第一个axios 中回调的数据 在发送请求
       function get(url, data) {
            return new Promise(() => {
                axios.get(url, {
                    prompt: data,
                    headers: {}
                })
            })
        }
        get('url1', { a: 123 })
            .then(res => {
                return get('url2', { a: res.data })
            })
            .then()
        get(url值,data数据)


  ```
## promise封装 async
- demo 举例
  ```js
        //需求：获取到第一个axios 中回调的数据 在发送请求
        async function as(url, data) {
            let res = await axios.get(url, data);
            let req = await axios.get('url2', res);
            return req;
        }
        as(url,data)

  ```


# Vue-Router 的使用
### 简介
### 注意事项
1. 路由组件通常存放在pages（view）文件夹，一般组件通常存放在components文件夹。
2. 通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。
3. 每个组件都有自己的$route属性，里面存储着自己的路由信息。
4. 整个应用只有一个router，可以通过组件的$router属性获取到。
### 模拟前端路由
- SPA (Single Page Application)
  - 后端路由（接口 性能问题）
  - 前端路由 (解决前端页面渲染性能问题)
  - 前端路由的核心
    - 基于URL地址的hash (hash的变化会导致浏览器记录访问历史的变化、
        但是hash的变化不会触发新的URL请求)在实现SPA过程中，最核心的技术点就是前端路由
- :is 属性指定的组件名称 把对应的组件渲染到 component 标签所在位置
- <component></component>  标签可以当做是组件的占位符
-  window.onhashchange  当 一个窗口的 hash （URL 中 # 后面的部分）改变时就会触发 hashchange 事件
-  window.location.hash   获取到最新的hash值
- demo 模拟前端路由的切换效果
  ```html
    <div id='app'>
        <!-- 切换组件的超链接 -->
        <a href="#one">ONE</a>
        <a href="#two">TWO</a>
        <a href="#three">THERR</a>
        <a href="#four">FOUR</a>
        <component :is="Page"> </component>
    </div>
    <script>
        // 组件
        const one = {
            template: '<h1>页面1</h1>'
        }
        const two = {
            template: '<h1>页面2</h1>'
        }
        const three = {
            template: '<h1>页面3</h1>'
        }
        const four = {
            template: '<h1>页面4</h1>'
        }
        var vm = new Vue({
            el: '#app',
            data: { Page: 'one' },
            components: { //注册私有组件
                one,two,three,four
            }
        })
        // 监听window 的 onhashchange  事件 根据获取到的最新的 hash 值 切换要显示的组件名称
        window.onhashchange = function () {
            // 通过location.hash 获取到最新的hash值
            console.log(location.hash);
            //判断当前 url更换 hash值（#xxx） 进行匹配 
            switch (window.location.hash) {
                case '#one': vm.Page = 'one'
                    break;
                case '#two': vm.Page = 'two'
                    break;
                case '#three': vm.Page = 'three'
                    break;
                case '#four': vm.Page = 'four'
                    break;
            }
        }
  ```
### vue-Router vue路由 的使用
- 安装 yarn add vue-router  vue2只能使用@3版本 vue3可以使用最新版本
- <router-link></router-link>     是vue 中提供的标签 默认会被渲染为a标签
- <router-link to="/one">ONE</router-link>    to 属性默认被渲染为href属性   to属性的值默认会被 渲染为 以 # 开头的 hash 地址
- <router-view></router-view>       路由占位符 (路由填充位) 通过路由规则匹配到的组件 将会被渲染到 router-view 所在的位置
- `const router = new VueRouter({})`      创建路由实例对象
  - 每个路由规则都是一个配置对象 其中至少包括 path 和 component 两个属性
  - routes 路由规则数组
    - path 表示当前路由 匹配的 hash 地址
    - component 表示当前路由规则对应要展示的组件
    - name 命名路由
    - meta:{} 设置元数据 （自定义数据 可用于进行权限管理判断）
    - children:[{}] 嵌套路由 
### 基础用法
1. 安装vue-router，命令：npm i vue-router
2. 应用插件：Vue.use(VueRouter)
3. 编写router配置项:
```js
  //引入VueRouter
  import VueRouter from 'vue-router'
  //引入Luyou 组件
  import About from '../components/About'
  import Home from '../components/Home'

  //创建router实例对象，去管理一组一组的路由规则
  const router = new VueRouter({
  	routes:[
  		{
  			path:'/about',
  			component:About
  		},
  		{
  			path:'/home',
  			component:Home
  		}
  	]
  })
  //暴露router
  export default router
```
4. 实现切换（active-class可配置高亮样式）
  `<router-link active-class="active" to="/about">About</router-link>`
5. 指定展示位置 `<router-view></router-view>` 路由占位符
### 路由的嵌套
- children 属性 添加子路由规则 children:[{path:'xxx',component:'xxx'},{}]
- 需要注意 children中 **子路由path路径不要在写 /**
- 但是跳转的时候 path 路径要写全
- demo
  ```js
        routes:[
    	{
    		path:'/about',
    		component:About,
    	},
    	{
    		path:'/home',
    		component:Home,
    		children:[ //通过children配置子级路由
    			{
    				path:'news', //此处一定不要写：/news
    				component:News
    			},
    			{
    				path:'message',//此处一定不要写：/message
    				component:Message
    			}
    		]
    	}
    ]

    //跳转（要写完整路径）：
    <router-link to="/home/news">News</router-link>
  ```
### vue-Router 重定向
- 重定向(Redirect)就是通过各种方法将各种网络请求重新定个方向转到其它位置
- redirect 属性 指定一个新的路由地址 键值对形式 redirect:'/xxx'
- demo
  ```js
    const router = new VueRouter({
        routes: [//routes路由规则数组
            // path 当原地址为 /  使用 redirect 重定向为 /one 地址
            // redirect 属性 指定一个新的路由地址
            { path: '/', redirect: '/one' },
            { path: '/one', component: One },
        ]
    })
  ```
### 命名路由  简化路由的跳转
- 命名路由就是为了更加方便的表示路由的路径 给路由规则起一个别名 
- demo
  ```js
    {
    	path:'/demo',
    	component:Demo,
    	children:[
    		{
    			path:'test',
    			component:Test,
    			children:[
    				{
              name:'hello' //给路由命名
    					path:'welcome',
    					component:Hello,
    				}
    			]
    		}
    	]
    }
    //简化跳转
    //简化前，需要写完整的路径
    <router-link to="/demo/test/welcome">跳转</router-link>

    //简化后，直接通过名字跳转
    <router-link :to="{name:'hello'}">跳转</router-link>

    //简化写法配合传递参数
    <router-link 
    	:to="{
    		name:'hello',
    		query:{
    		   id:666,
                title:'你好'
    		}
    	}"
    >跳转</router-link>
  ```
### 通过路由组件传参

#### query 传参 
- 通过query传参两种形式 1.字符串形式 2.对象形式
- 接收query参数 `$route.query.xxx`
- 也可以使用命名路由来规定跳转页 name:'xxx'  （前提是 routes中给组件配置了name）
- demo
  ```js
        //从当前页 message 跳转到 detail页面 并携带参数
        // 跳转路由并携带query参数 to的字符串写法
        <router-link :to="`/home/message/detail?id=${m.id}&message=${m.message}`">
          {{ m.message }}
        </router-link>

        //跳转路由并携带query参数 to的对象写法 
        <router-link
          :to="{
            path: '/home/message/detail', //也可以使用命名路由来规定跳转页 name
            query: {
              id: m.id,
              message: m.message,
            },
          }"
        >
          {{ m.message }}
        </router-link>

        //detail 页面 接收参数
        <div>{{ $route.query.id }}</div>
        <div>{{ $route.query.message }}</div>
  ```

#### params 传参
- 首先在 路由配置中提前在path上 设置占位符 /:xxx 形式
- **特别注意 使用 params 对象写法时 不能使用path类型路径  只能使用命名路由 name**
- demo
  ```js
  //配置
    const routes = [
    {
      path: '/home',
      component: Home,
      children: [
        {
          path: 'message',
          component: Message,
          children: [
            {
              name: 'detail', //命名路由
              path: 'detail/:id/:message', //params传参 提前设置占位符声明接收params参数
              component: Detail,
            },
          ]
        },
      ]
    },
  ]

  //传参
  //跳转路由并携带 params 参数 to的字符串写法
        <router-link :to="`/home/message/detail/1234/abcd`">
          {{ m.message }}
        </router-link>

  //跳转路由并携带 params 参数 to的对象写法
  //特别注意 使用 params 对象写法时 不能使用path类型路径  只能使用命名路由 name
        <router-link
          :to="{
            name: 'detail',
            params: {
              id: m.id,
              message: m.message,
            },
          }"
        >
          {{ m.message }}
        </router-link>
  // 接收参数  同query
   <div>{{ $route.params.id }}</div>
    <div>{{ $route.params.message }}</div>
  ```

#### props 传参
- 谁接收参数 就给谁routes上配置 props
- props 的值为布尔类型  props:true/false 设置为true时 route.params 将会被设置为组件属性
  - 在组件中同样使用 props:['xxx'] 接收 路由参数（）
- 传参形式 
  - 1.props 为布尔形式    布尔值为真 就会把该路由组件收到的所有 params 参数 以props的形式传给 对应 组件
  - 2.props 值为对象形式  值为对象 该对象中的所有key-value 都会以props的形式传给 对应 组件  **为对象形式的时候 动态路由的 hash路径值获取不到**
  - 3.props 值为函数形式  传参形式query
- props为布尔值时 使用params 为函数时 使用query
- demo
  ```js
          {
      path: '/home',
      component: Home,
      children: [
        {
          path: 'message',
          component: Message,
          children: [
            {
              name: 'detail', //命名路由
              // path: 'detail/:id/:message', //占位 params   props为布尔值时 
              path: 'detail',
              component: Detail,
              // 方式1 值为对象 该对象中的所有key-value 都会以props的形式传给detail组件
              // props: { a: 1, b: 2 }
              // 方式2 值为布尔值 布尔值为真 就会把该路由组件收到的所有 params 参数 以props的形式传给detail组件
              // props: true
              // 方式3 值为函数
              // 普通写法
              /*  props (route) {
                 return {
                   id: route.query.id,
                   message: route.query.message
                 }
               } */
              //  简写形式 简单解构赋值
              /*   props ({ query }) {
                  return {
                    id: query.id, message: query.message
                  }
                } */
              // 连续解构赋值
              props ({ query: { id, message } }) {
                return {
                  id, message
                }
              }
            },
          ]
        }
      ]


      //传参
      //props为布尔值时 使用params 为函数时 使用query
       <router-link
          :to="{
            name: 'detail',
            query: {
              id: m.id,
              message: m.message,
            },
          }"
        >
          {{ m.message }}
        </router-link>
      </li>

  ```
### <router-link>的replace属性
- 控制路由跳转时操作浏览器历史记录的模式
- 1. 浏览器的历史记录有两种写入方式：分别为push和replace，push是追加历史记录，replace是替换当前记录。路由跳转时候默认为push
- 2. 开启replace模式：`<router-link replace .......>News</router-link>`
### 编程式路由导航
- 不借助<router-link>实现路由跳转，让路由跳转更加灵活
- this.$router.push('/xxx') 跳转到指定的url路径
- this.$router.replace('/xxx') 跳转到指定的url 路径, 但是history 栈中不会有记录, 点击返回就会跳转到上上个页面, (就是直接替换了当前的页面)
- demo
  ```js
  //触发事件调用进行跳 并携带参数 接收参数同样使用 props
    methods: {
    pushShow(m) {
      this.$router.push({ //push 会记录跳转历史
        name: "detail",
        query: {
          id: m.id,
          message: m.message,
        },
      });
    },
    replaceShow(m) {
      this.$router.replace({ //replace 不会记录跳转历史 直接替换
        name: "detail",
        query: {
          id: m.id,
          message: m.message,
        },
      });
    },
    },
  ```
### 横跨历史 （页面的前进后退）
- this.$router.forward() //前进
- this.$router.back() //后退
- this.$router.go(+-n) 向前或者向后跳转n个页面,  n 可以为正整数也可以为负整数
- demo
  ```js
    <template>
    <div>
      <button @click="back">后退</button>
      <button @click="forward">前进</button>
      <button @click="go">go 回退3个页面</button>
    </div>
    </template>

    methods: {
    back() {
      this.$router.back();
    },
    forward() {
      this.$router.forward();
    },
    go() {
      // 正为前进 负为后退
      this.$router.go(-3);
    },
   
  },
      
  ```
### keep-alive 缓存路由组件  
- 让不展示的路由组件保持挂载，不被销毁
- **填写的组件名 为组件内的name**
- 如果不使用 include 指定需要缓存的路由组件名 那么当前组件内的所有子组件都将进行缓存 不被销毁
- `include="item1"` 为需要缓存的路由组件 （单个）
- `:include="['item1', 'item2']"` （多个）
- demo
  ```js
    <keep-alive include="item1"> 
    <router-view></router-view>
    </keep-alive>
  ```
### 路由独有的两个生命周期 **activated  deactivated**
- 路由组件所独有的两个钩子，用于捕获路由组件的激活状态
- activated 路由组件被激活时触发
- deactivated 路由组件失活时触发
- 场景：当组件使用了 keep-alive 缓存了当前路由组件 当前组件中有一个定时器 进入时开始执行，退出时关闭，因为缓存了组件 导致离开当前页面时无法销毁当前组件，定时器也无法清除了 此时使用 这两个生命周期刚好解决问题
- demo
  ```js
    activated() {
    console.log("组件被激活");
    this.timer = setInterval(() => {
      console.log("🤪");
      this.opacity -= 0.01;
      if (this.opacity < 0) this.opacity = 1;
    }, 16);
    },

    deactivated() {
      console.log("组件失效");
      // 清除定时器
      clearInterval(this.timer);
    },
  ```
### **路由守卫**
1. 作用：对路由进行权限控制
2. 分类：全局守卫（全局前置后置）、独享守卫、组件内守卫
3. 在路由文件中进行设置 router/index.js

#### 全局前置路由守卫
- 全局前置路由守卫 初始化的时候被调用一次 每次路由切换之前被调用
- 语法：` router.beforeEach((to,from,next)=>{})`
  - form  表示来自于哪里
  - to    表示去哪里
  - next()  表示执行下去
- routes 中配置 meta{isAuth:true} 元信息 用于判断 通过 to.meta 可以获取到设置的元信息
- 权限判断流程：当点击页面时进行判断该页面是否是需要权限的页面 不需要则直接访问 需要则在进行下一步判断 进入校验 判断token（这里使用localStorage模拟）token合法则有权限访问
- demo
  ```js

    //设置元数据
     {
        path: 'news',
        name: 'news',
        component: News,
        meta: { isAuth: true, title: '新闻' } //设置元数据
    },

    router.beforeEach((to, from, next) => {
      console.log('前置路由守卫', to, from);
      // if (localStorage.getItem('test') === 'abcd') next()

      // 单独限制 两个页面需要权限才可以访问 其他的都可以访问
      // 使用path路径判断 也可以使用 name 路由命名判断
      // 方式1 to.path === '/home/news' || to.path === '/home/message'
      // 方式2 通过自定义 meta{} 自定义元信息 在进行校验
      if (to.meta.isAuth) { //判断是否需要鉴权
          // 判断 缓存中是否有该对应的值
        if (localStorage.getItem('test') === 'abcd') {
          next()
        } else {
          alert('无权访问😀');
        }
      } else {
      
        next()

      }
    })
  ```
#### 全局后置路由守卫
- 全局后置路由守卫 初始化的时候被调用一次 每次路由切换之后被调用
- 语法：` router.afterEach((to,from)=>{})`  后置没有 next 因为切换之后才会触发
- demo
  ```js
  router.afterEach((to, from) => {
    console.log('后置路由守卫', to, from);
    // 到这里使用意味着 一定切换完毕 所以可以进行操作
    document.title = to.meta.title || '浏览器页签标题名字'
  })
  ```
#### 独享路由守卫
- 对单个页面进行守卫 所以将规则写到当前路由上即可
- 语法： ` beforeEnter (to, from, next) {}`
- 独享路由守卫只有前置 没有后置  但是可以配合 全局后置使用
- demo
  ```js
     {
        path: 'news',
        name: 'news',
        component: News,
        meta: { isAuth: true, title: '新闻' },
        beforeEnter (to, from, next) {
          if (to.meta.isAuth) { //判断是否需要鉴权
            if (localStorage.getItem('test') === 'abcd') {
              next()
            } else {
              alert('无权访问😀');
            }
          } else {
            next()
          }
        }
      },
  ```
#### 组件内守卫
- beforeRouteEnter (to, from, next) {}   进入守卫：通过路由规则，进入该组件时被调用
- beforeRouteLeave (to, from, next) {}   离开守卫：通过路由规则，离开该组件时被调用
- demo
  ```js
     beforeRouteEnter(to, from, next) {
    if (to.meta.isAuth) {
      //判断是否需要鉴权
      if (localStorage.getItem("test") === "abcd") {
        next();
      } else {
        alert("无权访问😀");
      }
    } else {
      next();
    }
    },
  beforeRouteLeave(to, from, next) {
    console.log(to, from);
    next();
  },
  ```
### hash 和 history 路由器的两种工作模式   
1. 对于一个url来说，什么是hash值？#及其后面的内容就是hash值
2. hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器
3. hash模式：
   1. 地址中永远带着#号，不美观 
   2. 若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法
   3. 兼容性较好。
4. history 模式：
   1. 地址干净，美观 。
   2. 兼容性和hash模式相比略差。
   3. 应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。
   4. 使用nodejs部署时 解决history的404 安装包  yarn add connect-history-api-fallback
### 动态路由
- 动态的路径参数 以冒号开头 :xxx   
- demo
  ```html
    <div id='app'>
        <router-link to="/one/a">ONE1</router-link>
        <router-link to="/one/b">ONE2</router-link>
        <router-link to="/one/c">ONE3</router-link>
        <router-link to="/one/d">ONE4</router-link>
        <router-link to="/two">TWO</router-link>
        <router-view></router-view>
    </div>
    <script>
        // 组件
        const One = {
            // 在 VueRouter 实例外 使用 route 前面要加 $
            // $route.params.id 获取路由参数
            template: '<h1>页面1 里面的第{{$route.params.abc}} 个</h1>'
        }
        const Two = {
            template: '<h1>页面2</h1>'
        }
        // 创建路由实例对象
        const router = new VueRouter({
            routes: [
                //动态的路径参数 以冒号开头 :xxx  不是固定的 
                { path: '/one/:abc', component: One },
                { path: '/two', component: Two }
            ]
        })
        var vm = new Vue({
            el: '#app',
            router,
        })
    </script>
  ```
## 其他
- 调试工具中 一个 root 代表一个vue实例对象

### Object.defineProperty(obj, prop, descriptor) 方法详情与案例
- 语法
  - obj：要定义属性的对象
  - prop：要定义或修改的属性的名称或 Symbol
  - descriptor：要定义或修改的属性描述符
    - get(){return value}  属性的  getter方法
    - set(value){}   属性的 setter方法
- demo
    ```js
    // 需求：
    // 1．给p添加一个新的属性: fullName= firstName + '-' + lastName
    // 2．如果修改了firstName/lastName,furllName自动改变为对应的值
    // 3．如果修改了fullName，firstName和lastName也自动改变为对应的值

    const p = {
        firstName: 'A',
        lastName: 'B'
    }

    Object.defineProperty(p, 'fullName', {

        get() {
            //*函数回调的三个问题?  什么时候执行?  用来做什么?  this指向谁 
            // 当读取属性值时自动调用set() ,将函数的返回值作为属性值，this是属性值所在的对象
            console.log(this);
            // return p.firstName + "-" + p.lastName
            return this.firstName + "-" + this.lastName
        },
        set(value) {
            // 当修改了属性值时自动调用set()，用来监视属性值的变化，this是属性所在的对象
            console.log(this);

            console.log(value);

            // 当set()执行说明fullName发生改变 获取到改变值 分割分别赋值
            const names = value.split('-')

            this.firstName = names[0]
            this.lastName = names[1]

        }
    })

    // 完成第一步
    console.log(p.fullName); //A-B
    // 完成第二步
    p.firstName = 'C'
    p.lastName = 'D'
    console.log(p.fullName); //A-B

    // 第三步
    p.fullName = 'Y-Z'

    console.log(p.firstName, p.lastName);

    ```


### event.target 触发事件的对象 (某个DOM元素) 的引用
-  event.target.tagName 返回元素名

###
- methods:{} 
  - 在methods中需要对data内部的数据发生更新 需要获取实例上的属性 才可以修改
  - 在methods中使用es6箭头函数 this指向为 window 使用普通函数 this指向为Vue实例

- el 指定element选择器
  - 提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例

### 全局配置
- 设置使用开发版本vue.js 不显示提示 `Vue.config.productionTip = false`

### 
- vue 中 但凡由vue所管理的函数，都不要写成箭头函数 否则会指向 window 而不指向 vue实例
### 什么是数据响应式？
- 1.data数据发生变化 页面渲染也发生变化 
- 2.页面渲染发生变化 data数据也发生变化
###
- some和every对数组的遍历：some是数组中只要有一个符合条件就返回true，every是每一个元素都符合条件才返回true，否则返回false

# VUEX
## 简述
- vuex是实现集中式状态（数据）管理的一个vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读/写）,也是一种组件间通信的方式
    且适用于任意组件间的通信
- Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化
- Vuex 是实现组件全局状态(数据)管理的一种机制,可以方便的实现组件之间数据的共享。
- Vuex其实就是一个为Vue.js设计的数据仓库，就是把各个组件公用的数据放到一个仓库里面进行统一的管理，这样既使得非父子组件间的数据共享变得简单明了，也让程序变得更加可维护（将数据抽离了出来）,而且只要仓库里面的数据发生了变化，在其他组件里面数据被引用的地方也会自动更新。
- 为什么要用vueX
  - 能够在vuex中集中管理共享的数据,易于开发和后期维护
  - 能够高效地实现组件之间的数据共享,提高开发效率存储
  - 在vuex中的数据都是响应式的,能够实时保持数据与页面的同步,
- Vuex适用于开发大型单页的应用上
- Vuex的数据 都是响应式的
- **vuex的缺点**
  - **刷新浏览器，vuex中的state会重新变为初始状态**   解决方案-插件vuex-persistedstate
    
## vuex核心
- state 提供唯一的公共数据源,所有共享的数据都要统一放到 $store的state中进行存储。
  - 组件访问 state中的数据 
    - 方式1 ` this.$store.state.全局数据名称 `
    - 方式2  将当前组件需要的全局数据 映射为当前组件的 computed计算属性
        ` import {mapState} from 'vuex'
          computed:{
          ...mapState(['名称'])
          }
          <templae>{{名称}}</template>
        `
     ```js
      export default createStore({
      // 公共数据源
      state: {
        count: 0
      },
      getters: {},
      mutations: {},
      actions: {},
      modules: {}
      })
      // vue 文件中 {{当中省略this}}
      <h1>{{$store.state.全局数据名称}}</h1>
     ``` 
- mutations 用于变更  $store  数据
  - 只能通过 mutation 变更 $store 数据,不可以直接操作 $store 中的数据。
  - 通过这种方式虽然操作起来稍微繁琐一些,但是可以集中监控所有数据的变化。
  - 触发 mutations 的方式
    - 方式1 ` this.$store.commit("add"); ` commit 作用是调用某个 mutation 函数
    - 方式2 通过 导入的 mapMutations 函数 将需要的 mutations 函数 隐射为当前组件的methods的方法
      `
      import {mapMutations} from 'vuex'
      methods: {
        ...mapMutations(["方法1", "方法2"]),
        btn() {
        this.方法1(); 
        //同时也可以传参 
        //this.方法2(123);
        },
      }
      `
        - 方式二可以 进行简化 可以在触发时 直接调用 mapMutations 映射来的函数 进行 使用也可以传参
          - `<button @click="方法1(123)">一个按钮</button>`
- actions 用于处理异步任务
  - actions 中不能直接修改 state的数据
  - 如果通过异步操作变更数据,必须通过action,而不能使用mutation,但是在action中还是要通过触发mutation的方式间接变更数据
  - 触发actions 方式
    - 方式1  使用 dispatch 触发 actions
      - demo 异步带参传递
        ``` js
            this.$store.dispatch("Async",step);

            // store 的action 接收处理
            actions:{
             Async(context, step) {
             setTimeout(() => {
             context.commit("add ", step);
             }, 1000);
            },
            }
        ```
    - 方式2 通过 导入的 mapActions 函数 将需要的action函数 隐射为当前组件的methods的方法 
      - demo
        ```js
        import {mapActions} from 'vuex'
        methods: {
        ...mapActions(["方法1", "方法2"]),
        btn() {
        this.方法1(); 
        //同时也可以传参 
        //this.方法2(123);
        },
      }
        ```
        - 方式二可以 进行简化 可以在触发时 直接调用 mapActions 映射来的函数 进行 使用也可以传参
          - `<button @click="方法1(123)">一个按钮</button>`
- getters 用于对 $store 中的数据进行监听加工处理形成新的数据  可以理解为 computed
  - getters可以对 $store 中已有的数据加工处理之后形成新的数据,类似Vue的计算属性
  -  $store 中数据发生变化, getters的数据也会跟着变化
  -  vue3.0之后 getter 无法像计算属性一样 进行缓存
  - 使用getters 方式1 `this.$store.getters.名称`
  - 使用getters 方式2 将当前组件需要的全局数据 映射为当前组件的 computed计算属性
    ` import {mapGetters} from 'vuex'
      computed:{
      ...mapGetters(['名称'])
      }
      <templae>{{名称}}</template>
     `
- modules 模块化 
  - 通过模块化形式 进行私有化vuex中的四种方法， 通过调用不同模块 去调用模块内部的方法
  - modules 是所有定义的每一个小模块的总和
  - 针对当应用变得非常复杂时，store 对象变得臃肿
  - demo 基础用法
    ```js
    //1. 在store 文件中 进行定义和导入模块
    // 定义一个单独的模块  在export default createStore外定义
    const moduleA = {
    state:{
        abc:123
    },
    };
    //向 modules导入模块
    export default createStore({
    modules: {
    cba:moduleA,
    },
    })

    //2.进行使用 ：组件访问 state中的数据 方式
    //方式1
    <p> {{ this.$store.state.cba }}</p>
    //可以省略this
    //this.$store.state.(modules中定义的模块名称).(state中的数据名)
    <p> {{ $store.state.cba.abc }}</p>

    //方式2
    //引入
    import { mapState } from "vuex";

    export default {
    //模块的使用方式与单个的形式相同 但在引入的时候 不是直接 引入 state中数据 而是模块名称
    //同时 在使用 {{}} 插值表达式时 需要 多一层 {{cba.abc}} 
    computed: {
    //   将当前组件需要的全局数据 映射为当前组件的 computed计算属性
    // 引入模块 时 直接引入 modules 中定义的模块名称 （cba:moduleA）
    ...mapState(["num", "cba"]),
    },
   }
  

    ```

# 其他
## 查看vue 版本 vue -V 或者 vue --version
## vite 构建工具 是一种新型前端构建工具，能够显著提升前端开发体验 
- 它是一个更加轻量（热更新速度快，打包构建速度快）的vue项目脚手架工具。
- 相对于vue-cli它默认安装的插件非常少，随着开发过程依赖增多，需要自己额外配置。
- 按需编译 不用等待整个应用编译完成
### 创建以及使用
- 创建项目 npm init vite-app 项目名称 或者 yarn create vite-app 项目名称
- 安装依赖 npm i 或者 yarn
- 启动项目 npm run dev 或者 yarn dev
## 重点知识 destroyed
- 生命周期执行顺序 ？
  - init->beforeCreate->created->beformMounted->mounted->init->beforeUpdate->updated->beforeDestroy->destroyed
  - init 为初始化
- Vue双向数据的原理？
  - VUE2是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调、
  - VUE3.0 通过 Proxy 来劫持数据，在数据变动时发布消息给订阅者，触发相应的监听回调
- v-for循环中的key值的作用？
  - key的作用主要是为了高效的更新虚拟dom，使用key来给每一个节点做唯一的标识
## 创键vue-cli脚手架方式
- 终端
  - vue create xxx项目名
  - Please pick a preset (预设配置)  Manually select features （手动选择功能）
  - Use history mode for router? 路由器是否使用历史模式？ y/n
  - Pick a linter / formatter config 选择一个linter/formatter配置 (ESLint配置)
    - ESLint with error prevention only  仅带错误预防的ESLint
    - ESLint + Airbnb config    ESLint+Airbnb配置
    - ESLint + Standard config  ESLint+标准配置
    - ESLint + Prettier         ESLint+更漂亮
  - Pick additional lint features: Lint on save 默认
  - Where do you prefer placing config for Babel, ESLint, etc.? 您更喜欢将Babel、ESLint等的配置放在哪里。？
  - Save this as a preset for future projects?   是否将其保存为未来项目的预设？

- ui界面创建vue项目
  - `vue ui`
## 组件 插件 包 
- 富文本 包  `vue-quill-editor`
  - 基于 Quill、适用于 Vue 的富文本编辑器，支持服务端渲染和单页应用。
# DEMO
- 通过路由传值到另一个页面 实现页面跳转并携带数据
  - demo
    ```js
    //传值页面
    updateShop (id) {
      this.$router.push({
        path: '/goods/update',
        query: {
          id
        }
      })
    }
    //接收页面
    const id = this.$route.query.id
    ```