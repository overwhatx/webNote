# Node.js
- 官网：https://nodejs.org/en/

## 什么是Nodejs
- Node.js 是一个基于 Chrome 谷歌V8 引擎的 JavaScript 运行环境
### 注意
- 浏览器是 javascript 的前端运行环境
- nodejs 是 javascript 的后端运行环境
- nodejs 中无法调用 dom和bom等浏览器内置 api
### nodejs 可以干什么
- 基于Express 框架(kttp://www.expressjs.com.cn/)，可以快速构建 Web 应用
- 基于 Electron 框架(https://electronjis.org/)，可以构建跨平台的桌面应用
- 基于restify 框架(http://restify.com/)，可以快速构建 API 接口项目
- 读写和操作数据库、创建实用的命令行工具辅助前端开发等......

## 优缺点
- 优点
  - 异步非阻塞的 I/O  (I/O 线程池)
  - 特别适用于 I/O  密集型应用
  - 事件循环机制
  - 单线程
  - 可以跨平台
- 缺点
  - 回调函数嵌套太多、太深 产生回调地狱问题
  - 单线程 处理不好 cpu 密集型任务

## Nodejs的安装
- 官网：https://nodejs.org/en/ 
  - LTS版本为稳定版本 Current为最新版本 （尽量安装稳定版）
- 标准化安装（傻瓜式）一路next即可
- 打开终端检测Nodejs 是否安装成功  输入：`node -v`  返回当前nodejs版本号

## fs 文件系统（File System） 通过node来操作系统中的文件
- 不带sync的是异步 带sync的是同步 异步都带 callback回调函数
### 文件的读写
- fs.readFile() 方法 用来读取指定文件中的内容
  ```js
    // 首先必须导入 fs 模块
    const fs = require('fs')

    // 以 utf8的编码格式 读取指定的内容 并打印 err和 dataStr
    // 参数1 读取文件的存放路径
    // 参数2 读取文件时 采用的编码格式 一般默认指定为 utf8
    // 参数3 回调函数，拿到读取失败和成功的结果 err dataStr
    fs.readFile('./files/1.txt', 'utf8', function (err, dataStr) {
      // 当读取成功 err 返回的值为 null
      // 当读取失败 err 返回的值为 错误对象 dataStr的值为 undefined
      console.log(err); //err
      console.log('--------');
      console.log(dataStr); //输出文本
    })
  ```
- fs.writeFile() 方法 用来指向指定的文件中写入内容
  - **注意点1 只能创建文件 不能创建路径**
  - **注意点2 重复调用fs.writeFile 写入一个文件 新写入的会覆盖之前的内容**
  ```js
    // 首先必须导入 fs 模块
    const fs = require('fs')

    // 参数1 指定一个文件路径的字符串
    // 参数2 表示要写入的内容
    // 参数3 可选参数 表示以什么格式写入文件内容 默认值 utf8
    // 参数4 回调函数
    fs.writeFile('./files/2.txt', 'hello XBG', 'utf8', function (err) {
    // 写入成功 err 返回值为 null
    // 写入错误 err 返回错误对象 （将盘符写为电脑没有的就可以报错 'V50:/files/2.txt'）
      console.log(err);
    })
  ```
- 读写demo
  ```js
    // 需求 将 成绩.txt 文件中 文本 ‘小红=99 小白=100 小黄=70 小黑=66 小绿=88’
    // 处理为 如下形式并写入到成绩ok.txt 新文件中
    /* 
    小红:99
    小白:100
    小黄:70
    小黑:66
    小绿:88
    */

    const fs = require('fs')

    fs.readFile('./demo/成绩.txt', 'utf8', function (err, value) {
    
      if (err == null) {
        let str = value.replaceAll("=", ':').split(' ').join('\r\n')
        console.log(str);
        fs.writeFile('./demo/成绩ok.txt', str, 'utf8', function (err) {
          if (err == null) console.log('写入成功');
        })
      }
    })
  ```
### fs 处理路径问题
- 在使用fs 模块操作文件时（读写都会），如果提供的操作路径是以./或./开头的相对路径时，很容易出现路径动态拼接错误的问题
- 原因:代码在运行的时候，**会以执行 node 命令时所处的目录**，动态拼接出被操作文件的完整路径
  ```js
    // 问题复现 文件结构 D盘：father文件 
    - demo文件夹
      - files 文件夹
        - 01.txt 文件
      - app.js 执行js 文件
    
    //使用如下代码去 获取 01.txt的文本内容
    const fs = require('fs')
    fs.readFile('./files/01.txt', 'utf8', function (err, dataStr) {
      console.log(err); //err
      console.log('--------');
      console.log(dataStr); //输出文本
    })

    // 重点在于 在那个文件下执行  一般情况下会在 demo 路径下执行 app.js 文件
    // 例如 demo文件夹的上一级目录为 father 然后在father 目录下进行执行
    // 执行命令为 node  demo/app.js （最终报错 找不到）
    // 实际执行的路径为 xxx盘：father/files/01.txt  （使用了当前位于目录位置路径+方法读取或写入的路劲进行了拼接） 最终导致 中间层的文件夹路径不存在引发了报错
    
    
  ```
- 解决方式1 将相对路径改为 绝对路径 这种方式 移植特别差不利于维护 
  ```js
    // // node 02.path/01.路径问题.js
    let url = 'D：/father/demo/files/01.txt'
    const fs = require('fs')
    fs.readFile(url, 'utf8', function (err, dataStr) {
      console.log(err); //err
      console.log('--------');
      console.log(dataStr); //输出文本
    })

    //了解
    // 如果使用如下路径 ：执行时注意符号 node .\02.path\01.路径问题.js
    // 在js 中 \ 为转义符 所以需要 使用两个 \\ 才能表示 \
    //let url = 'D：\\father\\demo\\files\\01.txt'
  ```
- 解决方式2  __dirname （推荐）
- __dirname+ 需要处理的文件 相对路径
- 使用 __dirname 后可以在任意的 目录下去执行文件
  ```js
     const fs = require('fs')
     console.log(__dirname);
     fs.readFile(__dirname + '/files/01.txt', 'utf8', function (err, dataStr) {
       console.log(err); //err
       console.log('--------');
       console.log(dataStr); //输出文本
     })
  ```

## path 模块
- path.join() 将多个路径片段拼接为完整的路径字符串
  - 可以有效的避免使用 + 号拼接路径造成的问题 （使用加号拼接时 ./ 会出问题）
  ```js
    const path = require('path')
    const fs = require('fs')
    let url = path.join('/a', 'b/c', '../', './d', 'e')
    console.log(url); // 输出 \a\b\d\e  
    //  ../ 会抵消前一个文件路径

    //demo
    fs.readFile(path.join(__dirname,'./files/01.txt'), 'utf8', function (err, dataStr) {
    console.log(err); //err
    console.log('--------');
    console.log(dataStr); //输出文本
    }) 

  ```
- path.basename(path,[’ext‘]) 获取路径中的文件名  
  - 可以获取路径中的最后一部分 经常通过这个方法获取路径中的文件名
  ```js
    //path.basename(path,[’ext‘])
    // path 必填 表示一个路径的字符串
    // ext 可选 表示文件的扩展名 字符串类型

    let path = require('path')
    let url = './files/01.txt'
    console.log(path.basename(url)); //返回 01.txt  将整个文件名返回
    console.log(path.basename(url, '.txt')); //返回 01  返回了 文件名 不带后缀
  ```
- path.extname('path') 获取路径中的文件扩展名
  ```js
    let path = require('path')
    let url = './files/01.txt'
    console.log(path.extname(url)); //.txt
  ```


## http内置模块
- http 模块是 Node,js 官方提供的、用来创建 web 服务器的模块。通过 http 模块提供的 http.createServer() 方法，就能方便的把一台普通的电脑，变成一台 Web 服务器，从而对外提供 Web 资源服务。
- 如果要希望使用 http 模块创建 Web 服务器，则需要先导入它: ` const http = require( "http' )`
- 创建第一个 简单的服务器
  ```js
    // 1. 导入 http 模块
    const http = require('http')

    // 2. 创建 web 服务器实例
    const serve = http.createServer()

    // 3. 为服务器实例绑定 request 事件 ，监听客户端请求
    serve.on('request', (req, res) => {
      console.log('成功响应');
      // req 是请求对象，它包含了与客户端相关的数据和属性
      // req.url 是客户端请求的 URL 地址 (端口号后面的地址)
      // req.method 是客户端的 method 请求类型
      // console.log(req);
      // console.log(req.url, req.method);

      // res 是响应对象，它包含了与服务器相关的数据和属性
      console.log(res);
      // res.end() 方法的作用:向客户端发送指定的内容，并结束这次请求的处理过程
      // 当调用 res.end0 方法，向客户端发送中文内容的时候，会出现乱码问题，此时，需要手动设置内容的编码格式
      // 为了防止中文显示乱码问题 需要设置响应头 Content-Type 值  text/html; charset=utf-8
      res.setHeader('Content-Type', 'text/html; charset=utf-8')
      // 进行响应
      res.end(`小八嘎:url:${req.url}, method:${req.method}`)

    })

    // 4. 启动服务
    // 调用服务器实例 .listen() 方法 既可启动当前的web服务器实例

    serve.listen(8080, function () {
      console.log('127.0.0.1:8080');
    })

    //终端使用 `node  被执行文件.js `  进行执行
    //或者安装 nodemon  可以让执行文件一直保持着执行状态



    // test----------------------------------
     // 引用 http模块
    let http = require('http'); //内置模块 http
    // console.log(http);

    // 创建服务器  第一个参数req 浏览器请求  第二个参数res服务器进行响应
    // 一次请求一次响应
    let server = http.createServer(function (req, res) {
        // 设定请求头支持万国码
        // writeHead 书写服务器请求头
        // 200 状态码 请求成功
        res.writeHead(200, {
            "Content-type": "text/html;charset=utf-8"
        })
        // 服务器发送响应
        // 服务器一旦不进行响应 页面进入假死状态
        res.end('服务器启动了123')
    })
    // 监听端口  3000为端口号 一个应用一个端口号
    server.listen(3000)

    // 开启服务 node 文件
    // strl+c 关闭服务器
  ```
- createServer((req,res)=>{})     创建服务器
- writeHead        书写服务器请求头
- end()              服务器输出响应
- listen(3000)     端口号
- 一次请求 一次响应 浏览器刷新一次就请求一次 服务器打开修改后需要重启
### 根据不同url 响应不同的html
```js
  // 1. 导入 http 模块
  const http = require('http')
  
  // 2. 创建 web 服务器实例
  const serve = http.createServer()
  
  // 3. 为服务器实例绑定 request 事件 ，监听客户端请求
  serve.on('request', (req, res) => {
    console.log('成功响应');
    const url = req.url
    // 定义返回的内容
    let content = '<h1>404 NOt found!</h1>'
  
    // 判断请求的url 根据不同url 设置不同返回的内容
    if (url === '/' || url === '/index.html') {
      content = '<h1>首页</h1>'
    } else if (url === '/about.html') {
      content = '<h1>关于页面</h1>'
    }
    // 为了防止中文显示乱码问题 需要设置响应头 Content-Type 值  text/html; charset=utf-8
    res.setHeader('Content-Type', 'text/html; charset=utf-8')
    // 进行响应
    res.end(content)
  
  })
  
  // 4. 启动服务
  // 调用服务器实例 .listen() 方法 既可启动当前的web服务器实例
  
  serve.listen(8080, function () {
    console.log('http://127.0.0.1:8080');
  })
```

## 模块化  CommonJS 是一套模块化规范
- 模块化指的就是将一个大的功能拆分为一个一个小的模块，通过不同的模块的组合来实现一个大功能。
- 内部外部模块
  - demo
    ```js
    let a = require('./a') // 外部模块
    let b = require('math') // 内部模块  node自带的模块 引用node自带的模块不需要写路劲
    ```
- **在node中一个js文件就是一个模块**
- **在node中每一个模块中的代码都是运行在一个独立的函数中的**
  - 进行验证`console.log(arguments.callee.toString());`
    - 返回的是`function (exports, require, module, __filename, __dirname){}`

- **模块的引用** 通过 require() 函数来引入外部的模块
  - demo
    ```js
    <!-- a.js文件 -->
    // require('.b/b.js') 引用模块的概念  a模块调用 b模块 
    var b = require('./b/b')   / require('./b/b.js') 可以省略后缀
    console.log(b); //我是b.js文件

    <!-- b.js文件 -->
    console.log('我是b.js文件')
    ```

- **模块的暴露** 通过 exports 导出变量 导出的是一个对象
- **默认情况下模块内部代码对于外部来说都是不可见的**，可以通过三种方式向外部暴露变量和函数
   - exports.xxx自定义=xxx值导出的是一个对象
     - `var a = 123; exports.abc = a;`  
   - module.exports ={} 模块导出 多个导出 **常用方式**
      - `let a = 123;  module.exports = {a,b}`
      - 多个变量的导出
       - demo
          ```js
          <!-- a文件 -->
            var b = require('./b');
            console.log(b);  //{ b: 123, c: [Function: c] }

          <!-- b文件 -->
          // 多个的导出 modlue.exports={}
          module.exports = {
              b,
              c
          }
          const b = 123;
          const c = function () {
          console.log(2);
               }
          ```
   - global全局  将变量定义到全局中  只能单个导出
     - node中没有window对象 因为运行环境在服务端中
     - demo
      ```js
      <!--  a文件 -->
        var b = require('./b');
        console.log(b); //输出{}
        // global全局 导出
        console.log(abc);

        <!-- b文件 -->
        const b = 123;
        global.abc = b;
      ```



- __filename  返回当前模块的文件名  当前文件的自身绝对路径
- __dirname;  返回当前模块的目录名  当前文件所在目录绝对路径
  - 使用__dirname与相对路径 进行拼接调用  在拼接相对路径前 多写一个 /
    - demo 
      ```js
      //a文件中的a 调用 b文件中的b
      <!-- a文件中的a.js -->
      let v = require(__dirname + '/../b/b')
      console.log(v);

      <!-- b文件中的b.js -->
      let b = 456;
      module.exports = b; 
      ```

## express  (node插件) Express就是运行在node中的用来搭建服务器的模块
### express的安装使用
#### 安装
  - npm init  初始化
  - npm i express --save --dev 下载
  - npm express -v 查看当前版本
#### 使用 
- app.use()是express 调用中间件的方法
- app.listen(端口号,(err)=>{}); 监听端口
##### 搭建一个简单的服务器
- demo
    ```js
    //搭建一个简单的服务器
    //引用内置模块
    const express = require('express')
    //创建服务器
    const app = express();
    //监听端口
    app.listen(3000, (err) => {
    if (!err) console.log('服务启动成功');
    else {
        console.log(err);
    }
    })

    //案例 带参数的请求
    const express = require('express')
    const { Server } = require('http')
    const app = express()
    app.get('/', (req, res) => {
      // query  获取页面上的get参数
      console.log(req.query); 
      //获取get路由后面?的参数 通过解构赋值
      const { name, age } = req.query
      //res.send 发送响应
      res.send(`欢迎${name}进来，您的年龄是${age}`);    
    })
    app.post('/', (req, res) => {
      res.send('POST请求')
    })
    app.listen(3000, () => {
      console.log('服务器启动成功'); 
    })

    ```
##### 路由
- 路由的理解
  - 路径和请求方法合起来一般被称为 API 端点（Endpoint）。而服务器根据客户端访问的端点选择相应处理逻辑的机制就叫做路由
  - 相同域名下,访问不同的地址
- '/' -为根路由  '/xxx'-一级路由 '/xxx/xxx'-二级路由 以此类推 路由层级不超过5级 否则嵌套过深
- demo
  ```js
  <!-- router 路由 -->
  // 引入exoress
  const express = require('express')
  // 添加路由对象
  let router = express.Router();
  // 挂载get路由
  router.get('/', (req, res) => {
      res.send('get首页')
  })
  // 挂载post路由
  router.post('/', (req, res) => {
      res.send('post首页')
  })
  // 将路由对象暴露
  module.exports = router;


  <!-- app -->
  // 引入exoress
  const express = require('express')
  // 创建服务对象
  const app = express();
  // 导入路由模块
  const router = require('./router');
  // app.use是express 调用中间件的方法
  app.use(router);
  app.listen(3000, (err) => {
      if (!err) console.log('服务启动成功');
      else {
          console.log(err);
      }
  })
- Router()

  ```
###### 动态路由
- demo
  ```js
    const express = require('express')

    const app = express();
    // :冒号表示动态路由 :冒号后面表示动态参数
    app.get('/meishi/:abc', function (req, res) {
        // params 获取页面上 get的动态路由
        let {
            abc
        } = req.params;
        res.send(`欢迎进入${abc}`)
    })
    app.post('/', function (req, res) {
        res.send('post请求')
    })
    app.listen(3000, (err) => {
        if (!err) console.log('服务启动成功');
        else {
            console.log(err);
        }
    })
  ```
##### express.static(文件路径) 静态资源管理 图片 css 文件 html文件
- **多个静态资源需要引用多次中间件调用**
- demo
  ```js
  const express = require('express')
  const app = express();
  //  多个静态资源需要引用多次中间件调用
  app.use(express.static('./public'))
  app.use(express.static('./html'))
  // 静态资源添加前缀
  app.use('/meishi', express.static('./css'))
  app.use(express.static('./js'))

  app.listen(3000, (err) => {
      if (!err) console.log('服务启动成功');
      else {
          console.log(err);
      }
  })
  ```

##### 中间件
- 中间件就是能够适用多个应用场景、可复用性良好的代码
- 中间件是按顺序执行的，因此在配置中间件时顺序非常重要，不能弄错
- 中间件在执行内部逻辑的时候可以选择将请求传递给下一个中间件，也可以直接返回用户响应
- demo
  ```js
  const express = require('express');
  const app = express();
  const a = function (req, res, next) {
      console.log('中间件');
      next()
  }
  app.use(a);
  app.get('/', (req, res) => {
      console.log('get log 首页1');
      res.send('首页2')
  
  })
  
  app.listen(3000, (err) => {
      if (!err) console.log("服务启动成功");
  })
  ```
- 中间件分为 全局中间件 和局部中间件
  - 全局中间件 调用方式: app.use(中间件函数) 
    - 客户端无论**发生任何的请求，到达服务器之后，都会触发的中间件 
    - demo
      ```js
      const express = require('express');
      const app = express();
      app.use((req, res, next) => {
          const time = Date.now();
          console.log(time);
          req.t = time;
          next();
      })
      app.get('/', (req, res, next) => {
          res.send('当前时间' + req.t);
          next();
      })
      app.listen(3000, (err) => {
          if (!err) console.log("服务启动成功");
      })
      ```
  - 局部中间件 使用 声明接收
    - 不需要使用 app.use() 调用的中间件，统称为 局部中间件
    - demo
      ```js
      const express = require('express');
      const app = express();

      const a = (req, res, next) => {
          console.log('a中间件');
          next();
      }
      const b = (req, res, next) => {
          console.log('b中间件');
          next();
      }
      app.get('/', [a, b], (req, res, next) => {
          res.send('首页');
      })
      app.get('/news', (req, res, next) => {
          res.send('新闻页');
      })

      app.listen(3000, (err) => {
          if (!err) console.log("服务启动成功");
      })
      ```
- **多个中间件的调用 使用逗号分隔 或者使用数组嵌套**
- **所有中间件 本质上 是一个function 处理函数**
- **next() 多个中间件连续调用的关键  表示将流转关系 转交 给 下一个中间/路由**
- **所有中间件中 必须优先调用 通过use方法调用的中间件 ，如果不是优先调用 之前调用的中间件必须 next()**
- 多个中间件之间 共用一份req,res 这样就可以利用上一个中间件 统一为req,res对象 添加 自定义的属性、方法 给 下一个中间件使用
- 必须在 路由之前 注册中间件
- 可以使用连续的多个中间件进行处理请求，不要忘记调用 next()
- 最好不要 在next() 后 再书写代码 容易造成代码逻辑混乱
- 连续调用多个中间件的时候，中间件可以共享 req,res 对象
###### 中间件的分类
- 1.应用级别的中间件 通过app.use/get/post  绑定在app实例上的中间件
- 2.路由级别的中间 绑定到 express.Router()上的中间件
- 3.错误级别的中间件 专门捕获异常错误，从而防止程序因异常崩溃的问题
  -  方法： 必须 四个参数  （err,req,res,next）
  -  重点：必须注册在 所有路由之后 再去调用
  -  demo
    ```js
      const express = require('express');
      const app = express();
      const port = 3000;
      app.get('/', (req, res, next) => {
          throw new Error('一个错误信息')
          res.send('首页');
      })
      app.use((err, req, res, next) => {
          console.log(err.message);
          res.send(err.message)
      })
      app.listen(port, (err) => {
          if (!err) console.log("服务启动成功")
          else {
              console.log(`Example app listening on port ${port}!`);
          }
      })
    ```
- 4.内置中间件
  - express.static()   托管静态资源的中间件
  - express.json()     解析json格式的请求数据   兼容性问题4.16+    语法：app.use(express.json())
  - express.urlencoded()   解析url-urlencoded格式的请求体数据 兼容性问题4.16+  语法：app.use(express.urlencoded({extended:false})) 
- 5.第三方中间件  非express内置
  - 下载第三方中间件 npm i body-parser   
  - 通过require() 导入中间件 用use方法进行注册
  - demo
    ```js
    const express = require('express');
    const app = express();
    const port = 3000;
    //导入中间件
    const bodyParser = require('body-parser');
    //用use方法进行注册
    app.use(bodyParser.urlencoded({
        express: false
    }))
    app.post('/name', (req, res) => {
        console.log(req.body);
        res.send(req.body);
    })
    app.listen(port, (err) => {
        if (!err) console.log("服务启动成功")
        else {
            console.log(`Example app listening on port ${port}!`);
        }
    })
    ```
###### 自定义中间件
- demo
  ```js
  // 自定义中间件
    <!-- express.js -->
    const express = require('express');
    const app = express()
    const port = 3000;
    const parse = require('./parse')
    app.use(parse);
    app.post('/user', (req, res) => {
        res.send(req.body)
    })
    app.listen(port, (err) => {
        if (!err) console.log('服务启动成功');
    })


    <!-- parse.js -->
    // 使用 querystring模块解析请求体数据
    const qs = require('querystring'); //解析字符串
    const Parse = (req, res, next) => {
        let str = ''
        // req.data 获取客户端发送给服务器的数据
        // 监听req.data 事件
        req.on('data', (sj) => {
            str += sj
        })
        req.on('end', () => {
            // 将字符串转换成 对象格式
            const body = qs.parse(str);

            req.body = body;
            console.log(body);
            next()
        })
    }
    module.exports = Parse;
  ```
- 自定义中间件 封装
  - demo
    ```js
    // 1.挂载到服务器上
    <!-- 文件1 -->
    const express = require("express");
    const app = express()
    const port = 3000
    app.use(express.urlencoded({
        extended: false
    }))

    const router = require('./jiekou2')
    app.use('/api', router)

    app.listen(port, () => console.log('启动成功'))


    <!-- 文件2 -->
    const express = require("express");
    const router = express.Router()
    // 2. 创建路由模块 保证对应的数据在对应的路由上

    // 通过路由暴露数据
    router.get('/get', (req, res) => {
        const query = req.query; //浏览器的参数
        res.send({
            status: 0, //0 表示成功 1表示失败
            msg: 'success', //状态的描述信息
            data: query // 相应给客户端的数据
        })
    })
    router.post('/post', (req, res) => {
        const body = req.body;
        res.send({
            status: 0,
            msg: 'success',
            data: body
        })
    })
    module.exports = router;
     ```



## express关联 mysql
- demo
  ```js
      //引用内置模块
    const express = require('express');
    //引用mysql   安装 npm i mysql -s
    const mysql = require('mysql');
    //创建连接
    let datas = mysql.createConnection({
        host: "127.0.0.1",      //地址
        user: 'root',           //用户名
        password: '',           //密码
        database: 'lc_study2',  //数据库名
    })

    //查询是否拿到数据判断是否连接成功
    datas.query('select *from  mytable', (err, res) => {
        if (err) return console.log(err.message);
        console.log(res);
    })
  ```

## 其他
- nodejs常用api： 内置api模块有（fs、path、http等）， 第三方api （express、mysql等）

### windows 终端命令
- 上键 快速定位到上一次执行的命令
- 文件或文件夹 首字+Tab键 快速补全路径
- esc键 快速清空当前已输入的命令
- cls 清空终端

- 待处理
  - cd xxx   进入xxx文件或文件夹
  - cd.. 返回上一级目录
  - mkdir xxx 创建一个空文件夹
  - cat xxx 查看文件内容
  - vi 文件名.后缀     创建一个文件
    - 自动进入了文件 输入i 进行编辑模式
    -  esc+ : + wq +enter 保存并退出文本编辑
    -  esc+ : + q! +enter 不保存并退出文本编辑
### git 终端命令
- ls 列出当前文件夹中所有文件
- clear 清屏
- cls 命令清空 控制台
- pwd 显示当前目录的路径

### 你真的会使用终端吗?
- shift+鼠标右键 在当前目录打开 windows PowerShell

### 待处理
- 同步异步写入
  - fs.openSync(path,flags,[mode]) 打开
    - path 需要打开文件的路径
    - flags 打开文件要做的操作类型  r- 只读的    w-可写的
    - [mde]可选 设置文件的操作权限 一般省略
  - fs.writeSync(fd, string, [position, [encoding]])  写入
  - ff 文件的描述符 需要传递要写入的文件的描述符
    - string 写入的内容
    - position 写入的起始位置
    - 写入的编码格式
  - fs.closeSync(ff) 关闭文件
  - demo
    ```js
    let fs = require('fs')
    let ff = fs.openSync('hello.txt', 'w')
    console.log(ff); //3
    fs.writeSync(ff, '今天是糟糕的一天')
    fs.closeSync(ff)

    ```
  - fs.open(path,flags,[mode],callback)
    - path 需要打开文件的路径
    - flags 打开文件要做的操作类型  r- 只读的    w-可写的
    - [mde]可选 设置文件的操作权限 一般省略
    - callback
      - 异步调用的方法 结果都是通过回调函数参数返回的 回调函数的两个参数
      - err错误对象 如果没有错误为null
      - fd文件的描述符
  - demo
    ```js
    let fs = require('fs')
    fs.open('hello2.txt', 'w', function (err, fd) {
    // console.log(123);
    // console.log(arguments); //[Arguments] { '0': null, '1': 3 }
    // 判断是否出错
      if (!err) {
        // 没有出错对文本进行操作
        fs.write(fd, '异步写入的糟糕', function (err) {
            if (!err) {
                console.log('写入成功');
            }

            // 关闭文件
            fs.close(fd, function (err) {
                if (!err) {
                    console.log('文件已关闭');
                }
            })
              })
              console.log(fd); //3
          } else {
              // 如果报错 输出
              console.log(err);
          }
      })  

    ```
- 简单文件写入
  - fs.writeFile(file,data,[options],callback) 异步
  - fs.writeFileSync(file,data,[options])   同步
    - file 操作的文件路劲
    - fata 要吸入的数据
    - options 选项 可以对写入进行一些设置
    - callback 当写入完成以后执行的函数
  - demo
    ```js
    // 异步写入
    let fs = require('fs');
    fs.writeFile('hello3.txt', '这是通过writeFile写入的糟糕', {
        flag: 'a'
    }, function (err) {
        if (!err) {
            console.log('写入成功');
        }
    })


    // 同步简单写入
    // 当写路径使用的是反斜杠 表示为转义 所以需要写两个 或者使用正斜杠
    // C:\\Users\\Administrator\\Desktop\\hello4.txt
    // C:/Users/Administrator/Desktop/hello4.txt

    let fs = require('fs');
    fs.writeFileSync('C:/Users/Administrator/Desktop/hello4.txt', '这   是通过writeFile写入的糟糕', {
        flag: "w"
    })
    ```
- 流式文件写入 同步异步 简单文件写入 都不适合大文件的写入 性能较差 容易导致内存溢出
- fs.createWriteStream(path, [option]) //可写 创建读写流
  - path 文件路劲
  - option 配置参数
  - fs.write 写入
  - demo
    ```js
    let fs = require('fs')
    // 创建一个可写流
    // fs.createWriteStream(path, [option]) //可写
    // path 文件路劲
    // option 配置参数

    let ws = fs.createWriteStream('hello4.txt')
    // 通过监听的流的open和close事件监听流的打开和关闭
    // open是一次性事件 on绑定的长期有的事件 once绑定一次性的事件
    ws.once("open", function () {
        console.log('流打开了');
    })
    ws.once("close", function () {
        console.log('流关闭了');
    })

    // 写入 可以一直写入
    ws.write('这是通过流式文件写入的糟糕1');
    ws.write('这是通过流式文件写入的糟糕2');
    ws.write('这是通过流式文件写入的糟糕3');

    // ws.close();
    ws.end()
    ```

- 其他一些操作
  - fs.existsSync() 检查一个文件是否存在
  - fs.statSync() 获取文件信息
    - demo
      ```js
      fs.stat('one.jpg', function (err, stat) {
      console.log(arguments);
      stat.size 文件大小
      stat.isFile() 是否是个文件
      stat.isDirectory() 是否是一个文件夹
      console.log(stat);
      }) 
      ```
  - fs.unlink(path,callback)  删除文件
    - /fs.unlinkSync(path)
  - fs.readdir(path,[options],callback) 列出文件
    - / fs.readdirSync(path,[options])
  - fs.mkdir(path, [mode], callback) 建立目录
    - /fs.mkdirSync(path, [mode]) 
  - fs.rmdir(path, callback) 删除目录
    - /fs.rmdirSync(path) 
  - fs.rename(oldPath, newPath,callback) 重命名文件夹 和文件
    - /fs.renameSync(oldPath, newPath)
    - oldPath -旧的  newPath -新的
  - fs.watchFile(filename[Option],listener) 监视文件的修改
    - demo
      ```js

      // filename要监视的文件名
      // Option配置{interval: 1000}响应速度
      // listener 回调函数 当文件发生变化时 回调函数会执行
      // curr当前文件的状态
      // prev修改前的文件状态
      // 这两个对象都是stats的对象


      fs.watchFile('hello4.txt', {
          interval: 1000
      }, function (curr, prev) {
          console.log('文件发生变化了');
          console.log('修改前文件大小' + prev.size);
          console.log('修改后文件大小' + curr.size);
      })
      ```
  - 配置
    - w+  --- 读写      创建（不存在） 覆写（存在）
    - r   --- 读取      不存在报错
    - r+  --- 读写      不存在报错
    - a   --- 追加      创建（不存在）
    - a+  --- 读取追加  创建（不存在）
