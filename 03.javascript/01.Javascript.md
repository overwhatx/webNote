# Javascript 

## JS 简介
- javascript 是什么？
    - js 是一门动态的、弱类型的、解释型的脚本语言
      - 动态：只有在执行的时候才能确定数据类型
      - 弱类型：变量数据的类型不是确定的，可以随意的进行改变
      - 解释型：不需要编译，执行的时候，一行一行去解释执行
        - 相对于编译型来说，编译型计算机在执行之前需要把程序进行编译，完事后才能执行
      - 脚本：一般只要是脚本语言，都代表可以在其他的语言中进行执行

## JS 组成
- ECMAscript 负责js的语法
- DOM   文档对象模型（document object model）-操作元素
- BOM   浏览器对象模型（browser object model）-操作浏览器

- 前端mvc
  - html    view       视图层
  - css     view       视图层
  -  js     controller 业务逻辑层
  -  db      model      数据访问层  （数据库）
- MVC    
  - Model 模型
  - View 视图
  - Controller 控制
  
## JS 的使用

- 行内
  - 局限性比较大，只能对事件进行书写js，同时也做不到结构和行为分离
- 内联
  - 用于项目初期
  - js代码写于script标签内
  - script 标签可以 存放于body内或外 以及html标签外
- 外联
  - 使用 script:src 标签引入
  - 标签中不能写其他代码 否则引入无效

## 输出方式 三种输出语句

- console.log()     输出到控制台
- alter()           弹出框输出
  - **alter()会导致页面假死状态 会造成代码的阻塞**
- document.write    输出到页面
- ```js
        var a = 10;
        var b = "2";
        console.log(a);
        alert("hello world");
        document.write("<h1>hetui</h1>");
        console.log(12333);
    ```


## 变量
### 变量的声明
- 定义变量使用 var关键字   先定义后使用，定义好之后，可以给变量赋值（存值）
- 如果定义变量不使用var，那么变量必须要赋值，不赋值报错未定义
- 通过var声明的变量 会将变量添加到 window 对象中
- **没使用var声明的变量 是全局变量的一个属性 （window对象的属性）**
- demo
  ```js
  var a = 2;    //单个声明
  var a =1,b = 2;   //多个声明
  ```
- 什么是变量
  - 变量：可以变化的量
  - 常量：不可以改变的量

### 变量的命名规范
- 可以使用：数字、字母、下划线
- 不可以使用：数字开头、不能是关键字名、不能是保留字名
- 规范
  - 大驼峰  变量名中所有单词首字母都大写
  - 小驼峰  变量名中首单词首字母小写其余单词首字母都大写
  - 下划线  单词和单词之间用下划线连接

### 程序与进程

- 什么是程序？什么是进程？
  - 程序：代码的集合，一般指的是文件，程序是静态的
  - 进程：运行的程序，就被称作进程，进程是动态的
  
- 程序其实就是一个输入  运算   输出的过程那么我们要对一个数据进行运算，然后进行输出，这个数据就需要有一个东西去保存,这个东西，就是我们所说的变量，本质上是一个容器（内存空间）；





## 数据类型 共9种

- **基本数据类型 6种**
  - number 数字类型
  - string 字符串类型
  - boolean 布尔类型 只有 true和false
  - undefined   未定义类型 （定义变量没有赋值）
  - null    空类型 (一般是对对象进行初始化使用或者是删除一个对象的时候用到)
  - Symbol  唯一标识  
- **对象（引用）数据类型 3种**
  - Array   数组
  - Object  对象
  - Function 函数

## 数据类型的判断方法
### typeof()  
- 可以正确的判断所有基础类型 
- 判断引用类型时 会将 array类型判断为object （可以判断函数类型 function）
- 数据类型的判断
  - demo
    ```js
        var f = " test";
    console.log(typeof f);
    console.log(typeof (f));
        var a = null; //空
        console.log(typeof null); //object

        var c = [1, 2] //数组
        console.log(typeof c); //object   数组无法判断但返回为 object

        var d = { x: 1 }//对象
        console.log(typeof d); //object

        function e() { }//函数
        console.log(typeof e); //function
    ```

  - 语法：console.log(typeof 变量) | console.log(typeof (num));
- **注意** 
  ```js
        var num = 8;
        // console.log(typeof num);  //number
        console.log(typeof typeof typeof num);  //string

  ```
  - 原因： 首先执行 (typeof num )得到 number
  -  但这个返回的（number）是字符串， 在次经过typeof 类型的判断 就成了string
  -  **注意只要经过多层次（两个两个以上）的typeof判断最后得到的都为 string （包括其他基本数据类型）**
### Object.prototype.toString.call(数据)  具体数据类型判断
- Object.prototype.toString.call(数据);    **具体数据类型判断** 

## 运算符与表达式

- 什么是运算符？
  - 运算符：参与运算的符号
- 什么是表达式？
  - 表达式：由变量或常量和运算符组成的式子   **表达式是有值的**
- 重点: **当出现运算符进行运算的时候，会默认将数据类型转换为 数字 进行运算**
- 非数组的值 跟 数字 进行运算 得到的是 NaN
- **当字符串 碰到 + 不是运算作用 是拼接 其他时候 都是 运算作用**
### 数据类型的转换 强制转换（显示转换） 隐式转换

#### 强制类型转换

- Number(data)  强制将一个数据转换为数字类型 无法转换就为 NaN
  - 三种情况
    - 1.**字符串整体来看是一个数字，那么就转换为这个数字**
    - 2.**字符串整体来看不是一个数字，那么就转化为NaN**  无法转换为数字
    - 3.**字符串是一个空字符串 或者 空白字符串 ，那么就会转换为 0**
  - 布尔值正常转换  true=1; false=0;
  - **undefined 转换为 NaN**
  - **null 转换为 0**
  - demo
    ```js
        var a = '1';            console.log(Number(a));   //1
        var b = '123abc'        console.log(Number(b));   //NaN
        var c = '1.2.3';        console.log(Number(c));   //NaN
        var d = '';             console.log(Number(d));   //0
        var e = '      ';       console.log(Number(e));   //0
        var f = true;           console.log(Number(f));   //1
        var g = false;          console.log(Number(g));   //0
        var h = undefined;      console.log(Number(h));   //NaN
        var i = null;           console.log(Number(i));   //0
    ```

- String(data) 强制将一个数据转换为字符串
  - 无特殊情况 将原有数据正常原封不动输出 只是类型变为 String类型
  - demo
    ```js
    //以下输出全为字符串类型
    var a = 1;                      console.log(String(a));  //1
    var b = '123abc'                console.log(String(b)); //123abc
    var c = '1.2.3';                console.log(String(c)); //1.2.3
    var f = true;                   console.log(String(f)); //true
    var g = false;                  console.log(String(g)); //false
    var h = undefined;              console.log(String(h)); //undefined
    var i = null;                   console.log(String(i)); //null

    var d = '';
    console.log(typeof d);  //string
    console.log(String(d)); // 空字符串
    var e = '        ';
    console.log(typeof e);  //string
    console.log(typeof String(e), String(e)); //string  空字符串
    ```

- Boolean(data) 强制将一个数据转换为Boolean
  - **数字中除了0为false 其余所有数字都为 true**
  - **字符串中 除了 空字符串为 false  其余皆为 true  即使是字符串数字（'0'）**
  - **空白字符串为 true   空白字符串也是字符串**
  - unll undefined  数字 0  空字符串  皆为false
  - demo
    ```js
    var a = 1;            console.log(Boolean(a));  //true
    var b = 0;            console.log(Boolean(b));  //false
    var c = '0';          console.log(Boolean(c));  //true
    var d = null;         console.log(Boolean(d));  //false
    var e = undefined;    console.log(Boolean(e));  //false
    var f = '';           console.log(Boolean(f));  //false
    var f = '   ';        console.log(Boolean(f));  //true
    ```

#### 隐式转换
- 特殊情况 
  - 1. 空字符串、空白字符串和 null 不相等
  - 2. false和null不相等
  - 3. undefined 和null相等
  - 4. 0和null 不相等
- 除以上特殊情况外 只要是不同的基本数据类型进行运算和比较 步骤如下
  - 第一步 先看运算符是不是  +
    - 如果是 +  看是否有字符串  ，如果有 就是字符串拼接
  - 第二步 看运算符是不是 比较
    - 如果是 比较运算符 看两边是不是都是字符串 如果是 比较的是字符串的unicode
  - 最后 全部转为数字 进行运算
- demo
  ```js
    // 特殊情况 当遇到 null 时候 产生特殊情况
    // 1. 空字符串、空白字符串和 null 不相等
    var a = '';
    var a = '   ';
    var b = null;
    console.log(a == b); // false  0 == 0

    // 2.    false和null不相等
    var a = false;
    var b = null;
    console.log(a == b); // false  0 == 0

    // 3. undefined 和null相等
    var a = undefined;
    var b = null;
    console.log(a == b); // true  NaN == 0

    //4.   0和null 不相等
    console.log(0 == null); //false
  ```

#### 其他需要注意的
- NaN 不等于 NaN
  - 理解 ：NaN表示非数字 a为非数字 b也是非数字 a和b虽然都不是数字 但一定就是一个东西吗？
- 除了0 任何数字除与0 都得 Infinity   负值则 为 -Infinity
- demo
  ```js
     var a = undefined;
     var b = undefined;
     console.log(a == b); //true
     var a = null;
     var b = null;
     console.log(a == b); //true
     var a = NaN;
     var b = NaN;
     console.log(a == b); //false

    console.log(0 / 1);   //0
    console.log(-10 / 0); // Infinity   除了0 任何数字除与0 都得 Infinity   负值 为 -Infinity
    console.log(0 / 0);   //NaN
  ```

### 部分操作符：
  -  ``` = ```：赋值符号，将右边的数据赋值给左边
  -  ``` . ```: 访问符号，用于访问对象的属性
  -  ``` [] ```：访问符号，用于访问对象的属性
  -  ``` () ```：函数调用
  
### 数学运算符
  - ```+ - * /``` 加减乘除
  - ```%```  取余
     1. 作用
        1. 可以拿到余数
			  2. 可以拿到一个范围
			    任何的一个数对78取余，余数永远是在0~77之间  包含0和77      （num）%78 + 1
  - ```**``` 幂
  - ```++ --```  加加 减减
    - 细则
      - 后自增（x++）: 将变量x自增1，得到的表达式的值是自增之前的值。
      - 前自增（++x）: 将变量x自增1，得到的表达式的值是自增之后的值。
      - 后自减（x--）: 将变量x自减1，得到的表达式的值是自减之前的值。
      - 前自减（--x）: 将变量x自减1，得到的表达式的值是自减之后的值。
    - 自增自减运算符，这个运算符只能和变量组成表达式
    - **有++和--时首先不能用数学计算的逻辑运算去计算**
    - **从左到右边运行依次 ++ --**
    - **会改变原数据的值**
    - demo
          ```js
          var j = 1;
          var k = j + j++ * (j = j + j++ * ++j) + j;
          //1+1*(j=2+2*4)+10     
          //有++和--时首先不能用数学计算的逻辑运算去计算
          //应先从左运算遇到小括号才算括号 小括号内为赋值表达式 所以最后一个x为10
          console.log(k);
       ```



### 比较运算符
  - 大小比较：`>   <    >=    <=`
  - 相等比较：
    - `==`   相等 （同值）
    - `!= `  不相等 （不同值）
    - `===`  严格相等   （同值 同类型）
    - `!==`  严格不相等 （不同值  不同类型）

### 逻辑运算符 通常用于多个条件判断时的链接
  - 与 &&   （并且）
    - 书写方式： 表达式1 && 表达式2
    - 将表达式1 进行 boolean 判定
    - **短路规则: 如果表达式1的判定结果为假，则直接返回表达式1，不执行表达式2；否则，返回表达式2的结果**
  - 或 ||   （或者）
    - 写法：表达式1 || 表达式2
    - 将表达式1 进行 boolean 判定
    - **短路规则:  如果表达式1为真，直接返回表达式1，不执行表达式2；否则，返回表达式2**
  - 非 !    （取反）
    - 写法: !数据
    - 将数据的boolean判定结果直接取反，非运算符一定返回boolean类型


- 以下数据均判定为false：
  - null
  - undefined
  - false
  - NaN
  - ''
  - 0
  - 其他数据全部为真

#### 与或非 短路案例 解析
- demo
  - 比较 `< >`  逻辑运算时
    ```js
    var a = 10;
    // 比较< >  逻辑运算时
    // && 与 （并且）
    console.log(a > 8 && a < 20); //true
    console.log(a > 8 && a < 10); //false
    console.log(a > 8 && a < 10 && a < 20); //false
    // 结论：&& 中 一假则假

    // || 或 （或者）
    console.log(a > 8 || a < 10); //true
    console.log(a > 20 || a < 10); //false
    console.log(a > 20 || a < 10 || a < 30); //true
    // 结论：||中 一真则真

    // 非 ！（取反）
    console.log(!(a > 5)); //false
    // 结论：非真既假 非假既真  
    ```
 
  - 等于= 逻辑运算时
    ```js
    
    // 短路 &&
    // var a = 10;
    // var b = 1 && 100;
    // console.log(b);         // 100
    // console.log(1 && 100);  //100
    // var c = 0 && 100;
    // console.log(c);         //0
    // var d = a > 8 && a < 20;
    // console.log(d);         //true
    // var b = 1 && 0 && 2;  //0
    // console.log(b);
    // 分析：  1 && 0   1为真 返回后面的值 第一节表达式得到 0
    //        0 && 2   0为假 返回前面的值 最后的值为 0       (1 && 0 && 2 整个逻辑表达式) = 0 =b
    // var b = 1 && 3 && 0;  //0
    // console.log(b);
    // 分析：  1 && 3   1为真 返回后面的值 第一节表达式得到 3
    //        3 && 0   3为真 返回后面的值 最后的值为 0       (1 && 3 && 0 整个逻辑表达式) = 0 =b

    // 结论：
    // 先判断&&中（前面）第一个表达式 是否为真,为真则取（后面）第二个表达式 的值，赋值给整个逻辑表达式
    // 如果第一个表达式为假，则取第一个表达式的值赋值给整个逻辑表达式


    // 短路 ||
    var a = 10;
    var b = 1 || 100;
    console.log(b);         // 1
    console.log(1 || 100);  //1
    var c = 0 || 100;
    console.log(c);         //100
    var d = a > 8 || a < 20;
    console.log(d);         //true
    var b = 1 || 0 || 2;  //1
    console.log(b);
    // 分析：  1 || 0   1为真 返回前面的值 第一节表达式得到 1
    //        1 || 2   1为真 返回前面的值 最后的值为 1       (1 || 0 || 2 整个逻辑表达式) = 1 =b
    var b = 1 || 3 || 0;  //1
    console.log(b);
    // 分析：  1 || 3   1为真 返回前面的值 第一节表达式得到 1
    //        1 || 0   1为真 返回前面的值 最后的值为 1      (1 || 3 || 0 整个逻辑表达式) = 1 =b

    // 结论：
    // 先判断||中（前面）第一个表达式 是否为真,为真则取（前面）第一个表达式 的值，赋值给整个逻辑表达式
    // 如果第一个表达式为假，则取第二个表达式的值赋值给整个逻辑表达式
    ```

### 复合的赋值运算符
  - +=   (a+=b)等于 a=a+b 以下同理
  - -=
  - /=
  - *=    
  - %=    取余等于
  - **    幂 **=4  （4*4）

### 三目运算符
- 书写方式： 表达式1 ? 表达式2 : 表达式3
  - 对表达式1进行boolean判定
  - 如果判定结果为真，返回表达式2；否则，返回表达式3
  - 如果判断结果为真，将表达式2赋值给整个表达式 并返回 ：否则 将表达式3赋值给整个表达式 并返回 
  - demo
    ```js
    var a = 6;
    var b = 7;
    var c = a > 0 ? ++b + a++ : --a + b;
    console.log(c,a,b);  //c=14  a=7  b=8   第二个表达式不会被执行


    var a=59;
    a>=60? console.log("及格"):console.log("不及格"); //不及格
    ```


### 优先级

- 从高到底依次是：
  1. ```++ --```
  2. ```* / %```
  3. ```+ -```




## Number
- 任何大于0的数除以0 都是无穷大 Infinity  
- 0除0结果为NaN
  - demo
    ```js
        var a = 0;
        var b = 0;
        console.log(a / b); //NaN
    ```
- NaN 表示 非数字的值   **但是 是数字类型**
- NaN 不能进行比较   任何数和 NaN比较 都为NaN
- **关于js中 0.1+0.2不等于0.5**
  - 原因：  二进制计算发生了精度丢失，导致再转换成十进制后和预计的结果不符
  - JS采数字采用IEEE 754 双精度 64 位浮点数来存储，只能保存小数点52位，53位为0省略，53位为1进1，所以0.1+0.2   
    二进制理论相加结果第53位为1所以进1得到实际二进制计算结果
  - 0.0100110011001100110011001100110011001100110011001101  // 换算为十进制为0.30000000000000004



### Number 对象

- Number.isNaN()  判断数据类型 是否为 非数字的值 是返回true
   -  ` var a = 'test';   console.log(isNaN(a)); //true`
- Number.parseInt() **从字符串中提取整数** 将数据类型 转换为 整数
  - **去除所有小数位 保留整数 不会进行四舍五入或向下向上取整**
  - **如果首字符非数字 那直接得到NaN 即使字符后面全是数字**

- Number.parseFloat() 将数据类型 转换为 浮点数
   - **非纯数字的数字类型 通过 number 方法 进行转换 得到 NaN**
   - **如果首字符是数字的字符串类型，则可以解析成数字,直到非数字部分 停止解析**
   - 如果首字符非数字 那直接得到NaN 即使字符后面全是数字
   - demo
      ```js
        var a = "p33p";
        console.log(parseInt(a));// NaN

        var a = "33p";
        console.log(parseInt(a));// 33

      ```
  
- toFixed(n) 将数字保留小数点后n位
  - **转换过后 得到的值为 string类型**


## String 

### String 对象方法 （常用）
- toString()  返回一个 String 对象的值
   - demo
      ```js
      var a = 123; 
      console.log(typeof a.toString(),a.toString());  //string 123
    ```

- concat() 连接两个或多个字符串，**并返回新的字符串**
   -  语法：string.concat(string1, string2, ..., stringN)
   - demo
    ```js
        var a = "Javascript百炼成仙"
        var b = '吊打众神';
        console.log(a.concat(b)); //Javascript百炼成仙吊打众神
    ```

      
- charAt(n) 返回指定下标的字符串
  - 语法：string.charAt(index)
  - 下标从0 开始 
   - **空格 换行 都算字符串**
   - demo 
    ```js 
    var a = "Javascript百炼成仙";
    console.log(a.charAt(2));  //v
    ```

- indexOf(data,[star~) 返回指定的字符串值 在字符串中**首次匹配的下标** **默认从0开始找 未找到返回 -1** 起始位置**不可以为负值 负值无效默认运行**
  - 语法：string.indexOf(searchvalue,[start 开始检索的位置])
  - 区间：**左闭区间[n~**
  - **如果没有找到匹配的字符串则返回 -1**
  - 下标从0开始
  - 字符串相邻
  - 设置从那个位置开始查找，(默认为 0)。 且位置写于查找字符串后 使用逗号隔开
  - demo
    ```js
        var a = "Javascript百炼成仙";
        var b = '吊打众神';
        console.log(b.indexOf("靠"));       //-1
        console.log(b.indexOf("神"));       //3
        console.log(a.indexOf("a", 1));     //1
    ```
        
- includes(data,[star~) 查找字符串中是否包含指定的子字符串 **返回Boolean值** **默认从0开始找** **可以是负数但搜索方向不改变**
  - 语法：string.includes(searchvalue, [start])
  - 区间：**左闭区间[n~**
  - 找到匹配的字符串返回true 否则返回false
  - **可以是负数 但是不改变判断搜索的方向，搜索方向还是从左到右**
  - 设置从那个位置开始查找，(默认为 0)。 且位置写于查找字符串后 使用逗号隔开
  - demo
     ```js
        var b = "Javascript";
        console.log(b.includes("f"));  //false
        console.log(b.includes("j"));  //true
        console.log(b.includes("a", 3)); //true
    ```

- repeat(n) 复制字符串n次 ，并将复制的拼接一起返回
  - 语法：string.repeat(count)
   - demo
     ```js
        var b = "Javascript";
        console.log(a.repeat(2));  //JavascriptJavascript
    ```

- replace() 在字符串中查找**首个匹配**的字符串，并替换  **未找到返回原始值**
  - 语法：string.replace(searchvalue,newvalue)
  - **未找到返回原始值**
  - **只能替换匹配到的第一个**
  - demo
  ```js
        var a = "abcdefgyq";
        console.log(a.replace("ac", "yyds")); // abcdefgyq 未找到返回原字符串
        console.log(a.replace("yq", "yyds")); // abcdefgyyds

        var c = "麻痹傻逼麻痹"
        var d = c.replace("傻逼", "***")
        console.log(d);                     //麻痹***麻痹
        console.log(c.replace("麻痹", "你真可爱")); //你真可爱傻逼你真可爱
  ```
        

- replaceAll() 在字符串中查找**所有匹配**的字符串，**并全替换** **未找到返回原始值**
  - 同replace() 只不过是全匹配 全替换
  - 将匹配到的所有字符串 全局替换  区分大小写


- slice( [start,end) ) 截取字符 并返回一个新字符串 **超出取值为空 ' '** **不会改变原数据** **两个值都可以为负值 只能从左到右**
  - 语法 string.slice(start,[end])
  - 区间：左闭右开[a,b)  （end取不到）
  - 不会改变原数据
  - 超出取值为空 ' '
  - 可以为负值 从后取 （-1 为字符串最后一个字符的位置）
  - demo
    ```js
        var a = "Javascript百炼成仙"
        console.log(a.slice(1, 3));  //av
        console.log(a.slice(-4));   //百炼成仙
         console.log(a.slice(-1, -3));  //空   超出取值为空
        console.log(a.slice(-3, -1)); //炼成   全为负数时
    ``` 
      
- split(data,length)  把一个字符串分割成**字符串数组**  **返回数组** **指定分割依据且指定分割的长度** **不指定分割依据将全变为一个数组子项**
  - 语法: string.split(separator,[limit 边界])
  - 方法不改变原始字符串
  - 分割依据可以是 空格 字符 符号
  - **不指定分割依据将全变为一个数组子项**
  - demo
    ```js
        var a = "Javascript百炼成仙"
        var c = "张三 李四 王五"
        console.log(c.split(" "));//以空格间分割字符串  //['张三', '李四', '王五']
        console.log(a.split("")); //将字符全分开       //['J', 'a', 'v', 'a', 's', 'c', 'r', 'i', 'p', 't', '百', '炼', '成', '仙']
        console.log(a.split("a"));//以指定字符分割     //['J', 'v', 'script百炼成仙']
        console.log(a.split("a", 2));//指定字符且指定分割的长度     //['J', 'v']
        console.log(a.split());//['Javascript百炼成仙']

    ```

- substr(start,length) 截取**指定数目**的字符串 **开始当前位置被计算**
  - 从起始索引号提取字符串中指定数目的字符  **指定数目**
  - 语法：string.substr(start,[length])
  - 下标为0
  - 不规定长度 自动从设置的开始位置到尾部
  - demo
    ```js
        var a = "Javascript百炼成仙"
        console.log(a.substr(2));       //vascript百炼成仙
        console.log(a.substr(0, 10));   //从0开始 选取长度10个字符   //Javascript    
        console.log(a.substr(10));      //百炼成仙
    ``` 


- substring([star,end)) 截取**指定区间**的字符串  **end结束位置取不到** **开始和结束 值 必须是非负的整数**
  - 提取字符串中两个指定的索引号之间的字符 **指定区间**
  - 语法：string.substring(from, [to])
  - 区间：左闭右开 [a,b)  （左开始闭 右结束开）
  - **开始和结束 值 必须是非负的整数**
  - demo
    ```js
    var a = "Javascript百炼成仙"
    console.log(a.substring(10)); //Javascript
    console.log(a.substring(0, 2)); //Ja
    ```

- toLowerCase() 用于把字符串转换为小写，并返回
- toUpperCase()	把字符串转换为大写，并返回
- trim()	去除字符串两边的空白
## Array 数组

### 数组的使用
- 生成新数组的3个方法
  - 方法1：var a = new Array(null, undefined, true, "string", 1234);
  - 方法2：var a = [null, undefined, true, "string", 1234];
  - 方法3：var a = []; 或 var a = new Array();    //创建空数组 使用索引进行添加
        a[0] = null;
        a[1] = undefined;
        console.log(a); // [null, undefined]

- 数组里面可以嵌套数组以及各种类型的值
- **只有空值会得到 empty[,,]  并非是null和undefined造成的**
- 数组具备下标以及长度
- 相同的两个数组一定是 不会相等的 因为他们的指向是不同的地址
  - 只要声明变量就会开辟一块新的内存空间 ,所以两个相同的数组地址不一样地址也不同最后也不会相等
- demo
  ```js
  //声明两个数组 数组值皆同一 进行相等比较
  var a = ["张三", "李四", "王五", "赵六", "田七"];
  var b = ["张三", "李四", "王五", "赵六", "田七"];
  console.log(a==b)//输出 false 

  //内存地址为同一块时 才会相等输出true
  //因为a的地址复制给了b 所以b数组的内存地址与a相等
  var a = ["张三", "李四", "王五", "赵六", "田七"];
  var b = a;   
  console.log(a == b); //输出 true
  //于此同时 如果修改了 b数组内的值 a数组也会被改变 原因还是因为 b使用的是a的内存地址
   b[0] = '靓仔';
  console.log(a);//['靓仔', '李四', '王五', '赵六', '田七']
  console.log(b);//['靓仔', '李四', '王五', '赵六', '田七']

  ```
- 遍历数组
  - demo
  ```js
  //使用for循环遍历
  var a = [null, undefined, 1, '123', true];
  for (var i = 0; i <= a.length; i++) {
            console.log(a[i]);
        }
  //使用forEach循环遍历
   var b = a.forEach(function (i, index, arr) {
            console.log(i);
        })
  ```

### Array 数组对象

#### Array 数组对象中 不会影响原数据的
- concat()              连接两个或多个数组，**并返回新的数组**
  - demo
  ```js
        var a = [1, 2, 3, 4]
        var b = ['a', 'b', 'c', 'd']
        console.log(a.concat(b)); // [1, 2, 3, 4, 'a', 'b', 'c', 'd']
         console.log(a.concat(b[0])); //[1, 2, 3, 4, 'a']
  ```


- indexOf(data,[star~)  返回指定的字符串值 在数组中**首次匹配的下标** **默认从0开始找 未找到返回 -1** 起始位置**不可以为负值**
   - 语法：string.indexOf(searchvalue,[start 开始检索的位置])
  - 区间：**左闭区间[n~**
  - **如果没有找到匹配的字符串则返回 -1**
  - 下标从0开始
  - 字符串相邻
  - 设置从那个位置开始查找，(默认为 0)。 且位置写于查找字符串后 使用逗号隔开
  - demo
    ```js
     var b = ['a', 'b', 'c', 'd', 'a', 'b']
        console.log(b.indexOf("b")); //1
    ```

- includes(data,[star~) 查找数组中是否包含指定的子数组项 **返回Boolean值** **默认从0开始找** **可以是负数但搜索方向不改变**
  - 语法：string.includes(searchvalue, [start])
  - 区间：**左闭区间[n~**
  - 找到匹配的字符串返回true 否则返回false
  - **可以是负数 但是不改变判断搜索的方向，搜索方向还是从左到右**
  - demo
    ```js
        var b = ['a', 'b', 'c', 'd']
        console.log(b.includes("b")); //true
        console.log(b.includes(1)); //false
    ```

- slice( [start,end) )  截取数组项 并返回一个新数组 **超出取值为空' '** **不会改变原数据** **两个值都可以为负值 只能从左到右**
  - 区间：左闭右开[a,b)  （end取不到）
  -  demo
    ```js
      var b = ['a', 'b', 'c', 'd']
      console.log(b.slice(1, 4));  //['b', 'c'] 
        // 左闭右开 下标1可以取到 下标3取不到所以需要 多一位
    ```

- isArray ()    判断一个对象是否为数组 是返回true 不是返回false
  - demo
    ```js
      var a = [20, 40, 80, , 60, 86, "85", 88]
        console.log(Array.isArray(a)); //true
        var b = 1;
        console.log(Array.isArray(b)); //false
    ```
  - 判断是否为数组的第二种方法 **Object.prototype.toString.call()**
    - demo
      ```js
       var a = [20, 40, 80, , 60, 86, "85", 88]
       console.log(Object.prototype.toString.call(a)); //[object Array]
        var b = 1;
        console.log(Object.prototype.toString.call(b)); //[object Number]
      ```

- filter()      数组的过滤，返回符合条件所有元素的数组
  - 满足条件的子项会组成新的项目
  - demo
    ```js
    //拿到大于70的数
         var a = [20, 40, 80, , 60, 86, "85", 88]
         var c = a.filter(function (i, index, arr) {
             return i > 70;
         })
         console.log(c); //[80, 86, '85', 88]
    ```
- 函数中的参数 
  - 函数括号里面的 可以随便命名
  - i       数组内的每一个子项
  - index   数组的每一个下标
  - arr     当前的原数组
  - return  关键字  返回值

- find(i, index, arr)  **查找第一个符合条件的子项并返回   如果没有则返回undefined**
  - demo
    ```js
         var a = [20, 40, 80, , 60,"85", 86,  88]
         var c = a.find(function (i, index, arr) {
             return i > 80;
         })
         console.log(c); //85


          let a = [1, 6, -3, -5, 2];

        let b = a.find((i, index, arr) => {
        // console.log(i);    //当前遍历到的元素
        // console.log(index);   //当前遍历到的索引
        // console.log(arr);  //数组本身。
        return i < 0;        //return 需要有值接收
        })
        console.log(b);  //-3

          let c = [1, 6, 3, 5, 2];
          let e = c.find((i) => i < 0)
          console.log(e);   //undefined
    ```

- findIndex(i, index, arr)   **查找第一个符合条件子项的并返回下标  都不符合条件，则返回-1**
  - demo
  ```js
        var a = [20, 40, 80, , 60, 86, "85", 88]
         var c = a.findIndex(function (i, index, arr) {
             return i > 80;
         })
         console.log(c); //5

    let a = [1, 6, -3, -5, 2];
    let b = a.findIndex((i, index, arr) => {
        // console.log(i);    //当前遍历到的元素
        // console.log(index);   //当前遍历到的索引
        // console.log(arr);  //数组本身。
        return i < 0;
    })
    console.log(b); //2


    // 没有匹配到符合条件返回-1
    let c = [1, 6, 3, 5, 2];
    let e = c.findIndex(i => i < 0)
    console.log(e);   //-1

  ```

- forEach()     数组的循环遍历
  - 不允许 参数的命名 跟 变量的命名 一致
  - demo
    ```js
      var a = [20, 40, 80, , 60, 86, "85", 88, null]
      var c = a.forEach(function (i, index) {
          console.log(i);//20 40 80 60 86 85 88 null
        }) 

    ```
  - forEach 参数值
  - demo
    ```js
        var a = [null, undefined, 1, '123', true];
        var b = a.forEach(function (i, index, arr) {
          console.log(i); //返回数组内的值（数组中的每一项）
          console.log(index);//返回数组的下标
          console.log(arr); //返回当前原数组
        })  
    ```
  

- join()        把数组中的所有元素转换为一个字符串
  - demo
    ```js
    var names = ["张三", "李四", "王五", "赵六", "田七"]
     console.log(names.join()); //张三,李四,王五,赵六,田七
        // 使用自定义间隔方式
     console.log(names.join('# ')); //张三# 李四# 王五# 赵六# 田七
    ```


- map()         映射  映射当前数组里的每一个子项，返回一个新的数组
  - **语法：`array.map(function(currentValue,index,arr), thisValue)`**
  - demo
    ```js
    var a = [1, 2, 3, 4]
    var c = a.map(function (i) {
            console.log(i); //1 、2、3、4
        })
        console.log(c);//[undefined, undefined, undefined, undefined] //没有return返回值 所以得到未定义的数组
        console.log(a == b); //false


        var c = a.map(function (i) {
            return i;
        })
        console.log(c);//[1, 2, 3, 4]
    ```

#### Array 数组对象中 会影响原数据的
- fill()     将指定的数组的元素全替换为一个固定值 不包括终止索引
  - 语法：array.fill(value, [start], [end])
  - 区间：左闭右开 [start,end)
  - demo
    ```js
     var names = ["张三", "李四", "王五", "赵六", "田七"]
     console.log(names.fill("name")); //['name', 'name', 'name', 'name', 'name']
    ```

- sort() 对数组的元素进行排序
  - demo
    ```js
        var a = [10, 20, 8, 4, 1, 6]
        var b = a.sort(function (a, b) {
            // return a - b;  // 升序 log// [1, 4, 6, 8, 10, 20]
            return b - a;  // 倒序 log// [20, 10, 8, 6, 4, 1]

        })
        console.log(b); 
    ```

- pop() 删除数组的最后一个元素并返回删除的元素  
  - 此方法改变数组的长度！
  - demo
    ```js
      var names = ["张三", "李四", "王五", "赵六", "田七"]
      console.log(names.pop());   //田七
      console.log(names); //['张三', '李四', '王五', '赵六']
    ```
- shift() 删除数组的第一个 并返回删除的元素 

- push() 向数组的末尾添加一个或多个元素，并返回新的长度   
  - 会改变原有长度
  - demo
  ```js
    var names = ["张三", "李四", "王五", "赵六", "田七"]
    console.log(names.push()); // 5
    console.log(names.push("吊毛", "靓仔")); // 7
    console.log(names);['张三', '李四', '王五', '赵六', '田七', '吊毛', '靓仔']
  ```
- unshift() 向数组的开始添加一个或多个元素，并返回新的长度 

- reverse() 颠倒数组中元素的顺序
  - 语法：
  - demo
    ```js
    var names = ["张三", "李四", "王五", "赵六", "田七"]
    console.log(names.reverse());  //['田七', '赵六', '王五', '李四', '张三']
    ```



- splice((star,number,items...) 添加或删除（截取）数组中的元素   **开始位置可以是负数** **会返回被删除的数组**
  - 语法：array.splice(index起始下标,[number 删除个数],[item1,.....,itemX])
  - 区间：(index  number]   左开右闭
  - 起始位置可以是负值 但是删除个数不可以是负数
  - 删除时 会返回被删除的数组
  - demo
  ```js
        var a = ["a", "b", "c", "d", "e"];
        console.log(a.splice(0, 3)); //['a', 'b', 'c'] //删除返回的数组
        console.log(a);//['d', 'e'] //删除过后的a数组
  ```
### Array 数组对象中 会影响原数据的
- fill()
- reverse()
- sort()
- push()
- unshift()
- pop()
- shift()
- splice()
## function 函数

### Function 函数 Function 函数名(形参1,...形参n){执行代码}
- 语法：Function 函数名(形参1,...形参n){执行代码}
- 函数的作用：重复代码让程序难以维护 ,函数主要用于减少重复代码
  - 高内聚低耦合： 
    - 高内聚:复用性
    - 低耦合:代码的关联性  
  - 代码冗余：重复代码过多
- 函数体的代码不会直接运行，必须要手动调用函数，才能运行其中的代码
- 函数名称: 不允许和变量名称一致  否则调用的是变量名称而不是函数
- 函数名称: **优先解析变量 后解析函数本身**

### Function函数的使用

#### 函数的调用
- 命名函数 
  - 方式1. `var a = function(){}; `          
  - 方式2. `function name(){};`  
    - demo
        ```js
        var a = function () {
          console.log(2);
        }
        function a() {
          console.log(1);
        }

        a(); //2   优先解析变量 后解析函数本身
        ```     
  - 调用:函数名+()

- 匿名函数
  - 触发匿名函数
    - 调用:需要特定的方法触发
    - 语法：运算符function(){}
      - 匿名函数  去除函数名后 使用括号()将其全部包裹
      - 或者在 function 前添加运算符号 + - ~ !  ++ -- **但不是所有的运算符都有用 有的会报错**
      - 并且 有些符号会将值改变如下
      - demo
        ```js
          console.log(function () { return 1 }()); //1 正常输出
          console.log(-function () { return 1 }()); //-1
          console.log(!function () { return 1 }()); //false
        ```
      - demo
        ```js
         //文档加载完 触发的事件
        //触发事件才执行
        window.onload = function () {
            console.log(321);
        }

        // 使用运算符
          ++ function () { console.log(1); }
        // * 、/+= function () { console.log(1); }都会报错
      ```

  -  自调用匿名函数 立即执行函数
     - 匿名函数中的立即执行函数（自调用函数）
     - 在函数末尾添加()括号
     - **立即执行函数不需要任何方式调用，只要代码读取，就立即调用**
     - **立即执行函数只会执行一次**
     - demo
      ```js
        (function () { console.log(1); })();    //1
        (function () { console.log(2); }());    //2
        ++ function () { console.log(3); ()};   //3

      // 当前为触发事件 但是不触发也会运行了 并且再次点击去触发也不会执行 
      lists.onclick = (function () { console.log(1); }())

      ```
     - 函数体的代码不会直接运行，必须要手动调用函数，才能运行其中的代码
  
     - demo  ```函数名(); ```

 

#### 函数中的参数
- 形参 实参 一一对应的原则  
  - 形参  接收实参
  - 实参  传值给形参
- 在调用函数时，可以向其传递值，这些值被称为参数  参数可以在函数中使用 多个参数间用逗号分隔
- 变量和参数必须以一致的顺序出现，第一个变量就是第一个被传递的参数的给定的值，以此类推
- **函数内部 变量名称不能与形参一致 如果一致优先解析 形参**
- demo
    ```js
    function 函数名(形参1, 形参2, ...){
        };

        函数名(实参);
    ```
- 如果实参没有传递，则对应的形参为undefined
- demo
  ```js
   function myfun(a, b) {
           
            console.log(a); //undefined
            console.log(b); //undefined
        }
        myfun(); //调用函数 但不传入实参
  ```
- arguments 
  - 如果不写形参，数据也能够传进来，都存在arguments中
    - demo
      ```js
      function a() {
        console.log(typeof arguments, arguments); // 返回存储实参的对象
        }
        a(1, 2, 3)
      ```

#### 函数的返回值
- **所有函数执行 一定有返回值** 不是 undefined 就是 return的值
- 函数的执行 没有 return 关键字的时候，默认返回 undefined
- **接收返回值  需要使用变量接收**
- 函数的四个值：
  - 有实参的才叫有参数
  - demo
    ```js
        // 有参有返回值
        function demo(a, b) {
            return a + b;
        }
        demo(1, 2);
    ```


        // 有参无返回值
        function demo(a, b) {
        }
        demo(1, 2);


        // 无参无返回值
        // function demo() {
        // }
        // demo();


        // 无参有返回值
        function demo(a, b) {
            return a + b;
        }
        demo();
    ```

## 对象 new Object()
#### 什么是对象？
- 但凡 通过new 关键字 去实例化的 函数  都会形成一个对象
#### 对象的创建方法 以及使用方式
- 1.字面量方式
  - demo
    ```js
      var obj2 = {
        // 键名：键值
        name: '李四',
        321: 'abc'
    }
    console.log(obj2.name);   //获取键值   李四
    console.log(obj2['name']);//获取键值   李四
    console.log(obj2[321]);   //获取键值    abc
    
    ```
- 2.new Object() 方法  
  - demo
    ```js
      // var obj1 = new Object({ name: '张三', age: 18 });  //创建一个写入键名键值的对象
    var obj1 = new Object(); //创建一个不写入键名键值的对象 后面进行添加
    obj1.name = '张三';
    console.log(obj1.name); //获取键值  张三
    ```
- 3.构造函数方法  
  - demo
    ```js
      var c = function (x, y) {
        this.name = x;  //name 为键名   x y 为形参
        this.age = y;   //age 为键名  
    }
    var d = new c('张三', 18)
    var e = new c('李四', 19)
    console.log(c);    //返回c整个函数
    console.log(c());  //调用c()函数 为返回值  undefined
    console.log(d);    //d的数据为对象{name: '张三', age: 18}
    console.log(e);   //{name: '李四', age: 19}
    ```
- 4.工厂函数方法
  - demo
    ```js
    function createPerson(x, y) {
        // 创建一个空对象
        var person = new Object();
        // 添加属性和方法 属性为形参值
        person.name = x;
        person.age = y;
        // 将对象作为函数的返回追
        return person
    }
    // 调用工厂函数进行创建对象
    var person1 = createPerson('张三', '18')
    console.log(person1);  //{name: '张三', age: '18'}
    ```
- 对象引用对象的属性的（键值）
  - `[被引用对象的属性名['引用的属性值']] `
  - demo
    ```js
       var a = {
        b: 'abc',
        c: 12
    }
    var d = {
        [a['b']]: 456,
        c: this.c
    }
    console.log(a);         //{b: 'abc', c: 12}
    console.log(d);         //{abc: 456, c: undefined}
    console.log(d.abc);     //456  d可以使用 d.abc 进行取值
    ```
   
##### 关于键
- 1.对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以
  -  var obj2 = {name: '李四',cba: 321};=== var obj2 = {'name': '李四','cba': 321};
- 2.如果键名是数值，会被自动转为字符串。
  - 如果键名是纯数字 那么获取的时候可以写引号也可以不写引号 
  - 但是 非纯数字的键名使用 []中括号获取 键值 一定要使用 引号
  - 键名可以是纯数字 但不能与其它字符串结合时数字在首位
  - demo
    ```js
        var objtest = {
        // 键名：键值
        123: '李四',
        cba: 321,
        '456': 654,
    }
    // console.log(objtest['123']);== console.log(objtest[123]); //李四
    console.log(objtest[456]); //654
    console.log(objtest[123]); //李四
    // console.log(objtest[cba]); // 报错 ['cba'] 非数字要写引号
    ```
- 3.键值可以是任何数据 如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。
  - demo
    ```js
    var objtest2 = {
        p1: function () {
            console.log('test');
        }
    }

    objtest2.p1();
    ```
#### 对象的增删改查
- demo
  ```js
    var obj = new Object()

    // 增
    obj.name = '张三';
    obj.city = '南昌';
    obj.age = 18;
    // console.log(obj.city);  //南昌

    // 删
    console.log(obj);   //{name: '张三', city: '南昌', age: 18}
    delete obj['name'];
    console.log(obj);   //{city: '南昌', age: 18}
    //方式二
    let user = {
    names: '张三',
    money: 10000
    }
    console.log(user);//{names: 'tom', money: 10000}
    Reflect.deleteProperty(user, 'money')
    console.log(user);//{names: 'tom'}

    // 改
    obj.age = 20;
    console.log(obj);  //{city: '南昌', age: 18}

    // 查
    console.log(obj.city);     // 南昌
    console.log(obj['city']);  // 南昌
  ```
#### 对象中 this 指向问题
- **对象属性值的this 谁调用指向谁**
- **构造函数里面的this 指向 对象本身**
  - demo
    ```js
    
    ```
#### 对象的遍历 for（var i in obj）{} 的使用
- demo
  ```js
    var obj = { name: '张三', age: '18', sex: '男' };

    for (var i in obj) {

        console.log(i);         //name age sex   i=属性值 
        console.log(obj[i]);    //张三  18  男    obj[i]=属性值
    }
  ```
#### demo
- 为什么不调用的时候就会输出？
- ` console.log(console.log(1));`  输出 1 和 undefined
  ```js

   var num2 = {
        a: console.log(this),  //当前this 指向为window  
        b: function () {
            console.log(this);
        },
        c: console.log(this.p) //没有这个 p 即使不调用 依然会自动输出 
    }
    console.log(num2.a);        //window是this输出的  + undefined  num2.a的
    // console.log(num2.b());  //输出 function 函数b   因为是调用b()函数 所以一定有返回值 没有返回值所以是undefined
    // console.log(num2.c);   //undefined + undefined
    // 首先 console.log(this.p) 拿到 undefined  console.log(num2.c); 也拿到undefined  这个undefined 是console.log自身的返回值
    // num2.c 因为 c不是函数 对象解析的时候就会自动执行  console.log是函数 没有返回值所以返回undefined
   ```

## 条件语句

### if else 语句
- 语句在指定的条件为 true 时，执行if代码块,如果条件为 false，会执行另外一个代码块
- demo
  ```js
  <!-- 
        85~100 优秀   100 满分
        70~85  良     
        60~69  中     60及格
        ~60    不及格
        0     零分
   -->
    var a = 10;
        if (a >= 85) {

            if (a == 100) {
                console.log("满分");

            } else {
                console.log("优秀");
            }
        } else if (a >= 70) {

            console.log("良");

        } else if (a >= 60) {
            if (a == 60) {
                console.log("及格");
            } else {

                console.log("中");
            }
        } else if (a >= 0) {
           
            if (a==0) {
            console.log("零分");
                
            } else {
                console.log("不及格");
            }
        } else {
            console.log("请输入100以内的数");
        }
  ```
- if判断语法糖
  - demo
    ```js
    // 当只有一个判断的时候可以使用如下语法糖
    // 使用条件 只能执行一条语句
      if(a>b) return '大于';
    ```

### switch 语句
- break 关键字用于跳出switch代码块。会终止switch代码块的执行。 **如果忽略break该关键字，swith 语句的下一个代码块会被执行**
- **default 关键字 来规定匹配不存在时做的事情**, **default 关键字在 switch 语句中只能出现一次**
- demo
  ```js
    switch
         var a = '星期天'
         switch (a) {
             case "星期1": console.log("星期1"); break;
             case "星期2": console.log("星期2"); break;
             case "星期3": console.log("星期3"); break;
             case "星期4": console.log("星期4"); break;
             case "星期5": console.log("星期5"); break;
             case "星期6": console.log("星期6"); break;
             case "星期天": console.log("星期天"); break;
             default: console.log("请输入正确的星期");
         }
  ```









## 循环

### for 循环 for(声明变量初始化; 循环条件; 变量运算符;){循环体}
- demo
  ```js
    // 得到sum的值
        var a = 10
        var b = 5;
        var sum = 0;
        for (var i = 0; i  <  a; i++) {
            a -= 2;
            for (var j = 0; j < b; j++) {
                b--;
                console.log(j); //01200
                sum = i + j;   
            }
        }
        console.log(sum); //2
  ```
- 个人解析：
  - 问题1：运算最后所得的结果为什么是 2？ 如何运算的？
    - 审题注意点：**1.内循环sum是赋值每次循环过后都会重新赋值**; **2.内循环 中(b--) 会导致 变量b值改变 并不是每次循环b值都是原始值**;
    - 外循环  外循环中 ( a -= 2;) 每次执行都会将 a值减小 间接性导致 i值递增的边界变小
    - 外循环 执行第4次时 不在满足条件 所以满足条件的**外循环执行了3次**  最后一次是跳出结束
        i<a才会执行  
        i=  0     1     2       3      此后不执行 4   **i=4 < a=2**
        a=  10    8     6       4      此后不执行 2
    - 内循环1次   j<a才会执行  内循环中 (b--;) 每次执行都会将 b值减小 间接性导致 j值递增的边界变小
      - 内循环第一次 初始值b=5 
        - j=0<b=5   j=1<b=4   j=2<b=3  
        - j=3<b=2? 不满足条件退出内循环
    - 内循环2次   
      - j=0<b=2  
      - j=1<b=1 ？ 不满足条件退出内循环
    - 内循环3次
      - j=0<b=1
      - j=0<b=0?   不满足条件退出内循环
    - 进入三次内循环说明外循环也进入过三次 所以此时 i=2 j=0
    - 所以结果为 2
            

  - 问题2：内循环内中的输出为什么依次是 0 1 2 0 0     尾部0 0如何而来？
    - 内循环1次   j<a才会执行  内循环中 (b--;) 每次执行都会将 b值减小 间接性导致 j值递增的边界变小
      - 内循环第一次 初始值b=5 
        - j=0<b=5   j=1<b=4   j=2<b=3    j值依次输出： 0、1、2
        - j=3<b=2? 不满足条件退出内循环
    - 内循环2次   
      - j=0<b=2                          j值依次输出： 0
      - j=1<b=1 ？ 不满足条件退出内循环
    - 内循环3次
      - j=0<b=1                          j值依次输出： 0
      - j=0<b=0?   不满足条件退出内循环



### while 循环 while(条件语句){循环体}
- while(){} 和do{}while() 的区别：
  -  **while先判断在执行 do while 无论是否满足条件都会执行一次**
- demo
  ```js
        //输出1~100
         var i = 0; //当前输出的次数，初始化
         var sum = 0;
         while (i <= 100) {
             sum += i;
             console.log(sum);
             i++;
         }
  ```
### do while 循环 do{循环体}while(条件语句)
- demo
  ```js
  //
   var i = 0;
        var sum = 0;
        do {
            sum += i;
            // console.log(sum);
            i++;
        } while (i <= 100);
        console.log(sum);
  ```



## Math 方法
- Math.random()   0~1 的随机数   [0,1)   无法取到1
- Math.round()    四舍五入               大于0.5向上取整 小于0.5向下取整 可以取到1
- Math.floor()    向下取整               只要是小数 0.99取值也为0   取不到1
- Math.ceil()     向上取整               只要是小数 0.01取值也为1   取不到0
- demo
  ```js
        console.log(Math.ceil(0.01));   //1   向上取整

        console.log(Math.floor(0.99));  //0   向下取整

        console.log(Math.round(0.4));   //0   四舍五入
        console.log(Math.round(0.5));   //1   四舍五入
  ```
- 得到一个 5~10间 的整数 [全闭区间 都可以选中]  （5 和10可以被选中）
  - Number.parseInt(Math.random() * max - min + 1) + min)
  - demo
    ```js
   // 
        console.log(
            Math.round(Math.random() * 5 + 5)   //round四舍五入);
  - Number.parseInt(Math.random() * max - min + 1) + min)
  - console.log(Math.round(Math.random() * 5 ) + 5);   //拿不到1 添加一位
  - console.log(Number.parseInt(Math.random() * 5) + 35);   //获取随机数在去除浮点数 最后拿到该随机数 
  - console.log(Math.random(Math.round() * 5) + 5);  //四舍五入
  - console.log(Math.random(Math.floor() * 5+1) + 5);  //向下取整 拿不到1 所以需要加一位
  - console.log(Math.random(Math.ceil() * 5-1) + 5);  //向上取整  拿不到0 所以需要减一位
  

   ```
## Date
- 使用Date  `var time = new Date();`
  - 单独获取：
    - 年   `time.getFullYear()`
    - 月   `time.getMonth()`       **月份(0 ~11)**
    - 日   `time.getDate`          **(1 ~31) 无闰平年判断**
    - 星期 `time.getDay`           **返回一周中的某天(0~6) 0为星期天**
    - 时   `time.getHours`         **(0~23)**
    - 分   `time.getMinutes`       **(0~59)**
    - 秒   `time.getSeconds`       **(0~59)**
  - 单独设置时间：
    - time。setFullYear()
## length 长度
- 所有带有长度属性的数据类型 都可以使用 for循环进行遍历
## 鼠标事件
#### 鼠标事件
- click     单击事件
- dblclick  双击事件
- mousedown 鼠标按下事件
- mouseup   鼠标抬起事件
- mousemove 鼠标移动事件  鼠标在元素上移动触发
- mouseover 鼠标移入事件  鼠标移入元素中触发  **会冒泡**
- mouseout  鼠标移出事件  鼠标移出元素中触发  **会冒泡**
- mouseevent 鼠标移入事件 **不会冒泡**
- mouseleave 鼠标移出事件 **不会冒泡**
- demo
  ```js
   var btn = document.getElementsByClassName('btn')[0];
    btn.onclick = function () {
        console.log('鼠标单击触发');
    }

    btn.ondblclick = function () {
        console.log('鼠标双击触发');
    }

    btn.onmousedown = function (event) {
        console.log('鼠标按下触发'); //鼠标上的每一个按键都会触发 具体触发使用 event.button
        console.log(e);
        // event返回MouseEvent对象  对象中的button 记录鼠标按键 左键=0 中键=1 右键=2
    }

    btn.onmouseup = function () {
        console.log('鼠标抬起');
    }

    btn.onmousemove = function () {
        console.log('鼠标在元素上移动');
    }


    // mouseover 鼠标移入元素中触发 会冒泡
    btn.onmouseover = function () {
        console.log('鼠标移入元素中触发');
    }

    // mouseover 鼠标移出元素中触发 会冒泡
    btn.onmouseout = function () {
        console.log('鼠标移出元素中触发');
    }

    btn.onmouseenter = function () {  //不会冒泡
        console.log('鼠标移入元素中触发');
    }
    btn.onmouseleave = function () { //不会冒泡
        console.log('鼠标移出元素中触发');
    }
  ```
- demo 移入移出事件的冒泡与不冒泡
  ```js
    <script>
    
    /* 
    mouseover 鼠标移入元素中触发 会冒泡
    mouseout 鼠标移出元素中触发 会冒泡
    当 鼠标 移入子元素时 首先会触发 鼠标移出mouseout 后在触发 鼠标移入mouseover子元素会向上冒泡
    */
    var box1 = document.getElementsByClassName('box1')[0];
    box1.onmouseover = function () {
      console.log("移入 over");
    }
    box1.onmouseout = function () {
      console.log("移出 out");
    }
    
    // 阻止 子元素冒泡的方法
    // 此时 最顶层的box3 不会向上进行冒泡 
    // 子元素 box2 依然存在冒泡 如果将box2阻止冒泡 那直接会阻断 box2子元素 的所有向上冒泡
    var box3 = document.getElementsByClassName('box3')[0];
    box3.onmouseover = function (e) {
      e.stopPropagation();
    }
    box3.onmouseout = function (e) {
      e.stopPropagation();
    }
    
    
        // mouseenter 鼠标移入元素中触发 不会冒泡
        // mouseleave 鼠标移出元素中触发 不会冒泡
        // 只要在父级的区域内就算移入 离开父级区域才算离开  （所以在子元素上移入移出 不会触发）
    
        // var box1 = document.getElementsByClassName('box1')[0];
        // box1.onmouseenter = function () {
        //     console.log("移入 enter");
        // }
        // box1.onmouseleave = function () {
        //     console.log("移出 leave");
        // }
    </script>
  ```
- 阻止 mouseover mouseout 冒泡
  - `even.stopPropagation();`  鼠标事件对象 案例如上 从中间隔断 那么 从自身以下的都无法冒泡到此前
#### 鼠标事件对象
- 关于鼠标坐标类的
  - offset  鼠标相对于 **带有定位的父盒子的** 事件源的内边距的 X Y坐标  **对象内**
    - event.offsetX 返回鼠标在元素中距离元素的左侧的距离    鼠标坐标到元素的左侧的距离
    - event.offsetY 返回鼠标在元素中距离元素的顶部的距离    鼠标坐标到元素的顶部的距离
  - clientX/Y  鼠标相对于 浏览器 首屏可视区 XY轴距离  **相对于浏览器首屏**
    - event.clientX 返回鼠标相对于浏览器窗口可视区的X坐标 
    - event.clientY 返回鼠标相对于浏览器窗口可视区的Y坐标
  - page  对于整个页面来说，**包括了被卷去的body部分的长度**
    - event.pageX   返回鼠标相对于文档页面的X坐标 IE9+支持  
    - event.pageY   返回鼠标相对于文档页面的Y坐标 IE9+支持
  - screen  鼠标相对于电脑显示器的XY坐标
    - event.screenX 返回鼠标相对于电脑显示器的X坐标
    - event.screenY 返回鼠标相对于电脑显示器的Y坐标
  - movement：
    - movementX、movementY，只在鼠标移动事件中有效，相对于上一次鼠标位置，偏移的距离
- 鼠标常用类型事件
  - event.bubble  检测该事件是否冒泡  返回布尔值 true冒泡 false 不冒泡
  - event.stopPropagation() 表示阻止当前事件的进一步捕获或冒泡,但是同一层的不能阻止
    - 同层的阻止可以使用e.stopImmediatePropagation()
  - event.preventDefault()  表示取消事件的默认行为
  - event.type    返回当前事件的类型
- event事件对象  兼容  var event = event||window.event
### 获取元素css的最终样式 `getComputedStyle('样式')` **只读属性**
### 获取元素方法  querySelector（）  querSelectorAll（）
- document.querySelector('css选择器')  选中的第一个匹配元素 
  - **书写css选择器的时候不要忘记 添加 # .**
- document.querySelectorAll（）; 与 document.getElementsByClassName 区别
- querySelectorAll('css选择器') 选中匹配的所有元素  节点列表 数组 可以使用数组的方法 例如遍历forEach等
- getElementsByClassName()      选中匹配的所有元素  元素集合 类数组 有数组结构  不可用数组的方法  
### 两种定时器 以及定时器的清除
- setInterval  **定时器的执行 必定带有 id标识**
  - setInterval(fn) 执行命名函数的时候 fn只需要填写函数名称 不需要+（）
- setTimeout  间隔xms**执行一次**
#### 定时器的清除 
- 每个定时器必定有id标识 而且是唯一的
- clearInterval(id);
- clearTimeout(id);
### disabled 禁用 表单元素自带的 布尔属性  默认为true即禁用 false不禁用
## DOM
#### 获取位置
- 获取当前显示器屏幕的宽高
  - window.screen.width 
  - window.screen.height
- 获取当前显示器可用性区域宽高
  - window.screen.availHeight 
  - window.screen.availWidht 
- 获取元素带边框的宽高
  - offsetWidth  当前对象的可视区域的宽度 **包含边框**
  - offsetHeight 当前对象的可视区域的高度 **包含边框**
- 获取元素不带边框的宽高
  - clientWidth  返回当前对象元素的像素宽度 **宽度包含内边距** **但不包含边框 外边距 滚动条**
  - clientHeight  返回当前对象元素的像素高度 **高度包含内边距** **但不包含边框 外边距 滚动条**
- 获取当前元素距离定位父级左侧的距离 包含边框
  - offsetLeft   当前对象距离定位父级的左侧距离 含边框
  - offsetTop    当前对象距离定位父级的顶部距离 含边框
- Element.scrollLeft 属性可以读取或设置元素滚动条到元素左边的距离 顶部的距离 **页面被卷去的宽度高度**
  - 如果元素不能滚动（比如：元素没有溢出），那么scrollLeft 的值是0。
  - console.log(document.documentElement.scrollLeft);
  - scrollTop   元素滚动条内的顶部隐藏部分的高度  被卷去的
    - `document.documentElement.scrollTop || document.body.scrollTop`
  - onscroll 滚动事件  当元素的滚动条滚动时触发的事件。
### 自定义元素属性
- setAttribute('属性名','属性值')  设置自定义元素属性
- getAttribute('属性名')           获取自定义属性的值
### 获取节点和元素
- parentNode：        获取父节点（元素、文档）
- previousSibling：   获取上一个兄弟节点   **（空格注释字符 都为节点）**
- nextSibling：       获取下一个兄弟节点
- childNodes：        获取所有的子节点
- firstChild：        获取第一个子节点
- lastChild：         获取最后一个子节点
- attributes:         获取某个元素的属性节点
#### 获取元素节点
- parentElement：             获取父元素    
- previousElementSibling：    获取上一个兄弟元素   只返回元素节点之前的兄弟元素节点（不包括文本节点、注释节点）
- nextElementSibling：        获取下一个兄弟元素
- children：                  获取元素的子元素集合
- firstElementChild：         获取第一个子元素
- lastElementChild：          获取最后一个子元素
#### 获取节点信息
- nodeName：获取节点名称
- nodeValue：获取节点的值
- nodeType：节点类型，是一个数字
### 删除元素
- remove() 删除自身
- removeChild() 删除父元素下的子元素
### 获取元素的方法
- 获取到的集合不是数组 使用 isArray() 或 forEach() 可以检测到
- 获取元素找不到对应的元素 返回 null
- 获取元素集合 找不到对于的元素 返回 空的 元素集合 []
- **元素集合是类数组:有数组的结构，没有数组的方法**
- document.getElementById('id名称')               通过id名称    获取元素  **未找到 返回undefined**
- document.getElementsByClassName()               通过class名称 获取元素集合 **不是元素 也不是数组**
- document.getElementsByTagName()                 通过标签名称  获取元素集合
- document.getElementsByName('name名称')          通过name名称  获取元素集合
  - **以上元素集合未找到 返回 空元素集合[]**
### 事件监听
- dom对象.addEventListener(event名称,执行function,冒泡/捕获) **默认冒泡**

  - 语法```js
      addEventListener("click",function(){
      console.log("1")
      },true/false);
    ```
  - 1值 事件名称（事件类型）注意不加on
  - 2值 处理函数 可以写多个处理程序
  - 3值 使用时表示是否在捕获阶段触发 默认为false 为冒泡阶段触发
 - **事件的监听 不是绑定事件 是但凡监听触发某个事件，则执行监听产生的事件**
- event.stopPropagation() 阻止事件冒泡
- event.preventDefault() 阻止默认行为  例如a元素的跳转 
- 事件的移除：dom对象.removeEventListener(事件名, 处理函数);
- 冒泡与捕获： **事件捕获 从外到内    事件冒泡 从内到外**

### 获取元素值
  - dom.innerHTML();    dom的html
  - dom.innerText();    dom的文本
  - dom.textContent();  设置或者返回指定节点的文本内容
  - dom.Value           获取或设置表单的value值

### 样式的修改
  - 设置样式        `box.style.background = 'red' `
  - 设置元素的类名   `demo.className=''`
## BOM
- BOM：Browser Object Model 是浏览器对象模型
### Bom 对象
- window    对象，是 JS 的最顶层对象，其他的 BOM 对象都是 window 对象的属性；
- document  对象，文档对象
- location  对象，浏览器当前URL信息
  - href     绝对路径的地址
  - pathname 相对路径的地址
  - origin   地址栏的前缀
- navigator 对象，浏览器本身信息
  - userAgent 获取浏览器的内核
    - demo 判断当前浏览器是不是iE浏览器
      ```js
      if (window.navigator.userAgent.indexOf('MSIE') != -1) {
        console.log('我是IE');
        } else {
        console.log('我不是IE');
        }
      ```
- screen    对象，客户端屏幕信息
  - 获取当前用户屏幕实际大小 宽高
    - width
    - height
      - demo
        ```js
        console.log(window.screen.availWidth);
        console.log(window.screen.width);
        ```
  - 获取当前用户屏幕的可用宽度  **可用宽高为除掉 半永久特性的底部任务栏**
    - availHeight
    - availWidht
- history   对象，浏览器访问历史信息
  - history.back() - 加载历史列表中的前一个 URL。返回上一页
  - history.forward() 加载历史列表中的下一个 URL。 返回下一页。 



## 原型原型链
- demo
   原型 prototype （显示原型）
        原型链 __proto__ （隐示原型）
        原型包含原型链 ，不包含原型   因为原型指向的是对象 对象里面只有原型链 所以 原型包含原型链 ，不包含原型 
        原型链中包含原型链 ，不包含原型
        function f() { };  //函数 
        var a = new f();   //实例化对象 
        假设：function Object()函数 =Obj      function Function() 函数= Fn
    1.函数的原型指向 （实例化）对象的隐式原型
    2.函数的原型 constructor 指向函数本身 同理对象的 原型链（隐式原型）的constructor指向函数本身
    3.函数的原型原型链 指向 对象的原型链的原型链
    4.函数的原型的原型链的原型链===对象的原型链的原型链的原型链 最终同指向 null
    5.万物皆对象  原因: 所有数据类型 都具备对象类型
    6.Obj 构造函数 的原型 指向  f函数的原型的原型链   对象的原型链的原型链
    7.Obj 函数 的原型链 指向 Fn 的原型链 
    8.f构造函数的原型链 指向 Fn的原型
    9.Fn的原型链 指向 Fn的原型 指向 Obj的原型链 指向 f构造函数的原型链 
    10.Fn的原型（链）的原型链 指向 Obj的原型  
    11.Obj函数的原型的原型链指向  Fn函数的原型的原型链的原型链  最终为null
## call() apply()  bind() this指向的改变
- call() 
- apply()
- bind()
  - demo
    ```js
     var name = '小王'
    var obj = {
        name: '小张',
        objAge: this.age,
        myFun: function (city, area) {
            console.log(this.name + "年龄" + this.age + city + area);
        }
    }
    var db = {
        name: '张三',
        age: 999
    }
    obj.myFun.call(db, '南昌', '青山湖');   //张三年龄999南昌青山湖
    obj.myFun.apply(db, ['湖南', '长沙']);  //张三年龄999湖南长沙
    obj.myFun.bind(db, ['湖南', '长沙'])(); //张三年龄999湖南,长沙undefined
    ```
## 同步异步
- 简述:
  - 同步:  生活中的异步 是代码中的同步 
    - 同步执行的代码 容易造成 代码的阻塞,无法继续向下执行。
  - 异步:  生活中的同步 是代码中的异步    
    - 为了规避代码阻塞问题
- js中同步异步执行方式
  - 同步任务  优先执行
  - 异步任务  等待所有同步任务执行完 之后 才会执行
  - 异步任务是为了避免代码堵塞
    - 定时器 setTimeauto setInterval   window.onload  alert 
- demo
    ```js
        console.log(2);
        // alert('我是弹窗');
        setTimeout(function () {
          console.log(abcd);
        }, 0)
        //abc()
        console.log(1);
        console.log(3);
        /* 
        alert 会阻塞 后面代码执行 造成页面假死状态  
        定时器 中调用 一个不存在的变量 让其报错    (阻塞代码执行的两个方式 代码报错和 alert的使用)
        如上代码 按照常态 1 3 不会被执行 因为在其上面有报错
         */

        //demo 1
        console.log(1);
        setTimeout(function () {
          console.log(2);
        }, 1000)
        console.log(3);
        setTimeout(function () {
          console.log(4);
        })
        /* 
        //输出结果： 1 3 4 2
        1,3 为 同步任务 先执行  2，4为异步任务  但是2 延迟执行了
         */

      //demo 2 
      console.log(1);
      setTimeout(function () {
          console.log(2);
          setTimeout(function () {
          console.log(5);
           })
      }, 1000)
      console.log(3);
      setTimeout(function () {
          console.log(4);
          setTimeout(function () {
          console.log(6);
          }, 1000)
      })
      /* 
      //1  3 4 2  6  5    有时候打开为 134256 原因 浏览器解析问题  因为时间在相同的情况下解析
      1 3 为同步任务先执行 
      第一个 异步任务带有定时所以执行第二个异步任务 输出4
      第二个异步任务中 遇到异步任务且延时  转到队伍列表中执行加载过的任务列表 第一个异步  输出 2 再次遇到异步任务 同上 先执行 6 最后执行5 
       */

      //demo3 
      setTimeout(function () {
        console.log(1);
        console.log(2);
        setTimeout(function () {
          console.log(3);
          console.log(4);
        }, 1000)
      }, 1000)
      console.log(5);
      setTimeout(function () {
        console.log(6);
        setTimeout(function () {
          console.log(7);
        }, 1000)
        console.log(8);
      })
      //  5  6 8 1 2  7  3 4

      //demo  4
    setTimeout(function () {
    console.log(1);
    setTimeout(function () {
      console.log(2);
    }, 1000)
    setTimeout(function () {
      console.log(3);
    }, 0)
     })
      console.log(4);
      setTimeout(function () {
    setTimeout(function () {
      console.log(5);
    }, 0)
    console.log(6);
    setTimeout(function () {
      console.log(7);
    })
    }, 1000)
    // 4 1 3 6  2 5 7
    // 4 1 3 6  7 5 2

    //demo
    
  setTimeout(function () {
    setTimeout(function () {
      setTimeout(function () {
        console.log(1);
      }, 1000);
      console.log(2);
    });
    console.log(3);
  }, 1000);
  console.log(4);
  setTimeout(function () {
    setTimeout(function () {
      setTimeout(function () {
        console.log(5);
      });
      console.log(6);
    }, 1000);
    console.log(7);
  });
  console.log(8);
  //4 8 7 3 6 2 5 1 


    //
     var i = 0;
    function a() {
    console.log(i++);  //0 
    }
    setTimeout(function () {
    a() //0
    setTimeout(function () {
      console.log(i++); //4
    }, 1000)
    console.log(i++); //1
  })
  setTimeout(function () {
    a() //2
    setTimeout(function () {
      console.log(i++); //5
    })
    console.log(i++); //3
  }, 1000)



    ```


## 函数防抖节流
>防抖:指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。(函数只执行最后一次触发的事件)
>节流:指连续触发事件但是在 n 秒中只执行一次函数（函数在n秒内只会执行一次）
#### 防抖
- 在函数需要频繁触发时：在规定的时间内只让最后一次生效，前面的不生效 （例如王者荣耀中的回城）
- 适合多次事件只执行一次响应的情况
  - 场景：输入框搜索联想
- demo
    ```js
      //防抖测试
       <div id="content"
        style="height:150px;line-height:150px;text-align:center; color: #fff;background-color:#ccc;font-size:80px;">
    </div>
    <script>
        var num = 1;
        var content = document.getElementById('content');
        var sid = 0;
        function count() {
            clearTimeout(sid)
            sid = setTimeout(function () {
                content.innerHTML = num++;
            }, 1000)
        };
        content.onmousemove = count;
    </script>

    ```
#### 节流
- 在函数需要频繁触发时：函数执行一次后后，只要大于等于设定的执行时间才会执行第二次（例如王者荣耀中的技能）
- 适合多次事件按时间平均分配触发
  - 场景：窗口调整、页面元素滚动 、元素的拖拽 、抢购的疯狂点击
- demo
    ```js
    //节流测试
     <div id="content"
        style="height:150px;line-height:150px;text-align:center; color: #fff;background-color:#ccc;font-size:80px;">
    </div>
    <script>
        var num = 1;
        var content = document.getElementById('content');
        var flag = true;
        function count() {
            if (flag) {
                content.innerHTML = num++;
                setTimeout(function () {
                    flag = true
                }, 1000)
            }
            flag = false
        };
        content.onmousemove = count;
    </script>
    ```

## 三大缓存 Cookie、sessionStorage、localStorage
- **缓存特点 不存在跨浏览器获取缓存  缓存的数据格式必须是字符串的形式**
- 缓存是暂时性的存储  不能永久化的保存
### Cookie 
  - 可以设置失效时间,默认情况关闭浏览器 Cookie自动被清除
  - 储存大小4kb左右  存储量较小
  - 可以与服务器通信 一般用于携带 会话秘钥token值 等一些简短的字符串
  -**只有服务器中才有Cookie 同一浏览器中可以跨页面获取 但不能跨服务器**
  - Cookie 的增删改查
    ```js
      // 增 储存形式以键值对的形式存储 
       document.cookie = 'a=测试测试1'
       document.cookie = 'b=测试测试2'
       let a=document.cookie = 'd=测试测试3'
      //查 打印出所有的cookie
       console.log(document.a);

      //删
      //不设置过期时间 默认关闭浏览器 清除所有cookie
      //给coolie 设置时间 设为过去式的时间 当前coikie就此删除
      //expires世界标准时间 UTC 
      //new Date() 获取到的是中国标准时间 GMT 
      //new Date().toUTString() 将中国标准时间转换位世界标准时间
      document.cookie = "a=测试测试1; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
    ```
- demo 定义某时间后自动删除 cookie
  ```js
    document.cookie = 'age=18'
    const date = new Date()
    // 当前时间 加 2000 后进行删除 数据
    date.setTime(date.getTime() + 2000)
    document.cookie = 'age=18;expires=' + date.toGMTString();

  ```
### localStorage 永久储存
  - 只要不进行手动删除，就会永久有效 关闭浏览器关闭页面依然存在 
  - 储存大小 5MB 左右 视浏览器决定
  - 单纯的前端储存不参与服务器通信
  - 数据共享 打开同域名下的页面可以获取到值
  - demo
    ```js
      localStorage.setItem('a', '1');
        localStorage.setItem('b', '2');
        localStorage.setItem('c', '3');
    
        // 读取一条数据
        let data = localStorage.getItem('a');
        console.log(data);
    
    
        // 删除一条
        localStorage.removeItem('a');
    
        // 删除所有
        localStorage.clear();
    ```
### sessionStorage 会话储存
  - 只能保存在当前页面，关闭页面或者浏览器 清除 SessionStorage 不能跨域获取
  - 储存大小 5MB 左右 视浏览器决定
  - 单纯的前端储存不参与服务器通信
  - 数据不共享 仅保存在当前页面
  - demo
    ```js
      // 添加一条
    sessionStorage.setItem('abc', '123');
    sessionStorage.setItem('b', '456');
    sessionStorage.setItem('c', '789');

    // 读取一条数据 getItem('属性名');
    let data = sessionStorage.getItem('abc');
    console.log(data);

    // 删除一条
    sessionStorage.removeItem('数据名');

    // 删除所有
    sessionStorage.clear();
    ```

## 其他

### 单双引号的使用
- 单双引号在js 中 无区别 前提是成对成对的使用
- 但是 出现嵌套时候 **不可以双引号套双引号 单引号套单引号**
- 多个引号嵌套时  单双引号同时使用 

### 多维数组
- 如何获取多维数组中的值
  - demo
  ```js
        var a = [[['a'], ['b']], ['c'], "d"]
        console.log(a[0][0]);  //['a']
  ```
### 主流浏览器 js 解析引擎
- Chrome  --> V8
- Firefox --> OdinMonkey (奥丁猴)
- Safari   --> JsCore
- IE      --> Chakra (查克拉) 
## 待处理

### 特殊字符
- 特殊字符
- 特殊字符使用 \+字符
  - \'	单引号
  - \"	双引号
  - \\	斜杆
  - \n	换行
  - \r	回车
  - \t	tab
  - \b	空格
  - \f	换页
	
	



### 单双引号的使用
- 单双引号在js 中 无区别 前提是成对成对的使用
- 但是 出现嵌套时候 **不可以双引号套双引号 单引号套单引号**
- 多个引号嵌套时  单双引号同时使用 
## 补充
- JSON.stringify() 方法用于将 JavaScript 值转换为 JSON 字符串。
-  JSON.parse() 方法将数据转换为 JavaScript 对象
### 其他
- 事件 window.onload()  文档加载完触发事件
- 内存溢出与泄露
  - 内存溢出: 当前程序执行 所需要的内存 大于 当前电脑的内存.程序抛出异常
  - 内存泄露: 每个变量的赋值，都是开辟一个新的内存,内存得不到释放，就会产生泄露问题。

###
- 匿名函数，回调函数，递归函数，构造函数
- 函数的this指向 谁调用 指向谁

### instanceof 与  typeof 区别
- instanceof 判断当前对象 是否是从 另外一个对象 实例化出来的
  - demo
    ```js
    // 通过 instanceof   判断当前A数据是否为B的实例化对象
    // 语法  A instanceof B
    var a = [1, 2, 3]
    var b;
    console.log(a instanceof Array); //true  
    ```

### 面向对象  构造函数
- 构造函数中 this.xxx=xxx  表示 是所有实例化对象都具备的共有属性 
- 构造函数中 var 声明的变量 表示 是实例化对象的私有属性  
###  封装 继承 （多态）

### 闭包是什么？ **函数内部的变量 函数外部无法调用**
- 简单来说 闭包就是能够读取其他函数内部变量的函数

### 运算符
- 重点: 当出现运算符进行运算的时候，会默认将数据类型转换为 数字 进行运算
- 非数组的值 跟 数字 进行运算 得到的是 NaN
- 当字符串 碰到 + 不是运算作用 是拼接 其他时候 都是 运算作用


## js中代码折叠
- //#region  头
- //#endregion 尾

## 加密 解密
- 1.window 自带的加密解密方式
  - window.btoa(xxx) 加密 btoa()
    - 方法用于创建一个 base-64 编码的字符串，接收一个字符串作为参数。该方法使用 "A-Z", "a-z", "0-9", "+", "/" 和 "=" 字符来编码字符串。
  - window.atob(xxx) 解密
    - atob() 方法用于解码使用 base-64 编码的字符串。atob() 方法接收一个通过 btoa() 方法编码的字符串
```js
  let a = 123465
  let b = window.btoa(`xbg${a}xbg`)
  console.log(b);
  console.log(window.atob(b));
```

