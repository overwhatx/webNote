# VUE2
## 简介
- 组件式开发 
- 不操作任何dom
- 数据双向绑定
## vue 的MVVM 含义 
- mvvm是 Model-View-ViewModel 的缩写，即 模型-视图-视图模型。
- Model：数据模型，后端传递的数据。(data，props，computed等部分）                              数据模型
- View：代表 UI 组件，它负责将数据模型转化成 UI 展现出来。（template部分）                      页面模板
- ViewModel：是一个同步View 和 Model的对象。是MVVM模式的核心，它是连接Model和View的桥梁。      连接同步 数据模型 和 页面模板的桥梁 
## 第一个vue
- `{{value}}` 插值表达式 需要注意 **在插值表达式中 null 和undefined 无法渲染出来 其余都可以**
- demo
    ```js
    <body>
    <div id='app'>
        <!--  v-model="texts" 指令  vue自定义标签属性v-开头  属性值是一个js的表达式  -->
        <input type="text" v-model="texts">

        <!-- 插值 双大括号表达式 动态显示数据  显示数据  {{xxx}} -->
        <p>hello {{texts}}</p>
    </div>
    <p id="test2">{{test2}}</p>

    </body>
    //引入 vue.js 文件
    <script src='js/vue.js'></script>
    <script>
    //配置对象 属性名是特定的名称 每个属性就是一个选项
    var vm = new Vue({
        //el 指定element选择器
        el: '#app',     //el:元素的挂载位置 （值可以是css选择器或者dom元素）  选择器字符串 用于指定模板的根元素
        data: {         // 包含一些数据属性的对象 为模板提供数据   data 初始化数据 页面可以访问
            texts: 'world'
        }
    })
    var vm = new Vue({
        data: {
            test2: 'test2'
        }
    }).$mount('#test2')  //.$mount('#app'); //不写el 使用 $mount() 也可以
    </script>
    ```
## 指令
- v-model 指令 双向数据绑定 **只能绑定在表单元素上 在其他元素上将报错**
  - 单向数据绑定: 数据流向 data ==> template 模板页面
  - 双向数据绑定: 数据流向 data `<==>` template 模板页面
- v-bind: 指令 属性绑定 属性值是一个动态值 缩写在属性值前面添加 “ : 冒号 ”
  - demo
    ```html
        <a v-bind:href="url" target="__blank">百度一下 方式1</a><br />
        <!-- 缩写方式 -->
        <a :href="url" target="__blank">百度一下 方式2 在属性值前面添加 “ :冒号 ”</a>
       <script>
        var vm = new Vue({
        el: '#app',
        data: {
            url: 'https://www.baidu.com'
        }
        })
        </script>
    ```
- v-on:事件类型  绑定事件监听器  **监视 监听 一定有回调函数** 缩写 事件前加 @
    ```js
   <button v-on:click="test1">绑定事件监听 方式1</button>
   <button @click="test1">绑定事件监听缩写 方式2</button>
    <script>
    // 监视 监听 一定有回调函数
     methods: {
            test1(event) {
                // 获取到按钮的文本
                console.log(event.target.innerText);
            }
    </script>
   ```
  - 元素绑定多个事件 `  <div class="abc" v-on={click:btnClick,mousemove:btnMove}>多个事件</div>  ` 使用对象形式进行多个事件的绑定
  
- v-cloak 解决vue插值表达式 闪动问题
  - ` <div id='app' v-cloak></div>  [v-cloak]{display:none}` v-cloak指令 配合  样式
  - 原理：先进行隐藏 等待数据发生变化在进行显示  是给自定义属性添加样式 不是给挂载的元素设置样式
- v-once 只编译一次 响应完一次 就不再具备响应式功能
- v-text 填充纯文本：相比插值表达式更加简洁 不存在闪动问题
- v-html 填充html片段：存在安全问题、本网站内部的数据可以使用，来自第三方的数据不可用
- v-pre 填充原始信息：显示原始信息，跳过编译过程（分析编译过程）
- v-show 条件渲染 显示隐藏
    - v-show 不支持 <teplate></teplate> 元素 也不支持 v-else
- v-if v-else-if v-else 判断是否渲染元素 但凡复合 判断条件 则渲染该元素
  - if判断但凡进入条件 则不在继续判断
  - demo
    ```html
    <div id='app'>
        <p v-if="score>=90"> 优秀</p>
        <p v-else-if="score<90&&score>=60"> 良</p>
        <p v-else="score<60"> 不及格</p>
    </div>
    <script>
        var vm = new Vue({
            el: '#app',
            data: {
                score: 59
            },
            methods: {},
        })
    </script>
  ```
- v-for 循环指令
  - 循环语句中 v-for 必须搭配key 帮助区分不同元素 提高性能  (vue 是虚拟dom)
    - 当循环数组的时候 不要使用 index 下标 而是使用 item.id
    - 当循环对象的时候 使用 index  或item.id 都可以
    ```html
        <div id='app'>
        <ul>
            <!-- 数组 是子项和下标 key值是 子项的id  items-元素 index-下标-->
            <li v-for="(items,index) in arr" :key="items.id">{{items}}--{{index}}</li>
            <!-- 对象是键值对 key值是index  key-键 values-值 index-下标-->
            <li v-for="(key,values,index) in obj" :key="index">{{values}}-{{key}}-{{index}}</li>
        </ul>
    </div>
    <script>
        var vm = new Vue({
            el: '#app',
            data: {
                arr: ['a', 'b', 'c'],
                obj: {
                    a: 'aa',
                    b: 'bb',
                    c: 'cc'
                }
            },
            methods: {},
        })
    </script>
    ```

### 分支v-if else渲染 和 v-show
- v-if  是真正条件上的渲染 但是只有当条件为真的时候 才会开始渲染满足的条件块 进行重排操作
- v-show 不管条件是否满足 元素依然会被渲染 只是简单基于css进行切换 进行重绘操作
- 当一条语句上 两者同时出现 v-if 的优先级更高 因为 当条件不成立不渲染 v-show无法操作
## 实例方法
- vm.$mount  实例方法 手动地挂载一个未挂载的实例
## @keyup 键盘事件 以及自定义
- @keyup.enter 键盘回车触发
- @keyup.delete 键盘退格或delete触发
- 自定义修饰符
  - 可以使用@keyup事件 配合 event.keyCode 获取到键盘的值
  - demo
    ```html
        <div id='app'>
        <input @keyup="code">
        <input @keyup.115="codef4">
        </div>
        <script>
        var vm = new Vue({
            el: '#app',
            data: {},
            methods: {
                code: function () {
                    //获取到键盘值
                    console.log(event.keyCode);
                },
                codef4: function () {
                    console.log('点击了f4');
                }
            },
        })
    </script>
    ```
## class和style样式绑定
### :class
- v-bind:class 数组形式 、对象形式 、 对象与数组混合形式 、 简写形式
    ```html
     <div id='app'>
    <p v-bind:class="{active:show}">对象形式</p>
    <button v-on:click='handle'>切换状态</button>
    <p :class="[isActive,isBg]">数组形式</p>
    <p :class="allar">数组形式 简写</p>
    <p :class="objarr">对象形式 简写</p>
    </div>
    <script>
        var vm = new Vue({
            el: '#app',
            data: {
                show: true,  //为true 表示添加样式 false 删除样式
                isActive: 'active', //值为 class类名
                isBg: 'bg',
                allar: ['active', 'bg'], //简写数组形式 数组包裹class类名
                objarr: {//简写对象形式 
                    active: true,
                    bg: true
                }
            },
            methods: {
                handle() {
                    this.show = !this.show
                }
            },
        })
    </script>
    ```
- 动态绑定的 class 可以和普通的 class 同时使用 且不会覆盖掉
  - `<p class="a"  v-bind:class="{active:show}">对象形式</p>`  当前元素的 calss为： a 和 active
### :style 抒写的是行内样式
- demo
  ```html
        <div id='app'>
        <p :style="{color:iscolor,background:isbg}">文字</p>
        <button v-on:click='handle'>切换状态</button>
        <div :style="allobj">style 对象简写</div>
        <div :style="allarr">style 数组简写</div>
         </div>
        <script>
        var vm = new Vue({
            el: '#app',
            data: {
                iscolor: 'red',
                isbg: 'blue',
                allobj: {
                    width: '100px',
                    height: '100px',
                    background: 'lightblue'
                },
                allarr: [{
                    width: '100px',
                    height: '100px',
                    background: 'lightpink'
                }]
            },
            methods: {
                handle() {
                    this.iscolor = 'green'
                }
            },
        })
    </script>
  ```
- show ` <p :class="{active:show}">文字</p>`  控制样式 显示 控制属性名是否存在 在 data数据中可以进行控制为 true或false
### scoped 让样式在局部生效，防止冲突 写法：`<style scoped>`
## 修饰符
- .prevent 阻止默认事件
- .stop 阻止冒泡
- .capture 开启捕获模式
- .once 只触发一次回调
- .self 只当事件是从侦听器绑定的元素本身触发时才触发回调
- .passive 监听滚动事件 立即触发
- .left 只当点击鼠标左键时触发
- .right 只当点击鼠标右键时触发
- .middle 只当点击鼠标中键时触发
- .passive {passove:true} 模式添加侦听器
- .{keyAlias} 仅当事件是从特定键触发时才触发回调
### 表单修饰符
- .lazy 输入框失去焦点才进行响应 将input事件转换为 change事件
- .number 将输入的值通过 parseFloat 进行转换 
- .trim  去除表单首尾空格
## 自定义指令 Vue.directive
-  全局注册指令 Vue.directive
   -  定义的时候不加 v- 使用时加 命名时单词和单词之间使用 -隔开不要使用驼峰 directive中使用的时有带-的命名 使用''包裹
   -   钩子函数 inserted **一旦渲染在父级中 则立即触发**
       - 被绑定的元素插入父节点时调用 （仅保证父节点存在 但不一定已被插入文档中）  
   -  demo 定义一个自动聚焦输入框的全局指令
    ```js
        Vue.directive('focus', {
            // 当被绑定的元素插入到 DOM 中时……
            inserted: function (el) {
                // 聚焦元素
                el.focus()  // 页面加载完成之后自动让输入框获取到焦点的小功能
            }
        })

         //自定义指令传参
        <input type="text" v-focus="{color:'lightpink'}">
        Vue.directive('focus', {
            // 当被绑定的元素插入到 DOM 中时……
            inserted: function (el, binding) {
                // el 绑定的指定的元素
                // binding  指令名称 不包含 v-
                // value 传入的值
                console.log(el);

                el.style.background = binding.value.color

            }
        })

    ```
- demo （函数形式）自定义一个big指令 使用后 放大当前数字的10倍
  ```js
    <template>
      <div>
        <h1>一个数{{ num }}</h1>
        <h2>放大十倍的num值： <span v-big="num"></span></h2>
        <button @click="num++">点击触发自定义事件</button>
      </div>
    </template>
    <script>
    export default {
      name: "Vue2TestApp",
      data() {
        return {
          num: 0,
        };
      },
      directives: {
        // big函数何时被调用：1.指令与元素成功绑定时 2.指令所在的模板被重新解析时
        // element 为真实dom  binding为对象（得到被绑定元素所有信息） 主要使用其中的value
        big(element, binding) {
          console.log(element, binding);
          console.dir(element);
          // 判断是否是真实DOM
          console.log(element instanceof HTMLElement);
          console.log(binding.value);
          element.innerText = binding.value * 10;
        },
      },
    };
    </script>
  ```
- demo （对象形式）自定义一个fbing指令 使用后 自动对焦输入框并把绑定的数据放大10倍
  ```js
    <template>
      <div>
        <router-view />
        <h1>一个数{{ num }}</h1>
        <input type="text" v-fbing:value="num" />
        <button @click="num++">点击触发自定义事件</button>
      </div>
    </template>

    <script>
    export default {
      name: "Vue2TestApp",
      data() {
        return {
          num: 0,
        };
      },
      directives: {
        // 自定义 fbing指令 实现进入页面input框自动对焦输入框 获取num值
        // 因为 使用函数方法只有两个时机触发调用 导致刚进入页面时 无法获取焦点（具体原因为vue模板元素并没有渲染）
        /*  fbing(element, binding) {
          console.log(element, binding);
          element.value = binding.value;
          element.focus();
        }, */
        fbing: {
          // 指令与元素成功绑定时 触发
          bind(element, binding) {
            console.log("bind");
            element.value = binding.value;
            element.focus();
          },
          // 指令所在元素被插入页面时 触发
          inserted(element) {
            console.log("inserted");
            element.focus();
          },
          // 指令所在模板被重新解析时 触发
          update(element, binding) {
            console.log("update");
            element.value = binding.value * 10;
            element.focus();
          },
        },
      },
    };
    </script>
  ```
## computed 计算属性
- 对于任何包含响应式数据的复杂逻辑，都应该使用计算属性
- computed:{} 计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例
    - 根据依赖关系进行缓存的计算，只有在它的相关依赖发生改变时才会进行更新 
    - 在数据不发生变化时，计算属性是不需要重新计算的
    - 但是如果依赖的数据发生变化，在使用时，计算属性依然会重新进行计算
- watch:{} 选项|数据  一个对象，键是需要观察的表达式，值是对应回调函数
- vm.$watch(){}实例方法  观察 Vue 实例上的一个表达式或者一个函数计算结果的变化
- 什么时候使用计算属性: 如果要显示的数据可以根据现有的数据产生那就使用计算属性
- demo
   ```html
    // 需求：
    // 1．给p添加一个新的属性: fullName= firstName + '-' + lastName
    // 2．如果修改了firstName/lastName,furllName自动改变为对应的值
    // 3．如果修改了fullName，firstName和lastName也自动改变为对应的值
    <div id="app">
        firstName: <input type="text" v-model="firstName">
        lastName:<input type="text" v-model="lastName">
        fullName1单向绑定:<input type="text" v-model="fullName1">
        fullName2双向绑定:<input type="text" v-model="fullName2">
        fullName3单向绑定watch:<input type="text" v-model="fullName3">
    </div>
    <script>
    var vm = new Vue({
        el: '#app',
        data: {
            //初始化数据
            firstName: 'A',
            lastName: 'B',
            fullName3: 'A-B'
        },
        // 计算属性
        computed: {

            // 简写显示 等同于单独写了getter
            // 初始显示 执行了一次
            // 依赖的数据发生改变 会进行执行
            fullName1() {
                console.log(this);
                return this.firstName + "-" + this.lastName
            },
            fullName2: {
                get() {  //监视依赖数据
                    return this.firstName + "-" + this.lastName;
                },
                set(value) { //监视自身 当自身发生改变的时候 进行后续处理
                    const names = value.split('-')
                    this.firstName = names[0]
                    this.lastName = names[1]
                }
            }

        },
        //   watch方式1 监听firsName
        watch: {
            // 当firsName发生改变的时候执行 并改变 fullname3
            firstName(value) {
                this.fullName3 = value + '-' + this.lastName;
            }
        }
    })

    // watch方式2 首先 声明定义vue模板
    // 当lastName发生改变的时候执行 并改变 fullname3
    vm.$watch('lastName', function (value) {
        this.fullName3 = this.firstName + "-" + value;
    })

    /*
    1.veu控制的所有回调的this都是 vm|组件对象
    2.vue给vm定义一些与data中属性对应的属性  条件 同名

        getter方法 当通过 vm.xxx读取属性值时，读取data对象中同名属性的值
        setter方法 当通过 vm.xxx=value 指定新的值时，值就保存data中对应的属性上
    数据代理 vm.data=xxx ===> vm.xxx 通过vm代理对vm内部的data对象的属性的操作 读|写 
    */
    </script>
   ```
- 计算属性 对于逻辑比较复杂的地方 使用计算属性 使得模板更加的简洁
- demo
  ```html
     <div id='app'>
        <p>{{msg}}</p>
        <p>{{trans}}</p>
    </div>
    <script>
        var vm = new Vue({
            el: '#app',
            data: {
                msg: '你好哇'
            },
            // 事件方法
            methods: {},
            // 触发逻辑上的业务
            computed: {
                trans() {
                    return this.msg.slice(0, 2).split(' ').reverse().join()
                }
            }
        })
    </script>
  ```
### computed计算属性 和 methods方法的区别
  - computed 计算属性 是基于其他的依赖进行缓存的
  - methods 方法 是不存在缓存的
## watch 侦听器
- 监听的数据发生改变 侦听器绑定的方法就会触发 
- 侦听器 适用于数据变化时执行异步或开销（耗时）较大的操作
  ```html
    <!-- demo 案例1 -->
    <div id='app'>
    <p>姓：<input type="text" v-model="fistName"></p>
    <p>名：<input type="text" v-model="lastName"></p>
    <p>{{names}}</p>
    </div>
    <script>
    var vm = new Vue({
        el: '#app',
        data: {
            fistName: '阿姨',
            lastName: '洗铁路',
            names: '阿姨 洗铁路'
        },
        methods: {},
        watch: {
            fistName(v) {
                this.names = v + " " + this.lastName;
            },
            lastName(v) {
                this.names = this.fistName + " " + v;
            }
        },
    })
    </script>
  ```
  ```html
    <!-- 案例2  模拟进行后天校验 -->
    <div id='app'>
      <p><input type="text" v-model.lazy="userName"> {{msg}}</p>
      </div>
      <script>
      /**
       * 通过v-model 实现数据绑定
       * 需要提供提示信息
       * 需要侦听监听输入信息的变化
       * 需要修改触发的事件     
      */
      var vm = new Vue({
          el: '#app',
          data: {
              userName: '',
              msg: '',
          },
          methods: {
              serverUser(val) {
                  let that = this;
                  setTimeout(function () {
                      if (val == 'admin') {
                          that.msg = '用户名已存在'
                          return;
                      } else {
                          that.msg = '可以使用'
                      }
                  }, 2000)
              }
          },
          watch: {
              userName(val) {
                  this.serverUser(val)
                  this.msg = '后台验证中。。。。。'
              },
          },
      })
    </script>
  ```
- watch 获取侦听数据 发生改变前和改变后的值
  - 获取的值如果是个对象 那么拿到的数据为代理对象 （proxy）
  - **获取原生对象** `Vue.toRaw(xxx)`
  ```js
     data: {
            message: 'Hello Vue',
            info: {name:'张三',age:18},
        },
        methods: {
          changeMessage(){
            this.message='Hello World'
            this.info={name:'李四',age:19}
          }
        },
        watch: {
            message(newValue,oldValue) {
              console.log('message 发生了变化',newValue,oldValue)
               
            },
            info(newValue,oldValue) {
                console.log('info 发生了变化',newValue,oldValue)
                // 获取原生对象
                 console.log(Vue.toRaw(newValue))
            }
        },
  ```
- watch 默认不会进行深度监听 （例如单独修改被侦听对象的某一个属性）
  ```js
     // watch 的配置选项 
     data: {
            message: 'Hello Vue',
            info: {name:'张三',age:18},
        },
        methods: {
          changeMessage(){
            this.message='Hello World'
            this.info={name:'李四',age:19}
          },
          changeText(){
          console.log(this.message)
          }
        },
        watch: {
           info:{
                handler(newValue,oldValue) {
                console.log(newValue,oldValue)
            },
            deep:true, //开启深度监听 （默认false）
            immediate：true，//开启立即执行侦听 （默认false）
           },
           //单独侦听对象中的某个属性
           "info.name":function(newValue,oldValue){
            console.log(newValue,oldValue)
           },
           //侦听并调用 methods中定义的函数
            message:"changeText"
            
        },
  ```
- $watch 侦听
  ```js
     data: {
            message: 'Hello Vue',
            
        },
        methods: {
          changeMessage(){
            this.message='Hello World'
          },
        },
        created(){
          //参数1 侦听源 2侦听的回调函数 3侦听配置项
          this.$watch('message',(newValue,oldValue)=>{
          console.log(newValue,oldValue)
          },{deep:true,immediate：true})
        }
       
  ```
## filter 过滤器 
- 将指定的数据进行处理 否则执行原数据
- 将数据进行处理 得到新的数据
- 多个过滤器 后面的会覆盖前面的
### 全局过滤 和局部过滤
- demo
  ```html
  
     <div id='app'>
        <input type="text" v-model='msg'>
        <!-- 将首字母转为小写  lower-->
        <div>{{msg | lower}} </div>
        <!-- 将首字母转为小写 在转换为大写 后面的过滤会覆盖前面的 -->
        <div>{{msg | lower | upper}} </div>
        <!-- 同时也可也作用于其他地方的过滤操作  -->
        <div :class="msg|upper"></div>
     </div>
    <script>
        // 定义一个全局过滤
        Vue.filter('lower', function (val) {
            return val.charAt(0).toLowerCase() + val.slice(1)
        })
        // Vue.filter('upper', function (val) {
        //     return val.charAt(0).toUpperCase() + val.slice(1)
        // })
        // 多个过滤器 后面的会覆盖前面的
        var vm = new Vue({
            el: '#app',
            data: {
                msg: ''
            },
            methods: {},
            //局部过滤
            filters: {
                upper: function (val) {
                    return val.charAt(0).toUpperCase() + val.slice(1)
                }
            }
        })
    </script>
  ```
### 带参数的过滤
- demo
  ```html
    <div id='app'>
        <!-- 渲染指定格式的数据 -->
        <div>{{datatime | time('yyy-mm-dd')}} </div>
    </div>

    <script src='../js/vue.js'></script>
    <script>
        // 将数据进行处理 得到新的数据
        // 定义一个全局过滤
        Vue.filter('time', function (val, text) {
            if (text == 'yyy-mm-dd') {
                var res = ''
                // 将时间拼接为 需要的格式
                res += val.getFullYear() + "-" + (val.getMonth() + 1) + "-" + val.getDate();
            }
            return res
        })
        // 多个过滤器 后面的会覆盖前面的
        var vm = new Vue({
            el: '#app',
            data: {
                msg: '',
                datatime: new Date(), //声明一个时间
            },
            methods: {},
        })
    </script>
  ```
## **生命周期 生命周期钩子 (vue2 总11个)**
### **4个阶段 8个生命周期函数**
- 生命周期执行顺序 init->beforeCreate->created->beformMounted->mounted->init->beforeUpdate->updated->beforeDestroy->destroyed
  - init 为初始化 在 挂载后在init 初始化
- 1.创建   
  - beforeCreate  实例化创建前  (在数据检测 数据代理之前) （啥也没哟）
  - created        实例化创建后 (在数据检测 数据代理之后)  （没有dom但有data）
- 2.挂载
  - beforeMount   模板、节点 挂载前 （没有dom但有data）
  - mounted       模板、节点 挂载完成 （有dom有data）
- 3.更新
  - beforeUpdate  （元素/组件的变更操作） 箭头data中数据 发生改变前
  - updated        元素/组件的变更操作） 箭头data中数据 发生改变后
- 4.销毁 在这个阶段可以访问数据 等 但无法改变数据
  - beforeDestroy 销毁相关的属性前
  - destroyed     销毁相关的属性后
- demo
  ```html
       <div id='app'>
        <p>{{msg}}</p>
        <!-- 使用input 双向绑定 修改值 触发变更 -->
        <input type="text" v-model="msg">
        <button @click="destroy">销毁</button>
    </div>
    <script src='../js/vue.js'></script>
    <script>
        var vm = new Vue({
            el: '#app',
            data: {
                msg: 'abc'
            },
            methods: {
                // 销毁当前vue实例
                destroy: function () {
                    this.$destroy();
                }
            },
            // this.$el 代表dom this.$data 代表数据
            beforeCreate: function () {
                console.log('beforeCreate 实例化创建前触发',this.$el,this.$data);
            },
            created: function () {
                console.log('created 实例化创建后触发',this.$el,this.$data);
            },
            beforeMount: function () {
                console.log('beforeMount 挂载前触发',this.$el,this.$data);
            },
            mounted: function () {
                console.log('mounted 挂载完成触发',this.$el,this.$data);
            },
            beforeUpdate: function () {
                console.log('beforeUpdate 变更前触发');
            },
            updated: function () {
                console.log('updated 变更后触发');
            },
            beforeDestroy: function () {
                console.log('beforeDestroy 销毁前触发');
            },
            destroyed: function () {
                console.log('destroyed 销毁后触发');
            },
        })
        </script>
  ``` 
- vm.$destroy() 完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器
### 其他vue2 生命周期钩子 3个
- activated 被 keep-alive 缓存的组件激活时调用 该钩子在服务器端渲染期间不被调用
- deactivated 被 keep-alive 缓存的组件失活时调用 该钩子在服务器端渲染期间不被调用
- errorCaptured 在捕获一个来自后代组件的错误时被调用（vue2.5新增）
## 数据变更方法
- push()
- pop()
- shift()
- unshift()
- splice()
- sort()
- reverse()
- 不会改变原有数组的方法
  - filter、concat、slice、map、join、forEach、find、findIndex、isArray、includes、indexOf、concat
### 修改响应式数据方法
- 参数1 数组名或对象  参数2 要处理的数组的下标或对象名 参数3 新的数组值或对象值
- Vue.set(vm.arr, 0, 10)
- vm.$set(vm.arr, 1, 8)
- demo
  ```html
     <div id='app'>
        <input type="text" v-model="cont">
        <div v-for="item in arr" :key="item.id">{{item}}</div>
        <button @click="add">尾部添加</button>
        <button @click="remo">尾部删除</button>
        <button @click="slice">尾部删除一项 slice</button>
        <div v-for="item in obj" :key="item.id">{{item}}</div>
    </div>
    <script>
        var vm = new Vue({
            el: '#app',
            data: {
                cont: '',
                arr: [1, 2, 3],
                obj: {
                    a: '苹果',
                    b: '榴莲',
                    c: '香蕉',
                }
            },
            methods: {
                remo() {
                    this.arr.pop();//尾部删除
                },
                add() {
                    this.arr.push(this.cont)//尾部添加
                },
                slice() {
                    this.arr = this.arr.slice(0, 2) //尾部删除一项
                },
            },
        })
        // 通过索引去改变值
        Vue.set(vm.arr, 0, '改变的数据1')
        vm.$set(vm.arr, 1, '改变的数据2')

        // 拖过键名去改变值
        Vue.set(vm.obj, 'a', '西红柿')
        vm.$set(vm.obj, 'b', '西红柿')

        vm.obj.d = '黄瓜'; //直接添加
  ```

## **组件  Vue.component**
- 注册全局组件语法：
   ```js
        Vue.component('组件名称', {
            data: 组件数据,
            template: 组件模板内容
        })
   ```
### 组件的使用全局注册组件
- 组件里面的data数据集 必须是函数形式 里面的数据 必须通过返回值返回
- 组件使用的数据和方法 是组件自身存在的 不是使用 vue实例里面的
- 每个子组件之间是相互独立的数据
- **组件模板内容必须是单个根元素** 可以是嵌套关系但不能是同级
- demo
  ```html
    <div id='app'>
        <button-btn></button-btn>
        <button-btn></button-btn>
        <button-btn></button-btn>
    </div>
    <script>
      
        Vue.component('button-btn', {
            data() { //data 必须是函数
                return { con: 0 };
            },
            // 组件模板内容必须是单个根元素 可以是嵌套关系但不能是同级
            // template: '<button @click="con++">点击次数：{{con}}</button>', 
            // template: '<button @click="jiajia">点击次数：{{con}}</button>',
            template: `
            <div>
                <button @click="jiajia">点击次数：{{con}}</button>
                <button >使用模板字符串</button>
            </div>`,
            methods: {
                jiajia() {
                    this.con += 2
                }
            }
        })
        var vm = new Vue({
            el: '#app',
            data: {},
            methods: {},
        })
    </script>
  ```
### 组件命名规范
-  组件的命名方式  使用短横线 hello-world  和 驼峰命名方式 
   - 如果使用了 驼峰命名 helloWorld  在使用该组件的时候 只在字符串模板中有效 但在普通标签中（渲染该元素）无效 
   - 但可以进行修改 将大写全改为小写 单词之间使用横杠连接 hello-world
   - 在其他组件中的字符模板中不受影响 可以直接使用驼峰
-  **根本原因是因为 html对大小写字母不敏感 不会进行区分 所以要将驼峰改为短横线命名方式** 
- demo
  ```html
      <div id='app'>
        <my-jerry></my-jerry> 
        <!-- 输出  my is Jerry-->
        <my-tom></my-tom>
        <!-- 输出 my is Tom my is Jerry-->
    </div>
    <script>
    Vue.component('myJerry', { //组件1
            data() { 
                return { con: 'my is Jerry' };
            },
            template: ` <div> {{con}}  </div>`,
        })

        Vue.component('myTom', {//组件2
            data() { 
                return { con: 'my is Tom' };
            },
            template: ` <div> 
                {{con}}  
                <myJerry></myJerry> //使用组件1
                </div>`,
        })
        var vm = new Vue({
            el: '#app',
            data: {},
            methods: {},
        })
    </script>
  ```
### 局部组件的注册  components:{} 复数加s
- 局部组件可以调用全局组件 全局无法调用局部 
- 外层定义模板 实例定义组件
- 局部组件只能在 注册他的父级组件中 进行调用
- 如果局部组件在全局组件中定义 才可以在全局组件中使用
- demo
  ```html
    <div id='app'>
        全局组件
        <button-btn></button-btn>
        局部组件
        <hello-world></hello-world>
    </div>
    <script>
        //创建一个局部组件的模板
        let helloWorld = {
            data() {
                return {
                    con: '一条语句 helloWorld'
                }
            }, template: `<div>{{con}}
                <buttonBtn></buttonBtn> //调用了全局组件
                </div>`,
        }
        Vue.component('buttonBtn', {
            data() {
                return { con: 0 }
            },
            template: `
           <div>
            <button @click='con++'>点击次数：{{con}}</button>
            <button @click='double'>点击次数+2：{{con}}</button>
            </div>
            `,
            methods: {
                double() {
                    this.con += 2
                }
            },
        })
        var vm = new Vue({
            el: '#app',
            data: {},
            methods: {},
            // 局部组件
            components: {
                'helloWorld': helloWorld, //引入局部组件
            }
        })
    </script>
  ```


## **组件通讯**

### 父组件向子组件传值 props
- 父组件向 子组件传递参数 子组件使用 props[] 接收传值
- **props接收的参数是只读的 如果需要将数据进行改变 应该复制一层到data中在进行处理**
- props 命名规范
- 子组件中的props中的属性是数组形式，可以接受父组件传入的多个值
  - 在props中使用驼峰形式，模板中需要使用短横线的形式 否则会产生警告提示
  - 在字符串模板中 没有这个限制 （在其他组件中可以使用驼峰）
  - 规范写法就是 key:'value' 当想传入的为Number类型时记得添加v-bind或简写: 否则传入的为字符串
- props 传递类型可以是 string number boolen array object
- demo
  ```html
  //父组件
    <template>
    <div class="hello">
    <p>{{ name }}</p>
    <hr />
    <Test01 :name="name"></Test01>
    </div>
    </template>
    <script>
    import Test01 from '@/views/Test01.vue'
    export default {
      components: {Test01},
      name: 'HomeView',
      data() {
        return {
          name: '张三'
        }
      }
    }
    </script>


  //子组件
    <template>
    <div>
    <h3>Test01 子组件（父子组件传值）</h3>
    <p>{{ name }}</p>
    </div>
    </template>
    <script>
    export default {
      name: 'Vue2TransferStudyTest01',
      // 方式1 普通形式
      // props: ['name'],
      // 方式2 指定数据类型 （传递非对应类型 会报错）
      // props: { name: String },
      // 方式3
      props: {
        name: {
          // 传递参数 类型
          type: String,
          // 当没有接收到传递参数时 默认值
          default: '小八嘎',
          // 是否为必传项 
          require: true
        }
      },
      data() {
        return {
          getName: this.name
        }
      }
    }
    </script>
  ```
- demo props接收的三种方式
  ```js
    // 简单接收
  // props: ["names", "age", "city"],

  // 对象接收 进行规定接收参数的类型
  // props: {
  //   names: String,
  //   age: Number,
  //   city: String,
  // },

  // 接收的同时对数据 进行类型限制 默认值指定 必要性限制
  props: {
    names: {
      type: String, //names的类型必须字符串
      required: true, //names是必要的
    },
    age: {
      type: Number, //age的类型必须数字
      default: 99, //当不传入的时候 使用默认值
    },
    city: {
      type: String,
      required: true,
    },
  },
  ```





### provide/inject 依赖注入 （给后代组件传值）
- 父组件可以直接向某个后代组件传值，不需要逐级传递
- provide 指定想要提供给后代组件的数据或方法
- inject  在任何后代组件中接收想要添加在这个组件上的数据或方法
- 要注意的是 provide 和 inject 传递的数据不是响应式的，也就是说用 inject 接收来数据后，provide 里的数据改变了，后代组件中的数据不会改变
```js
    // 爷爷组件 
    <template>
      <div class="hello">
        <Test01></Test01>
      </div>
    </template>

    <script>
    import Test01 from '@/views/Test01.vue'
    export default {
      components: {
        Test01
      },
      // 需要传递的数据
      provide() {
        return {
          xiaobaga: '大八嘎'
        }
      },
    }
    </script>

    // 父组件 只进行了引入组件
    <template>
    <div>
      <Test01son></Test01son>
    </div>
    </template>
    <script>
    import Test01son from '@/views/Test01son.vue'
    export default {
      name: 'Vue2TransferStudyTest01',
      components: { Test01son },
    }
    </script>

    // 孙子组件

    <template>
      <div>
        <p>孙子组件 {{ xiaobaga }}</p>
      </div>
    </template>
    <script>
    export default {
      name: 'Vue2TransferStudyTest01son',
      // 从爷爷组件中获取的数据
      inject: ['xiaobaga']
    }
    </script>
```

### $parent/$children (父子间数据直接使用)
-  都可以直接获取 数据，并且可以直接修改数据
#### 子组件直接使用父组件中的值 this.$parent.xxx
- 通过 `this.$parent.xxx` 可以直接拿到 当前组件的父级 data 中的数据
- 通过 `this.$parent.$parent.xxx` 可以拿到爷爷级别的数据 （但不推荐）
- 通过 this.$parent.xxx 拿到的数据 可以进行修改 并且父组件数据会跟随改变
#### 父组件直接使用子组件中的值 this.$children[0].xxx
- 通过 `this.$children[0].xxx` 可以直接拿到 当前组件的子组件 data 中的数据
- 因为子组件的个数不唯一 所以需要指定哪个子组件


### 子组件向父组件传值 $emit()/v-on
- 通过自定义事件 向 父组件进行传值  $emit() 方法
- 父组件需要监听子组件的事件
- 子组件自定义方法中 可以传入多个参数 接收多个参数 在父组件中使用 `@xxx="xxx(arguments)"`
- demo
  ```html
   // 子组件
    <script>
    export default {
      data() {
        return {
          age: 18,
          name:'张三'
        }
      },
      mounted() {
        // $emit('自定义事件名'，携带的参数)
        this.$emit('getAges', this.age)
        // 传递多个参数
        this.$emit('getAges', this.age,this.name)
      }
    }
    </script>

   // 父组件
    <template>
      <div class="hello">
        <!-- @getAges 自定义事件名  getAge 接收的函数名()-->
        <Test01 :name="name" @getAges="getAge($event)"></Test01>
        // 不填默认获取第一个参数
        <Test01 :name="name" @getAges="getAge"></Test01>
        // 获取多个参数时 使用 arguments
        <Test01 :name="name" @getAges="getAge(arguments)"></Test01>
      </div>
    </template>
    <script>
    import Test01 from '@/views/Test01.vue'
    export default {
      components: {
        Test01
      },
      name: 'HomeView',
      methods: {
        getAge(evevt) {
          console.log(evevt)
        }
      }
    }
    </script>

  ```

### ref/this.$refs 父组件直接拿到子组件的数据
- ref 如果在普通的DOM元素上，引用指向的就是该DOM元素
- 如果在子组件上，引用的指向就是子组件实例，然后父组件就可以通过 ref 主动获取子组件的属性或者调用子组件的方法
```js
    // 父组件
    <template>
    <div>
    <Test01 ref="child"></Test01>
    </div>
    </template>
    <script>
    import Test01 from '@/views/Test01.vue'
    export default {
      components: {
        Test01
      },
      name: 'HomeView',
      mounted() {
        console.log(this.$refs.child.age)
      }
    }
    </script>

    // 子组件
    <template>
    <div>
    </div>
    </template>
    <script>
    export default {
     data(){
        return{
            age:18
        }
     }
    }
    </script>
```

### EventBus 事件总线
- EventBus 是中央事件总线，不管是父子组件，兄弟组件，跨层级组件等都可以使用它完成通信操作
```js
    // 创建 js 文件 src/utils/bus.js
    // bus.js
    import Vue from 'vue'
    export const EventBus = new Vue()

    // 父组件中引入 两个儿子组件

    // 儿子组件 A

    <template>
    <div>
    <p>{{ num }}</p>
    <button @click="additionHandle">+加法器</button>
    </div>
    </template>

    <script>
    import { EventBus } from '@/utils/bus'
    export default {
      data() {
        return {
          num: 1
        }
      },
      methods: {
        additionHandle() {
          EventBus.$emit('addition', {
            num: this.num++
          })
        }
      },
    }
    </script>

    // 儿子组件 B
    <template>
    <div>计算和: {{ count }}</div>
    </template>
    <script>
    import { EventBus } from '@/utils/bus'
    export default {
      data() {
        return {
          count: 0
        }
      },
      mounted() {
        EventBus.$on('addition', (param) => {
          console.log(param)
          this.count = this.count + param.num
        })
      },
    }
    </script>

```

## 插槽
- 作用域插槽和单个插槽和具名插槽的区别：
  - 因为单个插槽和具名插槽不绑定数据，所以父组件是提供的模板要既包括样式又包括内容的。而作用域插槽，父组件只需要提供一套样式
### 组件插槽 (默认插槽)
- `<slot></slot>` 是固定的 用于命名插槽
- 父组件向子组件传递内容
- 当父组件没有填入数据的时候 自动使用默认数据填充 （在有设置默认的情况下）
- demo
  ```html
    //父组件
    <template>
    <Son><p>父组件传递给子组件slot的值</p></Son>
    </template>

    //子组件
     <template>
     <slot>子组件中slot的默认值</slot>
    </template>
  ```
### 具名插槽 (命名插槽)
- `<slot></slot>`
- 通过给模板设置 slot 类名来区分 板块
- 在父组件中 带有相匹配的slot值 会被渲染到指定结构中
- demo
  ```html
   父组件中：
   <Category>
       <template slot="center">
         <div>html结构1</div>
       </template>

       <template v-slot:footer>
          <div>html结构2</div>
       </template>
   </Category>
   子组件中：
   <template>
       <div>
          <!-- 定义插槽 -->
          <slot name="center">插槽默认内容...</slot>
          <slot name="footer">插槽默认内容...</slot>
       </div>
   </template>
  ```
### 作用域插槽
- 作用域插槽其实就是带数据的插槽，即带参数的插槽，
- 简单的来说就是子组件提供给父组件的参数，该参数仅限于插槽中使用，
- 父组件可根据子组件传过来的插槽数据来进行不同的方式展现和填充插槽内容。
- demo
  ```html
     <div id='app'>
        <!-- id 为1 的改变了字体颜色并且使用strong标签渲染  其余的不符合条件使用了a元素渲染 -->
        <!-- slot-scope 获取到子组件的值  -->
        <list :lists="lists">
            <!-- <template slot-scope="aaa"> -->
            <template v-slot:default="aaa">
                <strong v-if="aaa.info.id==1" :style="{color:'lightblue'}">{{aaa.info.name}}</strong>
                <a href="" v-else>{{aaa.info.name}}</a>
            </template>
        </list>
    </div>

    <script src='../js/vue.js'></script>
    <script>
        // slot-scope 在2.6，0版本已经废弃 可以使用 v-slot:default 插槽名 (可选，默认值是 default)
        // 作用域插槽 场景 父组件对子组件的内容进行加工处理
        Vue.component('list', {
            props: ['lists'],
            template: `
            
            <ul>
             <li v-for='item in lists' :key="item.id">
            <slot :info='item'>{{item.name}}</slot>    
            </li>    
            </ul>
            `
        })
        var vm = new Vue({
            el: '#app',
            data: {
                lists: [
                    {
                        id: 0,
                        name: '张三'
                    },
                    {
                        id: 1,
                        name: '李四'
                    },
                    {
                        id: 2,
                        name: '王五'
                    },
                ]
            },
            methods: {},
        })
    </script>
  ```
## ref 属性
1. 被用来给元素或子组件注册引用信息（id的替代者）
2. 应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）
3. 使用方式：
   1. 语法打标识 普通标签<p ref="tagP">一些文字</p>  组件<Son ref="son" />   
   2. 获取：this.$refs.xxx
## mixin 混入 
1. 功能：可以把多个组件共用的配置提取成一个混入对象（类似于封装 提高复用性）
2. 使用方式：
   第一步定义混合：
       {
           data(){....},
           methods:{....}
           ....
       }
   第二步使用混入：
   使用前需要调用文件
  全局混入：Vue.mixin(xxx)
	局部混入：mixins:['xxx']
- 注意事项
  - 如果引入的混入与当前组件发生数据冲突 当前组件的优先级更高
  - 相同的类型 以当前组件数据为主 没有的数据则进行引入
## 组件的自定义事件
1. 一种组件间通信的方式，适用于：子组件 ===> 父组件
2. 使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（事件的回调在A中）。
3. 绑定自定义事件：
   1. 第一种方式，在父组件中：<Demo @atguigu="test"/>  或 <Demo v-on:atguigu="test"/>
   2. 第二种方式，在父组件中：
          ```js
          <Demo ref="demo"/>
          ......
          mounted(){
             this.$refs.xxx.$on('atguigu',this.test)
          }
          ```
   3. 若想让自定义事件只能触发一次，可以使用once修饰符，或$once方法。
4. 触发自定义事件：this.$emit('atguigu',数据)		
5. 解绑自定义事件this.$off('atguigu')
6. 组件上也可以绑定原生DOM事件，需要使用native修饰符。
7. 注意：通过this.$refs.xxx.$on('atguigu',回调)绑定自定义事件时，回调要么配置在methods中，要么用箭头函数，否则this指向会出问题！
## 全局事件总线（GlobalEventBus）
1. 一种组件间通信的方式，适用于任意组件间通信。
2. 安装全局事件总线： (在 main.js 中进行安装)
      ```js
         new Vue({
       	......
       	beforeCreate() {
       		Vue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm
       	},
           ......
       }) 
      ```
3. 使用事件总线：
   1. 接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身。
         ```js
            methods(){
            demo(data){......}
          }
          ......
          mounted() {
            this.$bus.$on('xxxx',this.demo)
          }
         ```
   2. 提供数据：`this.$bus.$emit('xxxx',数据)`
4. 最好在beforeDestroy钩子中，用$off去解绑当前组件所用到的事件。

## 消息订阅与发布（pubsub）
## nextTick
- 语法：this.$nextTick(回调函数)
- 作用：在下一次 DOM 更新结束后执行其指定的回调。
- 什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行

## 基于promise的ajax
- demo
  ```js
        function promiseAjax(url) {
        let pm = new Promise((res, rej) => {
            let xhr = new XMLHttpRequest();
            xhr.onreadystatechange = () => {
                if (xhr.readyState != 4) return; //当状态不等于4的时候 直接退出 
                if (xhr.readyState == 4 && xhr.status == 200) {
                    // 处理正常的情况
                    res(xhr.responseText)
                } else {
                    // 处理异常情况
                    rej('服务器错误！')
                }
            }
            xhr.open('get', url);
            xhr.send();
        })
        return pm;
    }
    promiseAjax('http://localhost:3000/database1')
        .then(function (data) {
            console.log(data);
        }, function (info) {
            console.log(info);
        })
  ```
### 基于promise发送多次ajax
- demo
  ```js
         // 发送多个ajax请求 并保证请求的顺序
    promiseAjax('http://localhost:3000/database')
        .then(function (data) {
            console.log(data);
            // return 的是一个新的Promise实例对象
            // 下一个then的调用者就是上一个then return的promise实例对象
            // data 接收的是上一个异步任务处理完的结果
            return promiseAjax('http://localhost:3000/database1');
        }).then((data) => {
            console.log(data);
            return promiseAjax('http://localhost:3000/database2');
        }).then((data) => {
            console.log(data);
        })
  ```
### 使用Promise对象方法
- demo
  ```js
    // Promise.all() 并发处理多个异步任务，所有任务都执行完成才能得到结果
    // Promise.race() 并发处理多个异步任务， 只要有一个任务执行完成就能得到结果
    let p1 = promiseAjax('http://localhost:3000/a1');
    let p2 = promiseAjax('http://localhost:3000/a2');
    let p3 = promiseAjax('http://localhost:3000/a3');
    let all = Promise.all([p1, p2, p3]).then((data) => {
        console.log(data);
    })
    let ra = Promise.race([p1, p2, p3]).then((data) => {
        console.log(data);
    })
  ```
## 接口调用 fetch 方法
- text() 方法属于 fetch api的一部分 它返回一个Promise实例对象 用于获取后台返回的数据
- json() 方法 接收 JSON格式的数据
- demo 基本用法get
  ```js
   // 默认是发丝get请求
    // 方式1传参方式 传统url
    fetch('http://localhost:3000/fetch2?id=123', {
        method: 'get' //发送请求类型 get post put  delete
    }).then((data) => {
        // text() 方法属于 fetch api的一部分 它返回一个Promise实例对象 用于获取后台返回的数据
        console.log(data);
        return data.text();
    }).then(data => {
        console.log(data);
    })
    // 方式2 需要服务器端设置 接收方式
    /*
    app.get('/fetch3:id', (req, res) => {
    res.send('fetch3 Restful形式的url传递参数 id=' + req.params.id)
        })
    **/
    fetch('http://localhost:3000/fetch3:456', {
        method: 'get' //发送请求类型 get post put  delete
    }).then((data) => {
        // text() 方法属于 fetch api的一部分 它返回一个Promise实例对象 用于获取后台返回的数据
        return data.text();
    }).then(data => {
        console.log(data);
    })
    //接收数据格式
    /* 服务器设置返回数据格式为json app.get('/fetch5', (req, res) => {res.json({name: '张三',sex: '男',age: 18,})})*/
    fetch('http://localhost:3000/fetch5').then((data) => {
    // return data.text();
    return data.json();
    }).then(data => {
        // let jo = JSON.parse(data) //当使用text() 接收返回值的时候为字符串格式 转换为JSON格式
        // console.log(jo);
        console.log(data);
    })
  ```
- demo post请求方式
  ```js
     fetch('http://localhost:3000/fetch4', {
         method: 'post', //发送请求类型 get post put  delete
         body: 'name=张三&age=18',
         headers: {
             'Content-Type': 'application/x-www-form-urlencoded'
         }
     }).then((data) => {
         // text() 方法属于 fetch api的一部分 它返回一个Promise实例对象 用于获取后台返回的数据
         return data.text();
     }).then(data => {
         console.log(data);
     })


    // json 格式 需要改变body 传递方式  和 请求头 改为json

    // 使用JSON时候的报错 Uncaught (in promise) TypeError: Failed to fetch
    // 服务器解决跨域问题 res.header("Access-Control-Allow-Headers", "X-Requested-With,Content-Type,mytoken");
    fetch('http://localhost:3000/fetch4', {
        method: 'post', //发送请求类型 get post put  delete
        body: JSON.stringify({
            name: '李四',
            age: '19',
        }),
        headers: {
            'Content-Type': 'application/json'
        }
    }).then((data) => {
        // text() 方法属于 fetch api的一部分 它返回一个Promise实例对象 用于获取后台返回的数据
        return data.text();
    }).then(data => {
        console.log(data);
    })
  ```
## 接口调用 axios 方法
- demo
  ```js
    //基础使用方法
        axios.get('http://localhost:3000/axios1')
        .then(res => {
            // 注意data属性是固定的用法 用于获取后台的实际数据
            console.log(res.data)
        })
        .catch(err => {
            console.error(err);
        })
        //通过 params 传参
        axios.get('http://localhost:3000/axios2', {
        params: {
            id: 789,
        }
        })
        .then(res => {
            // 注意data属性是固定的用法 用于获取后台的实际数据
            console.log(res.data)
        })
        .catch(err => {
            console.error(err);
        })
    //  传统url传参
    axios.get('http://localhost:3000/axios2?id=123')
        .then(res => {
            console.log(res.data)
        })
        .catch(err => {
            console.error(err);
        })
        // 后台使用 restful 接收参
        /** 后台 app.get('/axios3:id', (req, res) => { res.send('hello axios id=' + req.params.id)})*/
     axios.get('http://localhost:3000/axios3:789')
         .then(res => {
             console.log(res.data)
         })
         .catch(err => {
             console.error(err);
         })
           //  post
        axios.post('http://localhost:3000/axios4', {
            names: '张三',
            age: 18,
        })
            .then(res => {
                // 注意data属性是固定的用法 用于获取后台的实际数据
                console.log(res.data)
            })
            .catch(err => {
                console.error(err);
            })
         // 通过 URlSearchParams 传递参数  (application/x-www-form-urlencoded)格式
        const params = new URLSearchParams();
        params.append('names', '李四')
        params.append('age', 18)
        axios.post('http://localhost:3000/axios4', params)
        .then(res => {
            console.log(res.data)
        })
        .catch(err => {
            console.error(err);
        })

  ```
### axios 配置
- 配置请求的基准url地址
  - ` axios.defaults.baseURL = 'http://localhost:3000/';`
    - 调用的时候  `axios.get('axios5')` 省略前缀
- 设置请求头 `axios.defaults.headers['mytoken'] = 'hello world' //设置请求头`
- 设置响应超时时间 `axios.defaults.timeout=200;`
### 拦截器
- 请求拦截 在请求发出之前设置一些信息
  - demo
    ```js
            axios.interceptors.request.use(config => {
            // 在请求发出之前进行一些信息的设置
            return config;
        }, error => {
            // 处理响应错误的信息
            return Promise.reject(error);
        });
    
        axios.get('http://localhost:3000/axios5')
            .then(res => {
                console.log(res.data)
                console.log(res.data.names)
            })
            .catch(err => {
                console.error(err);
            })
    ```
- 响应拦截 在获取数据之前对数据做一些加工处理
  - demo
    ```js
        axios.interceptors.response.use(res => {
        // 在这里对返回的数据进行处理
        var data = res.data;
        return data; //直接返回data数据 
    }, error => {
        // 处理响应错误的信息
        return Promise.reject(error);
    });
    axios.get('http://localhost:3000/axios5')
        .then(data => {
            // 经过拦截器处理后 可以直接使用data获取数据 不用res.
            console.log(data)
            console.log(data.names)
        })
        .catch(err => {
            console.error(err);
        })
    ```
### async和await
- async 关键字用于函数上 async函数的返回值是promise 实例对象
- await 关键字用于async函数当中 await可以得到异步的结果
- demo
  ```js
    //基础用法
    axios.defaults.baseURL = 'http://localhost:3000/'
    async function tests() {
        let ret = await axios.get('axios5')
        return ret.data
        // console.log(ret.data.names);
    }
    tests().then(ret => {
        console.log(ret.names);
    })

    //async和await多个异步任务处理方式
    axios.defaults.baseURL = 'http://localhost:3000/'
    async function tests() {
        let async1 = await axios.get('async1');
        let async2 = await axios.get('async2?async1=' + async1.data); //将接口返回的值 在传给接口二进行处理
        return async2.data
        // console.log(ret.data.names);
    }
    tests().then(data => {
        console.log(data);
    })
  ```
### 关于响应
- data 实际响应回来的数据
- headers 响应头信息
- status 响应状态码
- statusText 响应状态信息
## promise封装 axios
- demo 举例 
  ```js
  //需求：获取到第一个axios 中回调的数据 在发送请求
       function get(url, data) {
            return new Promise(() => {
                axios.get(url, {
                    prompt: data,
                    headers: {}
                })
            })
        }
        get('url1', { a: 123 })
            .then(res => {
                return get('url2', { a: res.data })
            })
            .then()
        get(url值,data数据)


  ```
## promise封装 async
- demo 举例
  ```js
        //需求：获取到第一个axios 中回调的数据 在发送请求
        async function as(url, data) {
            let res = await axios.get(url, data);
            let req = await axios.get('url2', res);
            return req;
        }
        as(url,data)

  ```

# 其他
## v-for 中的 key
### VNode
- VNode概念：
  -  VNode的全称是Virtual Node，也就是虚拟节点
  - 事实上，无论是组件还是元素，它们最终在Vue中表示出来的都是一个个VNode
  - VNode 的本质是一个javaScript的对象
### 虚拟DOM

### diff 算法
- Vue会对有key和没有key 调用两个不同的方法
  - 有key 调用 pathKeyedChildren 方法
  - 没有key 调用 patchUnkeyedChildren 方法

## 查看vue 版本 vue -V 或者 vue --version
## vite 构建工具 是一种新型前端构建工具，能够显著提升前端开发体验 
- 它是一个更加轻量（热更新速度快，打包构建速度快）的vue项目脚手架工具。
- 相对于vue-cli它默认安装的插件非常少，随着开发过程依赖增多，需要自己额外配置。
- 按需编译 不用等待整个应用编译完成
### 创建以及使用
- 创建项目 npm init vite-app 项目名称 或者 yarn create vite-app 项目名称
- 安装依赖 npm i 或者 yarn
- 启动项目 npm run dev 或者 yarn dev
## 重点知识 destroyed
- 生命周期执行顺序 ？
  - init->beforeCreate->created->beformMounted->mounted->init->beforeUpdate->updated->beforeDestroy->destroyed
  - init 为初始化
- Vue双向数据的原理？
  - VUE2是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调、
  - VUE3.0 通过 Proxy 来劫持数据，在数据变动时发布消息给订阅者，触发相应的监听回调
- v-for循环中的key值的作用？
  - key的作用主要是为了高效的更新虚拟dom，使用key来给每一个节点做唯一的标识
## 创键vue-cli脚手架方式
- 终端
  - vue create xxx项目名
  - Please pick a preset (预设配置)  Manually select features （手动选择功能）
  - Use history mode for router? 路由器是否使用历史模式？ y/n
  - Pick a linter / formatter config 选择一个linter/formatter配置 (ESLint配置)
    - ESLint with error prevention only  仅带错误预防的ESLint
    - ESLint + Airbnb config    ESLint+Airbnb配置
    - ESLint + Standard config  ESLint+标准配置
    - ESLint + Prettier         ESLint+更漂亮
  - Pick additional lint features: Lint on save 默认
  - Where do you prefer placing config for Babel, ESLint, etc.? 您更喜欢将Babel、ESLint等的配置放在哪里。？
  - Save this as a preset for future projects?   是否将其保存为未来项目的预设？

- ui界面创建vue项目
  - `vue ui`
## DEMO
- 通过路由传值到另一个页面 实现页面跳转并携带数据
  - demo
    ```js
    //传值页面
    updateShop (id) {
      this.$router.push({
        path: '/goods/update',
        query: {
          id
        }
      })
    }
    //接收页面
    const id = this.$route.query.id
    ```
# 面试题
## 发送请求在 created 还是 mounted？
- 该问题需要根据项目和业务的情况去进行判断
- 当一个组件引入了子组件：组件的加载顺序是 先执行 父组件前3个生命周期 -> 在执行子组件前4个生命周期 -> 最后执行父组件第4个生命周期
- 当业务需求中是父组件引入子组件，并且优先加载子组件的数据，那么在父组件中当前的请求要放在 mounted中
- 如果当前组件没有什么依赖关系 放在哪个生命周期中请求都是可以的 （但组件请求）
## 为什么不在 beforeCreate 里 发送请求？ beforeCreate和created 有啥区别？
- 如果 请求是封装在 methods函数中 然后在beforeCreate 中调用，beforeCreate 实例创建前阶段拿不到 methods 里面的方法的（报错）
- beforeCreate 和 created 有啥区别
  - beforeCreate 1.拿不到 $el 拿不到 $data 2. 拿不到 methods 中的方法
  - created 1.拿不到 $el 能拿到 $data  2. 能拿到 methods 中的方法
## 当组件中存在子组件 生命周期如何执行的？
- 父beforeCreate -> 父create -> 父beforeMount -> 子beforeCreate -> 子create -> 子beforeMount -> 子beforeMount -> 父mounted
## 在 created 中如何获取 dom？
- 实例创建后 dom元素还没有挂载 只能拿到data数据，使用普通的同步代码获取时无法获取dom元素的
- 方式1.通过异步代码就可以 获取dom元素，所有的声明周期都是同步的 异步代码最后执行 所以可以获取到dom元素 (promise 、定时器)
- 方式2.使用vue 内置的 `this.$nextTick` `this.$nextTick(res=>{ console.log(document.getElementById('home')) })`

## 加入 keep-alive 组件 会执行哪些生命周期？
- 首先 keep-alive 是用来缓存组件的
- 使用 keep-alive 组件 会增加两个生命周期  activated （缓存组件被激活时） 和 deactivated（缓存组件失活时）
- 首次进入 带有 keep-alive 的组件 会执行 5个生命周期 最后一个 activated
### 第二次或者第N次 进去会执行哪些生命周期？
- 带有 keep-alive 的组件  第二次或者第N次 进去 只会 执行一个生命周期 activated
- 不带有 keep-alive 的组件 第二次或者第N次 进去执行前4个生命周期