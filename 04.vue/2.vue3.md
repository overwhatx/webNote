# VUE3

## 选项API和组合API 概念
- vue2 中使用的就是选项api (Options API 选项形式api)
  - 代码风格：data选项写数据，methods选项写函数...，一个功能逻辑的代码分散。
  - 优点：易于学习和使用，写代码的位置已经约定好
  - 缺点：代码组织性差，相似的逻辑代码不便于复用，逻辑复杂代码多了不好阅读。
  - 补充：虽然提供mixins用来封装逻辑，但是出现数据函数覆盖的概率很大，不好维护。
- vue3 中使用的是组合api  (Composition API 组合形式api 借鉴于react hooks的思想)
  - 代码风格：一个功能逻辑的代码组织在一起（包含数据，函数...）
  - 优点：功能逻辑复杂繁多情况下，各个功能逻辑代码组织再一起，便于阅读和维护
  - 缺点：需要有良好的代码组织能力和拆分逻辑能力。
  - 补充：在vue3中同时也支持vue2.x选项API写法
- Options API 
  - 问题 使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 
  - 优势 可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。

## 新组件 Fragment
- 在Vue2中: 组件必须有一个根标签
- 在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中
- 好处: 减少标签层级, 减小内存占用

## V3 指令
- v-memo 缓存一个模板的子树。在元素和组件上都可以使用。为了实现缓存，该指令需要传入一个固定长度的依赖值数组进行比较 
  ```js
  
  ```

## setup函数
- **setup 函数中没有this 指向**
  - 从组件生命周期来看，它的执行在组件实例创建之前执行（vue2的beforeCreate）
  - 意味着在setup函数中 this 还不是组件实例，this 此时是 undefined 
- **setup 是组合API的起点 vue中所有的数据 方法 全部挂载在 setup 函数中**
- **在模版中需要使用的数据和函数，必须在 setup 中使用 return 进行返回**
- 当在vue3 中使用vu2的配置 （vue2中的data、methods、computed） 中可以访问到setup中的属性和方法
- 但是 setup 不能访问 vue2的配置 如果有重名 setup优先 (有语法检测时是不允许冲突的)
- setup 不能是个 async 函数 使用 async 后返回的是promise 模板会找不到return对象中的属性 **可以返回一个Promise实例，但需要Suspense和异步组件的配合**
- setup 函数的两种返回值
  - 方式1 若返回一个对象 则对象中的属性 、方法 在模板中都可以直接使用 
    - demo
    ```js
    <template>
      <div>
      <h1>姓名：{{ name }}</h1>
      <h1>年龄：{{ age }}</h1>
      <button @click="syhi">按钮</button>
      </div>
    </template>
    <script>
      import { h } from 'vue'
      export default {
      name: 'App',
      setup () {
        const name = '张三'
        const age = 18
        function syhi () {
          console.log(`${name}${age}岁`)
        }
        return {
          name,
          age,
          syhi
        }
      }
      }
    </script>
    ```
    - 方式2 返回一个渲染函数  可以自定义渲染内容
    - demo
      ```js
      <template>
        <div>  </div>
      </template>
      <script>
      import { h } from 'vue'
      export default {
        name: 'App',
        setup () {
          return () => {
            return h('h1', '返回一个渲染函数的参数')
          }
        }
      }
      </script>
      ```
- setup 中不能使用 let 全变为const原因 大哥说 let 定义的数据不是响应式
  - const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了
- setup 执行机制 setup 在beforeCreate 之前执行一次 this是undefined
- setup 的参数 两个
  - props 值为对象 包括 组件外部传递过来且组件内部声明接收了的属性
  - context 上下文对象
    - .attrs 值为对象 包括组件外部传递过来 但没有在 props配置中声明的属性 相当于 vue2 的 this.$attrs
    - .slots 收到的插槽内容 相当于 vue2 的this.slots (**vue3 中 使用 v-slots:xxx 不在 使用vue slots="xxx"**) 
    - .emit 分发自定义事件的函数 相当于 this.$emit

## ref 定义一个响应式的数据
- 语法 `const xxx=ref(value)`
- **操作数据时 需要 xxx.value   在模板中读取数据时 不需要**
- 接收的数据类型可以是基本类型也可以是对象类型
  - 基本类型的数据 响应式依然靠的是 Object.defineProperty()的get与set完成
  - 对象类型的数据 内部 求助了vue3 中的一个新函数 reactive 函数
- demo
  ```js
    <template>
    <div>
      <h1>姓名：{{ name }}</h1>
      <h1>年龄：{{ age }}</h1>
      <h1>职业：{{ obj.type }}</h1>
      <h1>薪资：{{ obj.money }}</h1>
      <button @click="change">按钮</button>
    </div>
    </template>
    <script>
    // 引入ref 实现响应式 ref 将数据加工成 引用对象
    import { ref } from 'vue'
    export default {
      name: 'App',
      setup () {
        const name = ref('张三')
        const age = ref(18)
        const obj = ref({
          type: '前端工程师',
          money: '10k'
        })
        function change () {
          name.value = '李四'
          age.value = 19
          obj.value.type = 'ui设计'
          obj.value.money = '20k'
        }
        return { name,  age, change,  obj}
      }
    }
    </script>
  ```

## reactive 定义一个对象类型的响应数据 （基本类型不能使用）
- 语法`const xxx 代理对象= reactive({}|[] 源对象)` 接收一个对象或数组 返回一个代理对象 （Proxy的实例对象 简称proxy对象） 
- reactive 定义的响应式数据是深层次的
- 内部基于 es6的Proxy 实现 通过代理对象操作源对象个内部的数据进行操作
- demo
  ```js
    <template>
      <div>
        <h1>姓名：{{ person.name }}</h1>
        <h1>年龄：{{ person.age }}</h1>
        <h1>职业：{{ person.obj.type }}</h1>
        <h1>薪资：{{ person.obj.money }}</h1>
        <h1>{{ person.arr }}</h1>
        <button @click="change">按钮</button>
      </div>
    </template>
        <script>
        import { reactive } from 'vue'
        export default {
          name: 'App',
          setup () {
            const person = reactive({
              name: '张三',
              age: 18,
              obj: {
                type: '前端',
                money: '10k'
              },
              arr: ['a', 'b', 'c']
            })
            function change () {
              person.name = '李四'
              person.obj.type = 'ui'
              person.arr[0] = 'abc'
            }
            return {
              person,
              change
            }
          }
        }
        </script>
  ```

## reactive与ref的对比
- 定义数据角度
  - ref 用来 定义 基本数据类型
  - reactive 用来定义 引用数据类型  （对象 数组）
  - ref 也可以用来定义 引用类型数据 ref的内部 会自动通过 reactive 转为代理对象
- 从原理角度
  - ref 通过 Object.defineProperty() 的get与set来实现响应式 （数据劫持）
  - reactive 通过使用 Proxy来实现响应式 （数据劫持），并通过Reflect 操作源对象内部的数据
- 从使用角度
  - ref 定义的数据 操作数据需要 .value  读取数据时模板中直接读取不需要 .value
  - reactive 定义的数据 操作数据与读取数据 都不需要 .value 

## vue 响应式原理
### vue2 响应式原理
- 实现原理
  - 对象类型 通过 Object.defineProperty() 对属性的读取 修改 进行拦截 （数据劫持）
    - demo
      ```js
       let person = { name: '张三'}
        // 模拟vue2中实现响应式
        let p = {};
        Object.defineProperty(p, 'name', {
          configurable: true,// 配置后可以进行删除
          // 当有人读取了name 时调用
          get () {
            return person.name
          },
          // 当有人修改了name时调用
          set (value) {
            console.log("有人修改了name");
            return person.name = value
          }
        })
        // 折叠
        //#region
        console.log(p);
        console.log(person);
        console.log(p.name = "李四");
        console.log(p.sex = '男');
        console.log(p); //{sex: '男'}
        console.log(delete p.name); //false  无法删除  配置 configurable: true 后 可以进行删除
        console.log(person);
         //#endregion
      ```
  - 数组类型 通过重写更新数组的一系列方法来实现拦截 （对数组的变更进行了包裹）
- 存在问题
  - 新增属性 删除属性 界面不会更新
  - 直接通过下标修改数组 界面不会自动更新
- demo
  ```js
    <template>
      <div id="app">
      <h1>姓名：{{ person.name }}</h1>
      <h1 v-show="person.age">年龄：{{ person.age }}</h1>
      <h1 v-show="person.sex">性别：{{ person.sex }}</h1>
      <h1>爱好：{{ person.hoop }}</h1>
      <button @click="addSex">添加sex</button>
      <button @click="delAge">删除age</button>
      <button @click="updArray">下标修改数组</button>
      </div>
    </template>
    
    <script>
    import Vue from 'vue'
    export default {
    name: 'App',
    data () { return {person: {name: '张三',age: 18,hoop: ['吃饭', '睡觉'] } } },
    methods: {
    // 添加
    addSex () {
      console.log(this.person.sex, '添加前') // undefined '添加前'
      // this.person.sex = '男' //实际数据改变但页面没变
      // 解决办法1 $set追加一个响应式的数据 sex 为追加属性 男为追加值
      // this.$set(this.person, 'sex', '男')
      // 解决办法2 sex 为追加属性 男为追加值
      Vue.set(this.person, 'sex', '男')
      console.log(this.person.sex, '添加后') // 男 添加后
    },
    // 删除
    delAge () {
      console.log(this.person.age, '删除前')
      // delete this.person.age
      // 删除一个响应式的数据
      // this.$delete(this.person, 'age')
      Vue.delete(this.person, 'age')
      console.log(this.person.age, '删除后')
    },
    // 修改数组
    updArray () {
      console.log(this.person.hoop, '处理前')
      // this.person.hoop[0] = '打豆豆'
      // 0 为数组下标 打豆豆为 修改的值
      // this.$set(this.person.hoop, 0, '打豆豆')
      //Vue.set(this.person.hoop, 0, '打豆豆')
      this.person.hoop.splice(0, 1, '打豆豆')
      console.log(this.person.hoop, '处理后')
    }}}
    </script>
   
  ```
### vue3 响应式原理
- 通过 Proxy 代理 ：拦截对象中任意属性的变化，值的增删改查
  - demo
    ```js
            // 全部到控制台输入 才能看到响应式
      let person = {
        name: '张三',
        age: 18
      }
      // 模拟 vue3 的实现响应式
      // 第二个参数一定要写 否则报错 空对象也ok 
      // person 为源数据  p为代理对象 
      let p = new Proxy(person, {
        // 访问触发
        // 第一个参数为 被访问的源数据 person 第二个参数为访问的具体属性
        get (target, propName) {
          console.log('有人读取了p身上的属性', target, propName);
          // 源数据[源数据中的属性] 返回 对应的值
          return target[propName]
        },
        // 修改触发 或 追加 触发
        // 参数3 为修改后的值
        set (target, propName, value) {
          console.log('有人修改或添加', target, propName, value);
          // 将修改的值真正的赋值给 源数据
          return target[propName] = value
        },
        // 删除触发
        // 参数 源 源属性
        deleteProperty (target, propName) {
          console.log('有人删除', target, propName);

          // 返回是否删除 成功  true/false
          return delete target[propName]
        }
      })

    ```
- 通过 Reflect 反射 ：对源对象的属性进行操作
  - demo
    ```js
            // Reflect 反射对象 
      let obj = {
        name: '张三',
        age: 18
      }
      // 查找
      console.log(window.Reflect.get(obj, "name"));
      // 修改
      console.log(window.Reflect.set(obj, "name", "李四"));
      // 添加
      console.log(window.Reflect.set(obj, "sex", "男"));
      // 删除
      console.log(window.Reflect.deleteProperty(obj, "age"));

      console.log(obj);
    ```
- Proxy 结合 Reflect
  - demo
    ```js
    let person = {
    name: '张三',
    age: 18
    }
    // 模拟 vue3 的实现响应式 雏形
    let p = new Proxy(person, {
      // 查
      get (target, propName) {
        console.log('有人读取了p身上的属性', target, propName);
        return Reflect.get(target, propName)
      },
      // 修改 或 添加
      set (target, propName, value) {
        console.log('有人修改或添加', target, propName, value);
        return Reflect.set(target, propName, value)
      },
      // 删除触发
      deleteProperty (target, propName) {
        console.log('有人删除', target, propName);
        return Reflect.deleteProperty(target, propName)
      }
    })
    ```

## computed 计算属性 同vue2
- demo
  ```js
    <template>
      <div>
        <h1>姓名：<input type="text" v-model="person.firstName"> </h1>
        <h1>年龄：<input type="text" v-model="person.lastName"> </h1>
        <h1>全名：<input type="text" v-model="person.fullName"></h1>
      </div>
    </template>
    <script>
    import { reactive, computed } from 'vue'
    export default {
      name: 'appDemo1',
      // vue2
      // computed: {
      //   fullName () {
      //     return this.person.firstName + '-' + this.person.lastName
      //   }
      // },
      setup () {
        const person = reactive({ firstName: '张', lastName: '三'  })
        // 只考虑计算属性的读取操作
        // person.fullName = computed(() => {
        //   return person.firstName + '-' + person.lastName
        // })
        // 考虑计算属性读取 和修改操作 当计算属性返回的值也被改变时的情况
        // computed 为对象形式
        person.fullName = computed({
          get () {
            return person.firstName + '-' + person.lastName
          },
          set (value) {
            // 切割为两个数组 内容全部对应
            const chai = value.split('-')
            person.firstName = chai[0]
            person.lastName = chai[1]
          }
        })
        return { person  } }  }
    </script>
  ```

## watch 监视
- 监视reactive 定义的响应式数据时  
  - 旧数据无法正确获取
  - 强制开启了深度监视 deep配置失效
- 监视reactive 定义的响应式数据中某个属性时 deep配置有效 （案例6）
### vue2 的监视
- vue2中两种监视方式 简写监视（函数形式）  和可配置监视 （对象形式）
- 语法
  - 简写 `watch:{被监视的数据xxx(new新值,old旧值){return 一些列操作}}`
  - 全写 `watch:{被监视的数据xxx{deep: true,配置,handler(new新值,old旧值){return 一些列操作}}}`
- 可以配置的监视 可以配置 属性
  - deep: true/false  是否深度监视  默认为false
  - immediate:true /false  是否立即监视 在未触发前 先进行监视
- demo
  ```js
    <template>
    <div>
    <h1>数值{{ num }}</h1>
    <button @click="num++">加加</button>
    <h1>{{ msg }}</h1>
    <button @click="msg += 'world'">同时监听多个</button>
    <hr />
    <h1>ref深层数据：{{ per.type.web.money }}</h1>
    <button @click="per.type.web.money++">监视改变ref深层数据</button>
     </div>
    </template>
    <script>
    import { ref, watch, reactive } from 'vue'
    export default {
    name: 'appDemo1',
    // vue2 中的监视
    watch: {
    // 方式1 简写方式
     num (newValue, oldValue) {
       console.log(`新值：${newValue} 旧值：${oldValue}`)
     }
    // 方式2 带配置
      num: {
      // 立即监视 在黑没有触发前就监视一次
      immediate: true,
      // 深度监视 默认是浅层监视 开启后可以监视 嵌套多层的数据
      deep: true,
      handler (newValue, oldValue) {
        console.log(`新值：${newValue} 旧值：${oldValue}`)
      }
    } 
    // 深层 不开deep 无法监视到
    per: {
      // 立即监视 在黑没有触发前就监视一次
      immediate: true,
      // 深度监视 默认是浅层监视 开启后可以监视 嵌套多层的数据
      deep: false,
      handler (newValue, oldValue) { console.log('新值：', newValue, '旧值：', oldValue) } } },
        
    setup () {
      const num = ref(0)
      const per = ref({type: {web: { money: 100 }}})
      const msg = ref('hello')
      return { num, msg, per }}}
    </script>
  ```
### vue3 的监视 **需要重听**
- 语法
- 1.监听reactive定义的全部响应式数据 或者 ref 定义的的单个响应式数据 `watch(num, (newValue, oldValue) => {一些列操作},{配置})`
- 2.监听一些ref数据 `watch([数据1,数据2], (newValue, oldValue) => {一些列操作},{配置})`
- 3.监听reactive中的一些数据 `watch([() => person.name数据1,() => person.name数据2], (newValue, oldValue) => {一些列操作},{配置})`
  - 监听单个 `() => person.name数据1`
- demo
  ```js
      <template>
    <div>
     <h1>数值{{ num }}</h1>
    <button @click="num++">加加</button>
    <h1>{{ msg }}</h1>
    <button @click="msg += 'world'">同时监听多个</button>
    <h1>{{ person.name }}</h1>
    <h1>{{ person.age }}</h1>
    <button @click="person.name += '牛逼'">reactive 改变 name</button>
    <button @click="person.age++">reactive 改变 age</button>

    <h1>薪资：{{ person.type.web.money }}</h1>
    <button @click="person.type.web.money++">reactive 改变 money</button>
     </div>
    /template>
    script>
    mport { ref, reactive } from 'vue'
    xport default {
    name: 'appDemo1',
  setup () {
    const num = ref(0)
    const msg = ref('hello')
    const person = reactive({
      name: '张三',
      age: 18,
      type: {
        web: {
          money: 20
        }
      }
    })
    // vue3 中的 watch
    // 情况1 监视 一个 ref 定义的响应式数据
    /*  watch(num, (newValue, oldValue) => {
      console.log(`新值：${newValue} 旧值：${oldValue}`)
    }, { immediate: true, deep: true }) */
    // 情况2 监视 多个 ref 定义的响应式数据 （可以同时出现多个watch 但可以简写）
    /*  watch([num, msg], (newValue, oldValue) => {
      console.log(`新值：${newValue} 旧值：${oldValue}`)
    }) */

    // 情况3 监听 reactive 定义的响应数据中的全部数据
    // 问题 监视 reactive定义的响应式数据时 oldValue无法正确获取
    // 自动开启了 深度监视 deep配置失效
    /*  watch(person, (newValue, oldValue) => {
      console.log('新值：', newValue, '旧值：', oldValue)
    }, { deep: false }) */

    // 情况 4 监听 reactive 定义的响应数据中的单个属性
    /*  watch(() => person.name, (newValue, oldValue) => {
      console.log('新值：', newValue, '旧值：', oldValue)
    }) */

    // 情况 5 监听 reactive 定义的响应数据中的一些属性
    /* watch([() => person.name, () => person.age], (newValue, oldValue) => {
      console.log('新值：', newValue, '旧值：', oldValue)
    }) */
    // 情况 6 监听 reactive 定义的响应数据中的单个属性
    // 改变了 person.type.web.money 但是无法触发 需要开启 deep 深度监视
     watch(() => person.type, (newValue, oldValue) => {
      console.log('新值：', newValue, '旧值：', oldValue)
    }, { deep: true }) 

    return { num, msg, person }
      }
    }
    </script>
  ```
### watch 监视 ref的value问题
- 当watch监听 使用 ref定义的基础数据类型 不用点value 否则监听的 具体值 而不是当前属性
- 当watch监听 使用 ref定义的复杂数据类型 **1.需要点value 否则无法监听 或者2.开启深度监听** （因为ref定义的复杂类型 同样是通过 reactive 代理完成的）  

## watchEffect 监视 
- watchEffect 未发生改变前也会触发一次 同 watch 开启了  immediate
- watchEffect 不用指定监视属性 **监视的回调中用到了哪些属性 那就监视哪些属性**
- watch 既要指定监视属性 也要指定监视回调
- watchEffect 所指定的回调中用到的数据只要发生变化 则直接重新执行回调
- watchEffect 类似于 computed 但 computed 注重计算的结果 必须要有返回值 而 watchEffect注重过程 所以不用写返回值

## **vue3 生命周期**
- vue3 中可以使用vue2的生命周期 以配置项形式抒写 需要注意的是 卸载前和卸载后 语法进行了改变
- vue3中同时出现 vue3 vue2生命周期时 vue3的生命周期优先级高于 vue2
### **4个阶段 7个生命周期** 
- **不在有创建实例后 vue2创建实例前 也改为setup**
- **vue2中生命周期钩子 beforeDestroy 和 destroyed(销毁前销毁后) 已经被重命名为beforeUnmount和unmouted**
- setup 创建实例前
- onBeforeMount 挂载DOM前
- onMounted 挂载DOM后
- onBeforeUpdate 更新组件前
- onUpdated 更新组件后
- onBeforeUnmount 卸载销毁前
- onUnmounted 卸载销毁后
  - demo
    ```js
    <template>
    <div id="app">
    {{ msg }}
    {{ texts }}
    {{ os }}
    <button @click="btn">进行更改</button>
    <button @click="del">进行销毁</button>
    </div>
    </template>
    <script>
    import { onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted, reactive, ref, toRef, toRefs } from 'vue'
    export default {
    name: 'App',
    setup () {
    let msg = reactive(
      {
        name: '张三',
        age: 18,
        sex: '男'
      }
    )
    // ref
    let texts = ref(123)
    // toRef
    let os = toRef(msg, 'age')
    // toRefs
    let refs_text = toRefs(msg)
    const btn = () => {
      msg.name = '李四'
      texts.value = 456
      os.value = 99
      refs_text.sex.value = '女'

    }
    const del = () => {
      console.log(1);
      // this.$destroy();
      // 销毁没做
    }
    // 生命周期
    onBeforeMount(() => {
      console.log('挂载DOM前')
    })
    onMounted(() => {
      console.log('挂载DOM后')
    })
    onBeforeUpdate(() => {
      console.log('更新组件前')
    })
    onUpdated(() => {
      console.log('更新组件后')
    })
    onBeforeUnmount(() => {
      console.log('卸载销毁前')
    })
    onUnmounted(() => {
      console.log('卸载销毁后')
    })
    return { msg, btn, texts, os, del }
    }
    }
    </script>
    ```
### vu3其他生命周期
#### 路由中的
- activated  缓存组件激活时
- deactivated 缓存组件失效时 （失活）
### 
- errorCaptured
- renderTracked
- renderTriggered

## 自定义 hook 函数
- 把setup 函数中使用的 Composition API（组合api） 进行封装  
- 作用：复用代码让setup中的逻辑更清楚易懂 
- demo
  ```js
  // hook/useGetPoint.js
    import { reactive, onMounted, onBeforeUnmount } from 'vue'
    export default function () {
      const point = reactive({
        y: 0,
        x: 0
      })
      function getPoint (event) {
        console.log(event.pageX, event.pageY)
        point.x = event.pageX
        point.y = event.pageY
      }
      onMounted(() => {
        // 挂载实例后
        window.addEventListener('click', getPoint)
      })
      // 销毁实例前
      onBeforeUnmount(() => {
        // 在销毁实例前 将这个事件清除 如果不进行清除 事件依然会存在
        window.removeEventListener('click', getPoint)
      })
      // 返回
      return point
    }

    // 需要调用的
     <template>
      <div>
        <h1>{{ `x:${point.x} y:${point.y}` }}</h1>
      </div>
    </template>
    <script>
    import { ref } from 'vue'
    // 引入获取位置的hook的函数
    import useGetPoint from '../hooks/useGetPoint'
    export default {
      name: 'appDemo1',
      setup () {
        const num = ref(0)
        // 进行赋值
        const point = useGetPoint()   

        return { num, point }
      }
    }
    </script>
  ```

## toRef 和 toRefs 的使用
- 创建一个ref 对象 其value值指向另一个对象中的某个属性值
- 将响应式对象中的某个属性（多个属性）提供给外部使用
- toRef 同于 toRefs 一个是单个创建一个是多个创建
- 需要注意的是 只能省略掉当前对象的最外层对象名 多级嵌套还是需要逐次写上才能获取到
- demo
  ```js
        <template>
      <div>
        <h3>{{ person }}</h3>
        <h1>姓名：{{ name }}</h1>
        <h1>年龄：{{ age }}</h1>
        <h1>城市：{{ cityss }}</h1>
        <h1>工资：{{ money }} K</h1>
        <button @click="person.city.citys.money++">money加加</button>
        <hr />
        <h4>{{ person2 }}</h4>
        <h1>姓名：{{ name2 }}</h1>
        <h1>年龄：{{ age2 }}</h1>
        <h1>工资：{{ money2.moneys2.moneyss2 }}</h1>
        <button @click="money2.moneys2.moneyss2++">money加加</button>
      </div>
    </template>
    <script>
    import { reactive, toRef, toRefs } from 'vue'
    export default {
      name: 'appDemo1',
      setup (context) {
        const person = reactive({name: '张三',age: 18,city: { citys: { cityss: '南昌',money: 10}}})
        const person2 = reactive({ name2: '李四', age2: 20, money2: { moneys2: { moneyss2: 100}}})
        return {
          person,
          // toRef
          name: toRef(person, 'name'),
          age: toRef(person, 'age'),
          money: toRef(person.city.citys, 'money'),
          cityss: toRef(person.city.citys, 'cityss'),
          person2,
          //toRefs 
          //因为拿到的是对象所以需要解构 
          ...toRefs(person2)
        }
      }
    }
    </script>
  ```

## shallowReactive 和 shallowRef  (了解)
- shallowReactive 只处理对象最外层属性的响应式 （浅层响应式）
- shallowRef 只处理基本数据类型的响应式 不进行对象的响应式处理
- 应用场景
  - 如果一个对象数据 结构比较深 但变化时只是外层属性变化 那就使用 shallowReactive
  - 如果一个对象数据 后续功能不会修改对象中的属性 或改变时是替代 那就使用 shallowRef
- demo
  ```js
        <template>
      <div>
        <h4>{{ person }}</h4>
        <h1>姓名：{{ name }}</h1>
        <h1>年龄：{{ age }}</h1>
        <h1>工资：{{ money.moneys.moneyss }}</h1>
        <!-- 使用了 shallowReactive 深层数据无法改变  （待定：有bug当点击年龄时在点击money有时候也会莫名奇妙加了） -->
        <button @click="money.moneys.moneyss++">money加加</button>
        <button @click="age++">年龄加加</button>
        <hr />
        <h4>{{ test1 }}</h4>
        <h4>{{ test2 }}</h4>
        <button @click="test1.b++">test1</button>
        <button @click="test2.a++">test</button>
      </div>
    </template>
    <script>
    import { toRefs, shallowReactive, ref, shallowRef } from 'vue'
    export default {
      name: 'appDemo1',
      setup (context) {
        // const person = reactive({
        const person = shallowReactive({ name: '李四', age: 0, money: {moneys: {  moneyss: 100} } })
        const test1 = ref({b: 456 })
        const test2 = shallowRef({   a: 123})
        console.log(test1)
        console.log(test2)
        // 因为拿到的是对象所以需要解构
        return {person,...toRefs(person), test1,test2}}
    }
    </script>
  ```

## readonly 和 shallowReadonly
- readonly 让一个响应式数据变为只读的 （深层只读）
- shallowReadonly 让一个响应式数据变为只读的 （浅层只读）意味着深层次的数据 可以被改变
- 应用场景 不希望数据被改变
- demo
  ```js
        <template>
    <div>
      <h1>姓名：{{ name }}</h1>
      <h1>年龄：{{ age }}</h1>
      <h1>工资：{{ money.moneys.moneyss }}</h1>
      <!-- 使用了 shallowReactive 深层数据无法改变  （待定：有bug当点击年龄时在点击money有时候也会莫名奇妙加了） -->
      <button @click="money.moneys.moneyss++">money加加</button>
      <button @click="age++">年龄加加</button>
      <hr />
      <h4>{{ sum }}</h4>
      <button @click="sum++">sum++</button>
    </div>
  </template>
  <script>
  import { toRefs, ref, reactive, shallowReadonly, readonly } from 'vue'
  export default {
    name: 'appDemo1',
    setup (context) {
      let person = reactive({
        name: '李四',
        age: 10,
        money: {
          moneys: {
            moneyss: 100
          }
        }
      })
      let sum = ref(0)
      // person = readonly(person)
      person = shallowReadonly(person)
      sum = readonly(sum)
      return {
        ...toRefs(person),
        sum
      }
    }
  }
  </script>
  ```

## toRaw 和 markRaw
- toRaw 
  - 作用：将一个由reactive生成的响应式对象转为普通对象。
  - 使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。
- markRaw：
  - 作用：标记一个对象，使其永远不会再成为响应式对象。
  - 应用场景:
    1. 有些值不应被设置为响应式的，例如复杂的第三方类库等。
    2. 当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。

- demo
  ```js
        <template>
      <div>
        <h1>姓名：{{ name }}</h1>
        <h1>年龄：{{ age }}</h1>
        <h1>工资：{{ money.moneys.moneyss }}</h1>
        <h1 v-show="person.car">{{ person.car }}</h1>
        <button @click="money.moneys.moneyss++">money加加</button>
        <button @click="age++">年龄加加</button>
        <hr />
        <button @click="showRawPerson">输出原始数据</button>
        <button @click="addcar">添加其他信息</button>
        <button @click="person.car.carMoney++">修改car价格</button>
      </div>
    </template>
    <script>
    import { toRefs, reactive, toRaw, markRaw } from 'vue'
    export default {
      name: 'appDemo1',
      setup (context) {
        const person = reactive({
          name: '李四',
          age: 10,
          money: {
            moneys: {
              moneyss: 100
            }
          }
        })
        function showRawPerson () {
          // 将一个由reactive 生成的响应式对象转为普通对象
          const p = toRaw(person)
          console.log(p)
          console.log(person)
        }
        // 添加一条数据
        // 在添加的时候 因为setup只会执行一次 所以还是需要将 person整个数据return 这样可以监测到整个数据的变化
        function addcar () {
          const car = { type: 'audioRs7', carMoney: 200 }
          // person.car = car
          // 标记当前当前对象 永远不在称为响应式对象
          person.car = markRaw(car)
        }
        return {
          person,
          ...toRefs(person),
          showRawPerson,
          addcar
        }
      }
    }
    </script>
  ```

## customRef 创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制

- demo 实现防抖效果
  ```js
          <template>
      <div>
        <input type="text" v-model="keyWord" />
        <h3>{{ keyWord }}</h3>
      </div>
    </template>
    <script>
    // customRef
    import { customRef } from 'vue'
    export default {
      name: 'App',
      setup () {
        function myRef (value, delay) {
          let timer
          return customRef((track, trigger) => {
            return {
              get () {
                console.log(`数据被读取了 ${value}`)
                track() // 通知vue追踪value的变化 提前跟get商量 让他认为value是有用的
                return value
              },
              set (newValue) {
                // 防抖 当改变数据时 当前函数就会被触发 在进入前先将上一次的定时器清除掉 最后只会执行一次
                clearTimeout(timer)
                console.log(`数据改变了 ${newValue}`)

                // 过500ms 后进行渲染改变后的数据
                timer = setTimeout(() => {
                  value = newValue
                  trigger() // 告诉Vue去更新界面
                }, delay)
              }
            }
          })
        }
        const keyWord = myRef('hello', 500)
        return { keyWord }
      }
    }
    </script>
  ```

## 组件通讯

### provide 与 inject  实现祖与后代组件间通信 （依赖注入）

- 父组件使用 provide 选项来提供数据，后代组件使用 inject 选项使用这些数据
```js
  // 父组件  
  export default {
  components: { Home },
  // 死数据形式
  provide: {
    name: "张三",
    age: 18,
  },
  };
  // 孙子组件
  <template>
      <h1>name:{{ name }} age:{{ age }} </h1>
  </template>
  <script>
  export default {
    name: "Home2Page",
    inject: ["name", "age"],
  };
</script>
```
- 当数据 来自 data中 需要通过 this去获取 此时this指向存在问题 **需要将 provide 改为函数形式**
- 一般情况下开发时都写成 函数形式所以尽量写成函数形式
- 但是通过当前方式 只是进行了复制的操作，**数据不是响应式的** 当父组件改变了当前data中获取来的数据时 孙子的数据不会改变
  - 通过 computed 计算属性来处理可以做到响应 （需要注意使用时 需要 .value 需要手动解包） 因为通过这样获取到的值是引用过来的 需要 .value 才能拿到具体值
```js
  //父组件
  import { computed } from "vue";
  export default {
  components: { Home },
  data() {
    return {
      city: "台州",
    };
  },
  provide() {
    return {
      name: "张三",
      age: 18,
      // 通过计算属性 复制data中的数据
      // city: computed(()=>{return this.city})
      //简写
      city: computed(()=> this.city)
    };
  },
  };

  // 孙子组件
  <template>
      <h1>name:{{ name }} age:{{ age }} city:{{ city.value }}</h1>
  </template>
  <script>
  export default {
    name: "Home2Page",
    inject: ["name", "age", "city"],
  };
</script>
```

### 全局事件总线
- Vue3从实例中移除了 $on $off 和 $once 方法，如果希望继续使用全局事件总线，要通过第三方的库
- Vue3官方有推荐一些库，例如 mitt 或 tiny-emitter; 或者其他库 hy-event-store

## 响应式数据的判断  isRef isReactive isReadonly isProxy
- isRef: 检查一个值是否为一个 ref 对象
- isReactive: 检查一个对象是否是由 reactive 创建的响应式代理
- isReadonly: 检查一个对象是否是由 readonly 创建的只读代理
- isProxy: 检查一个对象是否是由 reactive 或者 readonly 方法创建的代理
- demo
  ```js
    <template>
      <div class="App-box">根组件</div>
    </template>
    <script>
    import { reactive, toRefs, ref, readonly, isProxy, isReactive, isReadonly, isRef } from 'vue'
    export default {
      name: 'AppPage',
      setup () {
        const car = reactive({ name: 'audioRS7', price: 200 })
        const sum = ref(0)
        const car2 = readonly(car) // true
        console.log(isRef(sum)) // true
        console.log(isReactive(car)) // true
        console.log(isProxy(car)) // true
        console.log(isReadonly(car2)) // true
        console.log(isProxy(car2)) // true
        return {...toRefs(car),sum,car2}}
    }
    </script>
  ```

## teleport 标签
- teleport 标签 能够将vue的组件 html结构移动到指定位置的技术
- `<teleport to="移动位置">` 可以填写标签名 和一系列css选择器 （提前在主html中定义）
- demo
  ```js
      <teleport to="移动位置">
  	<div v-if="isShow" class="mask">
  		<div class="dialog">
  			<h3>我是一个弹窗</h3>
  			<button @click="isShow = false">关闭弹窗</button>
  		</div>
  	</div>
  </teleport>
  ```

## ref 获取元素、获取元素组件
- 需要获取的元素或组件上添加 ref='自定义名' 拿到该元素
- `this.$refs.组件上的ref名.$el` 从跟元素返回所有包裹的元素
- `this.$refs.home.FN();` 调用组件的方法
- `this.$parent` //获取父组件 （了解）
- `this.$root` //获取根组件 （了解）
```js
//  App.vue
<template>
  <div ref="names">小八嘎</div>
  <button @click="btn" ref="btn">btn</button>
  <Home ref="home"></Home>
</template>
<script>
import Home from "./Home.vue";
import { computed } from "vue";
export default {
  components: { Home },
  name: "App",
  data() {
    return {city: "台州"};},
    methods: {
    btn() {
      console.log(this.$refs.names); //<div>小八嘎</div>
      console.log(this.$refs.btn); //<button>btn</button>
      // 获取组件实例
      console.log(this.$refs.home); //Proxy{}
      // 调用子组件中的方法
      this.$refs.home.abc(); //Home 中的方法被调用了
      // 获取子组件中的元素
      console.log(this.$refs.home.$el); //从跟元素返回所有包裹的元素
      // 多个根的情况下 拿到的是 node 节点 （v3支持多个根元素 v2不支持）
      // 从多个节点中获取第一个节点
      console.log(this.$refs.home.$el.nextSibling);
      // console.log(this.$refs.home.$el.nextElementSibling);
      console.log(this.$parent, "this.$parent"); //获取父组件
      console.log(this.$root, "this.$root"); //获取根组件
      // 注意 VUE3 中移除了 $children属性 （获取组件中所有的元素或子组件）
    },
  },
};
</script>
```
```js
// Home.vue
<template>
  <div class="Home-box">
    <h1>home1</h1>
    <Home2></Home2>
  </div>
</template>
<script>
import Home2 from "./Home2.vue";
export default {
  name: "HomePage",
  components: { Home2 },
  methods: {
    abc() {
      console.log("Home 中的方法被调用了");
    },
  },
};
</script>
```
```js
// Home2.vue
<template>
  <div class="Home2-box"> <h1>home2</h1> </div>
</template>
<script>
export default {name: "Home2Page"};
</script>
```

## 动态组件

- `<component :is="currentTab"></component>`
- 使用 component 时给子组件传递数据（同普通组件）
  - `<component :is="currentTab" name="小八嘎" :age="18"></component>`
```js
<template>
  <div>
    <div class="tabs">
      <template v-for="(item, index) in tabs" :key="index">
        <button
          @click="itemClick(item)"
          :class="{ active: currentTab == item }"
        >
          {{ item }}
        </button>
      </template>
    </div>
    <div class="main">
      <!-- 普通方式 -->
      <!-- <Home v-if="currentTab == 'home'"></Home>
      <About v-else-if="currentTab == 'about'"></About>
      <About2 v-else></About2> -->

      <!-- is中的组件可以是全局或局部注册的组件 -->
      <component :is="currentTab"></component>
    </div>
  </div>
</template>

<script>
import Home from "./Home.vue";
import About from "./About.vue";
import About2 from "./About2.vue";
import { computed } from "vue";
export default {
  components: { Home, About, About2 },
  name: "App",
  data() {
    return {
      tabs: ["home", "about", "about2"],
      currentTab: "home",
    };
  },
  methods: {
    itemClick(item) {
      this.currentTab = item;
    },
  },
};
</script>

<style lang="less">
.active {
  color: red;
}
</style>

```

## keep-alive 缓存组件
- 使用标签包裹需要缓存的组件，被包裹中的所有组件都将有缓存效果
- 通过配置可以定义某些组件是否缓存
  - include（string |RegExp |Array） 指定需要缓存的组件 组件名为组件定义时的name
  - exclude（string |RegExp |Array） 被匹配到的组件都不会被缓存
  - max（string|Number） 最多可以缓存多少 组件实例，一旦达到这个数量，缓存组件中最近没有被访问的实例会被销毁
- `<keep-alive include="[a,b,c]" >被缓存的组件</keep-alive>`
```js
 <keep-alive include="HomePage">
        <component :is="currentTab"></component>
  </keep-alive>
```
### 缓存组件生命周期
- 对于缓存的组件来说，再次进入时，是不会执行created或者mounted等生命周期函数的，但是有时候我们确实希望监听到何时重新进入到了组件，何时离开了组件，可以通过 activated 和 deactivated 这两个生命周期钩子函数来监听
- activated 缓存组件激活时
- deactivated 缓存组件失活时 

## 异步组件 defineAsyncComponent

### Webpack的代码分包
- 默认情况下，在构建整个组件树的过程中，因为组件和组件之间是通过模块化直接依赖的，那么webpack在打包时就会将组件模块打包到一起（比如一个app.js文件中）；
- 这个时候随着项目的不断庞大， app.js文件的内容过大，会造成首屏的渲染速度变慢；
- 所以，对于一些不需要立即使用的组件，我们可以单独对它们进行拆分，拆分成一些小的代码块chunk.js；
- 这些chunk.js会在需要时从服务器加载下来，并且运行代码，显示对应的内容；
- webpack中如何可以对代码进行分包？
```js
// 异步导入方式
// import 函数可以让webpack对导入文件进行分包处理
import("./utils/math").then(res => {
  res.sum(200, 50)
})
```

### Vue中实现异步组件
- 如果我们的项目过大了，对于某些组件我们希望通过异步的方式来进行加载（目的是可以对其进行分包处理），那么Vue中给我们提供了一个函数： **defineAsyncComponent**
- defineAsyncComponent：接受两种类型的参数
  - 类型一：工厂函数，该工厂函数需要返回一个Promise对象；
    ```js
      <script>
      import { computed, defineAsyncComponent } from "vue";
      import Home from "./Home.vue";
      import About from "./About.vue";
      // import About2 from "./About2.vue";
      // 示例
      const About2Async = defineAsyncComponent(() => import("./About2.vue"));
      export default {
        components: {
          Home,
          About,
          About2: About2Async,
        },
        name: "App",
      };
      </script>
    ```
  - 类型二：接受一个对象类型，对异步函数进行配置；

## 组件上使用 v-model
- `<About v-model="message"></About>` 在组件上使用的时候，等价于如下的操作：
- `<About v-model="message" @update:model-value="message=$event"></About>`
- v-model默认帮助我们完成了两件事：v-bind:value的数据绑定和@input的事件监听；
```js
//  App.vue
<template>
  <div class="tabs">
    <!-- 默认 modelValue -->
    <Home v-model="homeNumber"></Home>
    <!-- 二者相等 -->
    <Home :modelValue="homeNumber" @update:modelValue="homeNumber = $event" ></Home> 

    <!-- 自定义名称 counter 以及绑定多个属性-->
    <About v-model:counter="homeNumber" v-model:message="message"></About>
  </div>
</template>
<script>
import { computed } from "vue";
import Home from "./Home.vue";
import About from "./About.vue";
export default {
  components: {
    Home,
    About,
  },
  name: "App",
  data() {
    return {
      message: "阿姨洗铁路",
      homeNumber: 99,
    };
  },
};
</script>

// Home.vue ---------------------
<template>
  <div class="Home-box">
    <h1>Home</h1>
    <h2>{{ modelValue }}</h2>
    <button @click="changeNumber">change</button>
  </div>
</template>
<script>
export default {
  name: "HomePage",
  props: { modelValue: { type: Number, default: 0, }, },
  emits: ["update:modelValue"],
  methods: { changeNumber() { this.$emit("update:modelValue", 1000); } },
};
</script>

// About.vue ---------------------
<template>
  <div class="Home-box">
    <h1>Home</h1>
    <h2>{{ counter }}</h2>
    <h2>{{ message }}</h2>
    <button @click="changeNumber">change</button>
  </div>
</template>
<script>
export default {
  name: "AboutPage",
  props: { counter: { type: Number, default: 0, }, message: { type: String, default: "呵呵"}},
  emits: ["update:counter", "update:message"],
  methods: {
    changeNumber() {
      this.$emit("update:counter", 6666);
      this.$emit("update:message", "hetui");
    },
  },
};
</script>
```

## Mixin 混入 （了解）
- 组件和组件之间有时候会存在相同的代码逻辑，我们希望对相同的代码逻辑进行抽取
- 在Vue2和Vue3中都支持
- Mixin提供了一种非常灵活的方式，来分发Vue组件中的可复用功能
- 一个Mixin对象可以包含任何组件选项
- 当组件使用Mixin对象时，所有Mixin对象的选项将被 混合 进入该组件本身的选项中
```js
// message-mixin.js
export default {
data() { return { message: 'hello world' } },
created() {console.log(this.message);}
}

// home.vue
<template>
  <div class="Home-box">
    <h1>Home</h1>
    <h2>{{ message }}</h2>
  </div>
</template>
<script>
import messageMixin from "./mixins/message-mixin";
export default {
  mixins: [messageMixin],
  name: "HomePage",
  data() {
    return {
      message: 21345,//当与混入的数据产生冲突时候
    };
  },
};
</script>
```
### Mixin的合并规则 如果Mixin对象中的选项和组件对象中的选项发生了冲突vue如何处理的？
- 情况一：如果是data函数的返回值对象
  - 返回值对象默认情况下会进行合并
  - 如果data返回值对象的属性发生了冲突，那么会保留组件自身的数据
- 情况二：如果是生命周期钩子函数
  - 生命周期的钩子函数会被合并到数组中，都会被调用
- 情况三：值为对象的选项，例如 methods、 components 和 directives，将被合并为同一个对象
  - 比如都有methods选项，并且都定义了方法，那么它们都会生效
  - 但是如果对象的key相同，那么会取组件对象的键值对
### 全局混入Mixin
- 如果组件中的某些选项，是所有的组件都需要拥有的，那么这个时候我们可以使用全局的mixin
```js
const app = createApp(App)
app.mixin({
  created() {
    console.log('global mixin created');
  }
})
app.mount('#app')
```
##

##

##

##

## 待处理

### defineAsyncComponent  异步引入组件
- demo
  ```js
    // 静态引入
    // import Father from './components/father.vue'

    import { reactive, toRefs, defineAsyncComponent } from 'vue'
    // 异步引入 配合 defineAsyncComponent使用
    const Father = defineAsyncComponent(() => import('./components/father'))
  ```

### VUE3 中的其他改变
 - 将全局的API，即：```Vue.xxx```调整到应用实例（```app```）上

    | 2.x 全局 API（```Vue```） | 3.x 实例 API (`app`)                        |
    | ------------------------- | ------------------------------------------- |
    | Vue.config.xxxx           | app.config.xxxx                             |
    | Vue.config.productionTip  | `<strong style="color:#DD5145">移除</strong>` |
    | Vue.component             | app.component                               |
    | Vue.directive             | app.directive                               |
    | Vue.mixin                 | app.mixin                                   |
    | Vue.use                   | app.use                                     |
    | Vue.prototype             | app.config.globalProperties                 |
- 移除keyCode作为 v-on 的修饰符，同时也不再支持config.keyCodes
- 移除v-on.native修饰符
- 移除了过滤器（filter）
- 移除 Vue.config.productionTip  （提示）

### $refs 直接获取到元素对象或者子组件实例
- 在Vue开发中不推荐进行原生DOM操作的
- 可以给元素或者组件绑定一个ref的attribute属性

### emits 
- 用于子传父时 明确自定义的事件名 以及对传递的参数进行验证
```js
// 1.数组形式
export default{
  
  emits:["add",'reduce'],
  methods:{
    btnClick1(){
      this.$emit('add',1)
    },
    btnClick2(){
      this.$emit('reduce',1)
    },
  }
}

// 2.对象形式 （验证的形式比较少了解就可以了）
export default{
  // 含义 当传递给 父组件时 先到这里进行一次判断 满足条件和不满足条件都会发送到父组件 但是不满足条件会出现警告
  emits:{
  add:function(count){
  if(count<=10){
    return true
  }else{
    return false
  }
}
  },
  methods:{
    btnClick1(){
      this.$emit('add',1)
    },
    btnClick2(){
      this.$emit('reduce',1)
    },
  }
}
```

###
- triggerRef 手动执行与 shallowRef 关联的任何作用(shallowRef 无法实现对象的数据成为响应式) triggerRef可以强制响应
  - demo
    ```js
      import { shallowRef, triggerRef } from "vue";
      let msg = shallowRef({ name: "小八嘎" });
      const changeMsg = () => {
        msg.value.name = "大八嘎";
        triggerRef(msg);
      };
    ```
- customRef 创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制
  - 它需要一个工厂函数，该函数接收 track 和 trigger 函数作为参数，并且应该返回一个带有 get 和 set 的对象
- vue-cli 3.x的views 和components有什么区别?
  - containers是容器级组件 components是小组件  views是页面级组件
  - 也就是说，views是页面级组件，components是小组件，小组件可被引用在views中，一般views组件不被复用containers是容器级组件（根据项目大小决定是否使用)
