# VUE2
## 简介
- 组件式开发 
- 不操作任何dom
- 数据双向绑定
## vue 的MVVM 含义 
- mvvm是 Model-View-ViewModel 的缩写，即 模型-视图-视图模型。
- Model：数据模型，后端传递的数据。(data，props，computed等部分）                              数据模型
- View：代表 UI 组件，它负责将数据模型转化成 UI 展现出来。（template部分）                      页面模板
- ViewModel：是一个同步View 和 Model的对象。是MVVM模式的核心，它是连接Model和View的桥梁。      连接同步 数据模型 和 页面模板的桥梁 
## 第一个vue
- `{{value}}` 插值表达式 需要注意 **在插值表达式中 null 和undefined 无法渲染出来 其余都可以**
- demo
    ```html
    <body>
    <div id='app'>
        <!--  v-model="texts" 指令  vue自定义标签属性v-开头  属性值是一个js的表达式  -->
        <input type="text" v-model="texts">

        <!-- 插值 双大括号表达式 动态显示数据  显示数据  {{xxx}} -->
        <p>hello {{texts}}</p>
    </div>
    <p id="test2">{{test2}}</p>

    </body>
    //引入 vue.js 文件
    <script src='js/vue.js'></script>
    <script>
    //配置对象 属性名是特定的名称 每个属性就是一个选项
    var vm = new Vue({
        //el 指定element选择器
        el: '#app', //el:元素的挂载位置 （值可以是css选择器或者dom元素）  选择器字符串 用于指定模板的根元素
        data: { // 包含一些数据属性的对象 为模板提供数据   data 初始化数据 页面可以访问
            texts: 'world'
        }
    })
    var vm = new Vue({
        data: {
            test2: 'test2'
        }
    }).$mount('#test2')  //.$mount('#app'); //不写el 使用 $mount() 也可以
    </script>
    ```
## 指令
- v-model 指令 双向数据绑定 **只能绑定在表单元素上 在其他元素上将报错**
  - 单向数据绑定: 数据流向 data ==> template 模板页面
  - 双向数据绑定: 数据流向 data `<==>` template 模板页面
- v-bind: 指令 属性绑定 属性值是一个动态值 缩写在属性值前面添加 “ : 冒号 ”
  - demo
    ```html
        <a v-bind:href="url" target="__blank">百度一下 方式1</a><br />
        <!-- 缩写方式 -->
        <a :href="url" target="__blank">百度一下 方式2 在属性值前面添加 “ :冒号 ”</a>
       <script>
        var vm = new Vue({
        el: '#app',
        data: {
            url: 'https://www.baidu.com'
        }
        })
        </script>
    ```
- v-on:事件类型  绑定事件监听器  **监视 监听 一定有回调函数** 缩写 事件前加 @
  - demo
    ```html
   <button v-on:click="test1">绑定事件监听 方式1</button>
   <button @click="test1">绑定事件监听缩写 方式2</button>
    <script>
    // 监视 监听 一定有回调函数
    var vm = new Vue({
        methods: {
            test1(event) {
                // 获取到按钮的文本
                console.log(event.target.innerText);
            }
        },
    })
    </script>

   ```
- v-cloak 解决vue插值表达式 闪动问题
  - ` <div id='app' v-cloak></div>  [v-cloak]{display:none}` v-cloak指令 配合  样式
  - 原理：先进行隐藏 等待数据发生变化在进行显示  是给自定义属性添加样式 不是给挂载的元素设置样式
- v-once 只编译一次 响应完一次 就不再具备响应式功能
- v-text 填充纯文本：相比插值表达式更加简洁 不存在闪动问题
- v-html 填充html片段：存在安全问题、本网站内部的数据可以使用，来自第三方的数据不可用
- v-pre 填充原始信息：显示原始信息，跳过编译过程（分析编译过程）
- v-show 条件渲染 显示隐藏
    - v-show 不支持 <teplate></teplate> 元素 也不支持 v-else
- v-if v-else-if v-else 判断是否渲染元素 但凡复合 判断条件 则渲染该元素
  - if判断但凡进入条件 则不在继续判断
  - demo
    ```html
    <div id='app'>
        <p v-if="score>=90"> 优秀</p>
        <p v-else-if="score<90&&score>=60"> 良</p>
        <p v-else="score<60"> 不及格</p>
    </div>
    <script>
        var vm = new Vue({
            el: '#app',
            data: {
                score: 59
            },
            methods: {},
        })
    </script>
  ```
- v-for 循环指令
  - 循环语句中 v-for 必须搭配key 帮助区分不同元素 提高性能  (vue 是虚拟dom)
    - 当循环数组的时候 不要使用 index 下标 而是使用 item.id
    - 当循环对象的时候 使用 index  或item.id 都可以
    ```html
        <div id='app'>
        <ul>
            <!-- 数组 是子项和下标 key值是 子项的id  items-元素 index-下标-->
            <li v-for="(items,index) in arr" :key="items.id">{{items}}--{{index}}</li>
            <!-- 对象是键值对 key值是index  key-键 values-值 index-下标-->
            <li v-for="(key,values,index) in obj" :key="index">{{values}}-{{key}}-{{index}}</li>
        </ul>
    </div>
    <script>
        var vm = new Vue({
            el: '#app',
            data: {
                arr: ['a', 'b', 'c'],
                obj: {
                    a: 'aa',
                    b: 'bb',
                    c: 'cc'
                }
            },
            methods: {},
        })
    </script>
    ```

### 分支v-if else渲染 和 v-show
- v-if  是真正条件上的渲染 但是只有当条件为真的时候 才会开始渲染满足的条件块 进行重排操作
- v-show 不管条件是否满足 元素依然会被渲染 只是简单基于css进行切换 进行重绘操作
- 当一条语句上 两者同时出现 v-if 的优先级更高 因为 当条件不成立不渲染 v-show无法操作
## 实例方法
- vm.$mount  实例方法 手动地挂载一个未挂载的实例
## @keyup 键盘事件 以及自定义
- @keyup.enter 键盘回车触发
- @keyup.delete 键盘退格或delete触发
- 自定义修饰符
  - 可以使用@keyup事件 配合 event.keyCode 获取到键盘的值
  - demo
    ```html
        <div id='app'>
        <input @keyup="code">
        <input @keyup.115="codef4">
        </div>
        <script>
        var vm = new Vue({
            el: '#app',
            data: {},
            methods: {
                code: function () {
                    //获取到键盘值
                    console.log(event.keyCode);
                },
                codef4: function () {
                    console.log('点击了f4');
                }
            },
        })
    </script>
    ```
## class和style样式绑定
### :class
- v-bind:class 数组形式 、对象形式 、 对象与数组混合形式 、 简写形式
  - demo
    ```html
     <div id='app'>
    <p v-bind:class="{active:show}">对象形式</p>
    <button v-on:click='handle'>切换状态</button>
    <p :class="[isActive,isBg]">数组形式</p>
    <p :class="allar">数组形式 简写</p>
    <p :class="objarr">对象形式 简写</p>
     
    </div>
    <script>
        var vm = new Vue({
            el: '#app',
            data: {
                show: true,  //为true 表示添加样式 false 删除样式
                isActive: 'active', //值为 class类名
                isBg: 'bg',
                allar: ['active', 'bg'], //简写数组形式 数组包裹class类名
                objarr: {//简写对象形式 
                    active: true,
                    bg: true
                }
            },
            methods: {
                handle() {
                    this.show = !this.show
                }
            },
        })
    </script>
    ```
### :style 抒写的是行内样式
- demo
  ```html
        <div id='app'>
        <p :style="{color:iscolor,background:isbg}">文字</p>
        <button v-on:click='handle'>切换状态</button>
        <div :style="allobj">style 对象简写</div>
        <div :style="allarr">style 数组简写</div>
         </div>
        <script>
        var vm = new Vue({
            el: '#app',
            data: {
                iscolor: 'red',
                isbg: 'blue',
                allobj: {
                    width: '100px',
                    height: '100px',
                    background: 'lightblue'
                },
                allarr: [{
                    width: '100px',
                    height: '100px',
                    background: 'lightpink'
                }]
            },
            methods: {
                handle() {
                    this.iscolor = 'green'
                }
            },
        })
    </script>
  ```
- show ` <p :class="{active:show}">文字</p>`  控制样式 显示 控制属性名是否存在 在 data数据中可以进行控制为 true或false
## 修饰符
- .prevent 阻止默认事件
- .stop 阻止冒泡
- .capture 捕获
- .once 只触发一次回调
- .self 只当事件是从侦听器绑定的元素本身触发时才触发回调
- .passive 监听滚动事件 立即触发
### 表单修饰符
- .lazy 输入框失去焦点才进行响应 将input事件转换为 change事件
- .number 将输入的值通过 parseFloat 进行转换 
- .trim  去除表单首尾空格
## 自定义指令 Vue.directive
-  全局注册指令 Vue.directive
   -  定义的时候不加 v- 使用时加 命名时单词和单词之间使用 -隔开不要使用驼峰 directive中使用的时有带-的命名 使用''包裹
   -   钩子函数 inserted **一旦渲染在父级中 则立即触发**
       - 被绑定的元素插入父节点时调用 （仅保证父节点存在 但不一定已被插入文档中）  
   -  demo 定义一个自动聚焦输入框的全局指令
    ```js
        Vue.directive('focus', {
            // 当被绑定的元素插入到 DOM 中时……
            inserted: function (el) {
                // 聚焦元素
                el.focus()  // 页面加载完成之后自动让输入框获取到焦点的小功能
            }
        })

         //自定义指令传参
        <input type="text" v-focus="{color:'lightpink'}">
        Vue.directive('focus', {
            // 当被绑定的元素插入到 DOM 中时……
            inserted: function (el, binding) {
                // el 绑定的指定的元素
                // binding  指令名称 不包含 v-
                // value 传入的值
                console.log(el);

                el.style.background = binding.value.color

            }
        })

    ```
- demo （函数形式）自定义一个big指令 使用后 放大当前数字的10倍
  ```js
    <template>
      <div>
        <h1>一个数{{ num }}</h1>
        <h2>放大十倍的num值： <span v-big="num"></span></h2>
        <button @click="num++">点击触发自定义事件</button>
      </div>
    </template>
    <script>
    export default {
      name: "Vue2TestApp",
      data() {
        return {
          num: 0,
        };
      },
      directives: {
        // big函数何时被调用：1.指令与元素成功绑定时 2.指令所在的模板被重新解析时
        // element 为真实dom  binding为对象（得到被绑定元素所有信息） 主要使用其中的value
        big(element, binding) {
          console.log(element, binding);
          console.dir(element);
          // 判断是否是真实DOM
          console.log(element instanceof HTMLElement);
          console.log(binding.value);
          element.innerText = binding.value * 10;
        },
      },
    };
    </script>
  ```
- demo （对象形式）自定义一个fbing指令 使用后 自动对焦输入框并把绑定的数据放大10倍
  ```js
    <template>
      <div>
        <router-view />
        <h1>一个数{{ num }}</h1>
        <input type="text" v-fbing:value="num" />
        <button @click="num++">点击触发自定义事件</button>
      </div>
    </template>

    <script>
    export default {
      name: "Vue2TestApp",
      data() {
        return {
          num: 0,
        };
      },
      directives: {
        // 自定义 fbing指令 实现进入页面input框自动对焦输入框 获取num值
        // 因为 使用函数方法只有两个时机触发调用 导致刚进入页面时 无法获取焦点（具体原因为vue模板元素并没有渲染）
        /*  fbing(element, binding) {
          console.log(element, binding);
          element.value = binding.value;
          element.focus();
        }, */
        fbing: {
          // 指令与元素成功绑定时 触发
          bind(element, binding) {
            console.log("bind");
            element.value = binding.value;
            element.focus();
          },
          // 指令所在元素被插入页面时 触发
          inserted(element) {
            console.log("inserted");
            element.focus();
          },
          // 指令所在模板被重新解析时 触发
          update(element, binding) {
            console.log("update");
            element.value = binding.value * 10;
            element.focus();
          },
        },
      },
    };
    </script>
  ```
## 计算属性 computed
- computed:{} 计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例
    - 根据依赖关系进行缓存的计算，只有在它的相关依赖发生改变时才会进行更新 
- watch:{} 选项|数据  一个对象，键是需要观察的表达式，值是对应回调函数
- vm.$watch(){}实例方法  观察 Vue 实例上的一个表达式或者一个函数计算结果的变化
- 什么时候使用计算属性: 如果要显示的数据可以根据现有的数据产生那就使用计算属性
- demo
   ```html
    // 需求：
    // 1．给p添加一个新的属性: fullName= firstName + '-' + lastName
    // 2．如果修改了firstName/lastName,furllName自动改变为对应的值
    // 3．如果修改了fullName，firstName和lastName也自动改变为对应的值
    <div id="app">
        firstName: <input type="text" v-model="firstName">
        lastName:<input type="text" v-model="lastName">
        fullName1单向绑定:<input type="text" v-model="fullName1">
        fullName2双向绑定:<input type="text" v-model="fullName2">
        fullName3单向绑定watch:<input type="text" v-model="fullName3">
    </div>
    <script>
    var vm = new Vue({
        el: '#app',
        data: {
            //初始化数据
            firstName: 'A',
            lastName: 'B',
            fullName3: 'A-B'
        },
        // 计算属性
        computed: {

            // 简写显示 等同于单独写了getter
            // 初始显示 执行了一次
            // 依赖的数据发生改变 会进行执行
            fullName1() {
                console.log(this);
                return this.firstName + "-" + this.lastName
            },
            fullName2: {
                get() {  //监视依赖数据
                    return this.firstName + "-" + this.lastName;
                },
                set(value) { //监视自身 当自身发生改变的时候 进行后续处理
                    const names = value.split('-')
                    this.firstName = names[0]
                    this.lastName = names[1]
                }
            }

        },
        //   watch方式1 监听firsName
        watch: {
            // 当firsName发生改变的时候执行 并改变 fullname3
            firstName(value) {
                this.fullName3 = value + '-' + this.lastName;
            }
        }
    })

    // watch方式2 首先 声明定义vue模板
    // 当lastName发生改变的时候执行 并改变 fullname3
    vm.$watch('lastName', function (value) {
        this.fullName3 = this.firstName + "-" + value;
    })

    /*
    1.veu控制的所有回调的this都是 vm|组件对象
    2.vue给vm定义一些与data中属性对应的属性  条件 同名

        getter方法 当通过 vm.xxx读取属性值时，读取data对象中同名属性的值
        setter方法 当通过 vm.xxx=value 指定新的值时，值就保存data中对应的属性上
    数据代理 vm.data=xxx ===> vm.xxx 通过vm代理对vm内部的data对象的属性的操作 读|写 
    */
    </script>
   ```
- 计算属性 对于逻辑比较复杂的地方 使用计算属性 使得模板更加的简洁
- demo
  ```html
     <div id='app'>
        <p>{{msg}}</p>
        <p>{{trans}}</p>
    </div>
    <script>
        var vm = new Vue({
            el: '#app',
            data: {
                msg: '你好哇'
            },
            // 事件方法
            methods: {},
            // 触发逻辑上的业务
            computed: {
                trans() {
                    return this.msg.slice(0, 2).split(' ').reverse().join()
                }
            }
        })
    </script>
  ```
### computed计算属性 和 methods方法的区别
  - computed 计算属性 是基于其他的依赖进行缓存的
  - methods 方法 是不存在缓存的
## watch 侦听器
- 监听的数据发生改变 侦听器绑定的方法就会触发 
- 侦听器 适用于数据变化时执行异步或开销（耗时）较大的操作
  - demo 案例1
    ```html
        <div id='app'>
        <p>姓：<input type="text" v-model="fistName"></p>
        <p>名：<input type="text" v-model="lastName"></p>
        <p>{{names}}</p>
        </div>
        <script>
        var vm = new Vue({
            el: '#app',
            data: {
                fistName: '阿姨',
                lastName: '洗铁路',
                names: '阿姨 洗铁路'
            },
            methods: {},
            watch: {
                fistName(v) {
                    this.names = v + " " + this.lastName;
                },
                lastName(v) {
                    this.names = this.fistName + " " + v;
                }
            },
        })
         </script>
    ```
    - demo 案例2  模拟进行后天校验
      ```html
        <div id='app'>
        <p><input type="text" v-model.lazy="userName"> {{msg}}</p>
        </div>
        <script>
        /**
         * 通过v-model 实现数据绑定
         * 需要提供提示信息
         * 需要侦听监听输入信息的变化
         * 需要修改触发的事件     
        */
        var vm = new Vue({
            el: '#app',
            data: {
                userName: '',
                msg: '',
            },
            methods: {
                serverUser(val) {
                    let that = this;
                    setTimeout(function () {
                        if (val == 'admin') {
                            that.msg = '用户名已存在'
                            return;
                        } else {
                            that.msg = '可以使用'
                        }
                    }, 2000)
                }
            },
            watch: {
                userName(val) {
                    this.serverUser(val)
                    this.msg = '后台验证中。。。。。'
                },
            },
        })
        </script>
      ```
## filter 过滤器 
- 将指定的数据进行处理 否则执行原数据
- 将数据进行处理 得到新的数据
- 多个过滤器 后面的会覆盖前面的
### 全局过滤 和局部过滤
- demo
  ```html
  
     <div id='app'>
        <input type="text" v-model='msg'>
        <!-- 将首字母转为小写  lower-->
        <div>{{msg | lower}} </div>
        <!-- 将首字母转为小写 在转换为大写 后面的过滤会覆盖前面的 -->
        <div>{{msg | lower | upper}} </div>
        <!-- 同时也可也作用于其他地方的过滤操作  -->
        <div :class="msg|upper"></div>
     </div>
    <script>
        // 定义一个全局过滤
        Vue.filter('lower', function (val) {
            return val.charAt(0).toLowerCase() + val.slice(1)
        })
        // Vue.filter('upper', function (val) {
        //     return val.charAt(0).toUpperCase() + val.slice(1)
        // })
        // 多个过滤器 后面的会覆盖前面的
        var vm = new Vue({
            el: '#app',
            data: {
                msg: ''
            },
            methods: {},
            //局部过滤
            filters: {
                upper: function (val) {
                    return val.charAt(0).toUpperCase() + val.slice(1)
                }
            }
        })
    </script>
  ```
### 带参数的过滤
- demo
  ```html
    <div id='app'>
        <!-- 渲染指定格式的数据 -->
        <div>{{datatime | time('yyy-mm-dd')}} </div>
    </div>

    <script src='../js/vue.js'></script>
    <script>
        // 将数据进行处理 得到新的数据
        // 定义一个全局过滤
        Vue.filter('time', function (val, text) {
            if (text == 'yyy-mm-dd') {
                var res = ''
                // 将时间拼接为 需要的格式
                res += val.getFullYear() + "-" + (val.getMonth() + 1) + "-" + val.getDate();
            }
            return res
        })
        // 多个过滤器 后面的会覆盖前面的
        var vm = new Vue({
            el: '#app',
            data: {
                msg: '',
                datatime: new Date(), //声明一个时间
            },
            methods: {},
        })
    </script>
  ```
## **生命周期 生命周期钩子 (vue2 总11个)**
### **4个阶段 8个生命周期函数**
- 生命周期执行顺序 init->beforeCreate->created->beformMounted->mounted->init->beforeUpdate->updated->beforeDestroy->destroyed
  - init 为初始化 在 挂载后在init 初始化
- 1.创建   
  - beforeCreate  实例化创建前  (在数据检测 数据代理之前)
  - created        实例化创建后 (在数据检测 数据代理之后)
- 2.挂载
  - beforeMount   模板、节点 挂载前
  - mounted       模板、节点 挂载完成
- 3.更新
  - beforeUpdate  （元素/组件的变更操作） 箭头data中数据 发生改变前
  - updated        元素/组件的变更操作） 箭头data中数据 发生改变后
- 4.销毁 在这个阶段可以访问数据 等 但无法改变数据
  - beforeDestroy 销毁相关的属性前
  - destroyed     销毁相关的属性后
- demo
  ```html
       <div id='app'>
        <p>{{msg}}</p>
        <!-- 使用input 双向绑定 修改值 触发变更 -->
        <input type="text" v-model="msg">
        <button @click="destroy">销毁</button>
    </div>
    <script src='../js/vue.js'></script>
    <script>
        var vm = new Vue({
            el: '#app',
            data: {
                msg: 'abc'
            },
            methods: {
                // 销毁当前vue实例
                destroy: function () {
                    this.$destroy();
                }
            },
            beforeCreate: function () {
                console.log('beforeCreate 实例化创建前触发');
            },
            created: function () {
                console.log('created 实例化创建后触发');
            },
            beforeMount: function () {
                console.log('beforeMount 挂载前触发');
            },
            mounted: function () {
                console.log('mounted 挂载完成触发');
            },
            beforeUpdate: function () {
                console.log('beforeUpdate 变更前触发');
            },
            updated: function () {
                console.log('updated 变更后触发');
            },
            beforeDestroy: function () {
                console.log('beforeDestroy 销毁前触发');
            },
            destroyed: function () {
                console.log('destroyed 销毁后触发');
            },
        })
        </script>
  ``` 
- vm.$destroy() 完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器
### 其他vue2 生命周期钩子 3个
- activated 被 keep-alive 缓存的组件激活时调用 该钩子在服务器端渲染期间不被调用
- deactivated 被 keep-alive 缓存的组件失活时调用 该钩子在服务器端渲染期间不被调用
- errorCaptured 在捕获一个来自后代组件的错误时被调用（vue2.5新增）
## 数据变更方法
- push()
- pop()
- shift()
- unshift()
- splice()
- sort()
- reverse()
- 不会改变原有数组的方法
  - filter、concat、slice、map、join、forEach、find、findIndex、isArray、includes、indexOf、concat
### 修改响应式数据方法
- 参数1 数组名或对象  参数2 要处理的数组的下标或对象名 参数3 新的数组值或对象值
- Vue.set(vm.arr, 0, 10)
- vm.$set(vm.arr, 1, 8)
- demo
  ```html
     <div id='app'>
        <input type="text" v-model="cont">
        <div v-for="item in arr" :key="item.id">{{item}}</div>
        <button @click="add">尾部添加</button>
        <button @click="remo">尾部删除</button>
        <button @click="slice">尾部删除一项 slice</button>
        <div v-for="item in obj" :key="item.id">{{item}}</div>
    </div>
    <script>
        var vm = new Vue({
            el: '#app',
            data: {
                cont: '',
                arr: [1, 2, 3],
                obj: {
                    a: '苹果',
                    b: '榴莲',
                    c: '香蕉',
                }
            },
            methods: {
                remo() {
                    this.arr.pop();//尾部删除
                },
                add() {
                    this.arr.push(this.cont)//尾部添加
                },
                slice() {
                    this.arr = this.arr.slice(0, 2) //尾部删除一项
                },
            },
        })
        // 通过索引去改变值
        Vue.set(vm.arr, 0, '改变的数据1')
        vm.$set(vm.arr, 1, '改变的数据2')

        // 拖过键名去改变值
        Vue.set(vm.obj, 'a', '西红柿')
        vm.$set(vm.obj, 'b', '西红柿')

        vm.obj.d = '黄瓜'; //直接添加
  ```

## **组件  Vue.component**
- 注册全局组件语法：
   ```js
        Vue.component('组件名称', {
            data: 组件数据,
            template: 组件模板内容
        })
   ```
### 组件的使用全局注册组件
- 组件里面的data数据集 必须是函数形式 里面的数据 必须通过返回值返回
- 组件使用的数据和方法 是组件自身存在的 不是使用 vue实例里面的
- 每个子组件之间是相互独立的数据
- **组件模板内容必须是单个根元素** 可以是嵌套关系但不能是同级
- demo
  ```html
    <div id='app'>
        <button-btn></button-btn>
        <button-btn></button-btn>
        <button-btn></button-btn>
    </div>
    <script>
      
        Vue.component('button-btn', {
            data() { //data 必须是函数
                return { con: 0 };
            },
            // 组件模板内容必须是单个根元素 可以是嵌套关系但不能是同级
            // template: '<button @click="con++">点击次数：{{con}}</button>', 
            // template: '<button @click="jiajia">点击次数：{{con}}</button>',
            template: `
            <div>
                <button @click="jiajia">点击次数：{{con}}</button>
                <button >使用模板字符串</button>
            </div>`,
            methods: {
                jiajia() {
                    this.con += 2
                }
            }
        })
        var vm = new Vue({
            el: '#app',
            data: {},
            methods: {},
        })
    </script>
  ```
### 组件命名规范
-  组件的命名方式  使用短横线 hello-world  和 驼峰命名方式 
   - 如果使用了 驼峰命名 helloWorld  在使用该组件的时候 只在字符串模板中有效 但在普通标签中（渲染该元素）无效 
   - 但可以进行修改 将大写全改为小写 单词之间使用横杠连接 hello-world
   - 在其他组件中的字符模板中不受影响 可以直接使用驼峰
-  **根本原因是因为 html对大小写字母不敏感 不会进行区分 所以要将驼峰改为短横线命名方式** 
- demo
  ```html
      <div id='app'>
        <my-jerry></my-jerry> 
        <!-- 输出  my is Jerry-->
        <my-tom></my-tom>
        <!-- 输出 my is Tom my is Jerry-->
    </div>
    <script>
    Vue.component('myJerry', { //组件1
            data() { 
                return { con: 'my is Jerry' };
            },
            template: ` <div> {{con}}  </div>`,
        })

        Vue.component('myTom', {//组件2
            data() { 
                return { con: 'my is Tom' };
            },
            template: ` <div> 
                {{con}}  
                <myJerry></myJerry> //使用组件1
                </div>`,
        })
        var vm = new Vue({
            el: '#app',
            data: {},
            methods: {},
        })
    </script>
  ```
### 局部组件的注册  components:{} 复数加s
- 局部组件可以调用全局组件 全局无法调用局部 
- 外层定义模板 实例定义组件
- 局部组件只能在 注册他的父级组件中 进行调用
- 如果局部组件在全局组件中定义 才可以在全局组件中使用
- demo
  ```html
    <div id='app'>
        全局组件
        <button-btn></button-btn>
        局部组件
        <hello-world></hello-world>
    </div>
    <script>
        //创建一个局部组件的模板
        let helloWorld = {
            data() {
                return {
                    con: '一条语句 helloWorld'
                }
            }, template: `<div>{{con}}
                <buttonBtn></buttonBtn> //调用了全局组件
                </div>`,
        }
        Vue.component('buttonBtn', {
            data() {
                return { con: 0 }
            },
            template: `
           <div>
            <button @click='con++'>点击次数：{{con}}</button>
            <button @click='double'>点击次数+2：{{con}}</button>
            </div>
            `,
            methods: {
                double() {
                    this.con += 2
                }
            },
        })
        var vm = new Vue({
            el: '#app',
            data: {},
            methods: {},
            // 局部组件
            components: {
                'helloWorld': helloWorld, //引入局部组件
            }
        })
    </script>
  ```
### 组件间的传值 父传子 子传父
#### 父组件向子组件传值 props
- 父组件向 子组件传递参数 使用 props[] 接收传值
- 父组件中的data的属性名称必须跟子组件间传入的属性值对应
- props接收的参数是只读的 如果需要将数据进行改变 应该复制一层到data中在进行处理
- props 命名规范
- 子组件中的props中的属性是数组形式，可以接受父组件传入的多个值
  - 在props中使用驼峰形式，模板中需要使用短横线的形式 否则会产生警告提示
  - 在字符串模板中 没有这个限制 （在其他组件中可以使用驼峰）
  - 规范写法就是 key:'value' 当想传入的为Number类型时记得添加v-bind或简写: 否则传入的为字符串
- props 传递类型可以是 string number boolen array object
- demo
  ```html
     <div id='app'>
        <!-- :num="222" 不加冒号 :也就是不使用 v-bind： 数据类型为 string  纯数字使用时为 number类型  -->
        <hello-tom str="字符串类型" :num="222" :trfa="true" :arrs="arrs" :objs="objs" :my-tom='myTom'></hello-tom>
    </div>
    <script>
        Vue.component('hello-tom', {
            props: ['str', 'num', 'trfa', 'arrs', 'objs','myTom'],
            data() {
                return {
                    msg: 'hello-tom'
                };
            },
            template: `
            <div>  
                <div>{{str}}</div>
                <div>{{typeof num}}</div>
                <div>{{ trfa}}</div>
                <ul>
                <li :key='index' v-for='(item,index) in arrs'>{{item}}</li>
                 </ul>
                 <div>{{objs.a}}</div>
                 <div>{{objs.b}}</div>
                 <div>{{myTom}}</div>
                
            </div>`,


        })

        var vm = new Vue({
            el: '#app',
            data: {
                ms: 'ms 动态父组件数据',
                arrs: ['one', 'two', 'therr'],
                objs: {
                    a: '张三',
                    b: '李四',
                    c: '王五',
                },
                myTom:'是个人才',
            },
            methods: {},
        })
  ```
- demo props接收的三种方式
  ```js
    // 简单接收
  // props: ["names", "age", "city"],

  // 对象接收 进行规定接收参数的类型
  // props: {
  //   names: String,
  //   age: Number,
  //   city: String,
  // },

  // 接收的同时对数据 进行类型限制 默认值指定 必要性限制
  props: {
    names: {
      type: String, //names的类型必须字符串
      required: true, //names是必要的
    },
    age: {
      type: Number, //age的类型必须数字
      default: 99, //当不传入的时候 使用默认值
    },
    city: {
      type: String,
      required: true,
    },
  },
  ```
#### 子组件向父组件传值 $emit()
-  通过自定义事件 向 父组件进行传值  $emit() 方法
- 父组件需要监听子组件的事件
#### 带参传递
- 子组件自定义方法中 可以传入多个参数
- 父组件监听的方法 通过$event 进行获取
- demo
  ```html
    <div id='app'>
        全局组件
        <button-btn :arr="arr" @chichichi="chichichi($event)"></button-btn>
    </div>
    <script>
        Vue.component('buttonBtn', {
            props: ['arr'],
            template: `
           <div>
           <ul>
            <li v-for='(item,index) in arr' :key='index'>{{item}}</li>
            </ul>
           <button @click='add'>按钮1</button>
           <button @click='arr.push("糖醋排骨")'>按钮2</button>
           <button @click='$emit("chichichi","就知道吃")'>按钮3</button> </div>`,
            methods: {
                add() {
                    this.arr.push('糖醋里脊')
                }
            },
        })
        var vm = new Vue({
            el: '#app',
            data: {
                abc: '父组件传递的数据',
                myJerry: 'my is jerry',
                arr: ['one', 'two', 'three'],
                myTom: {
                    names: 'tom',
                    age: 18
                }
            },
            methods: {
                chichichi(val) {
                    this.arr.push('红烧鱼')
                    console.log(val);
                }
            },
        })
    </script>
  ```
### 非父子组件传值
- 单独的事件中心管理组件间的通信   var eventHub=new Vue()
- 监听事件 和销毁事件
  - 监听事件 eventHub.$on()
  - 销毁事件 eventHub.$off()
- demo 兄弟组件间的传递
  ```html
    <div id='app'>
        <button @click="deljerry">销毁事件 销毁jerry</button>
        <button @click="deljadd">全部销毁</button>
        <hello-tom></hello-tom>
        <hello-jerry></hello-jerry>

    </div>
    <script>
        // 创建一个事件管理中心
        let hub = new Vue();
        // 子组件1
        Vue.component('hello-tom', {
            data() {
                return { num: 0 }
            },
            template: `
            <div>  
                <div>{{num}}</div>
                 <button @click='handle'>给兄弟组件jerry传值</button>
            </div>`,
            methods: {
                handle() {
                    // 通过事件中心触发 组件二中的数据
                    hub.$emit('event-jerry', 1)
                }
            },
            // 模板节点挂载完成 
            mounted() { //生命周期
                // 监听事件 自定义监听事件名 event-tom
                hub.$on('event-tom', (val) => {
                    this.num += val;
                })
            },
        })
        // 子组件2
        Vue.component('hello-jerry', {
            data() {
                return { num: 0 }
            },
            template: `
            <div>  
                <div>{{num}}</div>
                 <button @click='handle'>给兄弟组件tom传值</button>
            </div>`,
            methods: {
                handle() {
                    hub.$emit('event-tom', 2)
                }
            },
            // 模板节点挂载完成 
            mounted() { //生命周期
                // 监听事件 自定义监听事件名 event-tom
                hub.$on('event-jerry', (val) => {
                    this.num += val;
                })
            },
        })
        var vm = new Vue({
            el: '#app',
            data: {
                msg: '父组件中的内容',
                fontSize: 10,
            },
            methods: {
                deljerry() {
                    hub.$off('event-jerry')
                },
                deljadd() {
                    hub.$off('event-jerry')
                    hub.$off('event-tom')
                },
            },
        })
    </script>
  ```
## 插槽
- 作用域插槽和单个插槽和具名插槽的区别：
  - 因为单个插槽和具名插槽不绑定数据，所以父组件是提供的模板要既包括样式又包括内容的。而作用域插槽，父组件只需要提供一套样式
### 组件插槽 (默认插槽)
- `<slot></slot>` 是固定的 用于命名插槽
- 父组件向子组件传递内容
- 当父组件没有填入数据的时候 自动使用默认数据填充 （在有设置默认的情况下）
- demo
  ```html
    //父组件
    <template>
    <Son><p>父组件传递给子组件slot的值</p></Son>
    </template>

    //子组件
     <template>
     <slot>子组件中slot的默认值</slot>
    </template>
  ```
### 具名插槽 (命名插槽)
- `<slot></slot>`
- 通过给模板设置 slot 类名来区分 板块
- 在父组件中 带有相匹配的slot值 会被渲染到指定结构中
- demo
  ```html
   父组件中：
   <Category>
       <template slot="center">
         <div>html结构1</div>
       </template>

       <template v-slot:footer>
          <div>html结构2</div>
       </template>
   </Category>
   子组件中：
   <template>
       <div>
          <!-- 定义插槽 -->
          <slot name="center">插槽默认内容...</slot>
          <slot name="footer">插槽默认内容...</slot>
       </div>
   </template>
  ```
### 作用域插槽
- 作用域插槽其实就是带数据的插槽，即带参数的插槽，
- 简单的来说就是子组件提供给父组件的参数，该参数仅限于插槽中使用，
- 父组件可根据子组件传过来的插槽数据来进行不同的方式展现和填充插槽内容。
- demo
  ```html
     <div id='app'>
        <!-- id 为1 的改变了字体颜色并且使用strong标签渲染  其余的不符合条件使用了a元素渲染 -->
        <!-- slot-scope 获取到子组件的值  -->
        <list :lists="lists">
            <!-- <template slot-scope="aaa"> -->
            <template v-slot:default="aaa">
                <strong v-if="aaa.info.id==1" :style="{color:'lightblue'}">{{aaa.info.name}}</strong>
                <a href="" v-else>{{aaa.info.name}}</a>
            </template>
        </list>
    </div>

    <script src='../js/vue.js'></script>
    <script>
        // slot-scope 在2.6，0版本已经废弃 可以使用 v-slot:default 插槽名 (可选，默认值是 default)
        // 作用域插槽 场景 父组件对子组件的内容进行加工处理
        Vue.component('list', {
            props: ['lists'],
            template: `
            
            <ul>
             <li v-for='item in lists' :key="item.id">
            <slot :info='item'>{{item.name}}</slot>    
            </li>    
            </ul>
            `
        })
        var vm = new Vue({
            el: '#app',
            data: {
                lists: [
                    {
                        id: 0,
                        name: '张三'
                    },
                    {
                        id: 1,
                        name: '李四'
                    },
                    {
                        id: 2,
                        name: '王五'
                    },
                ]
            },
            methods: {},
        })
    </script>
  ```

## ref 属性
1. 被用来给元素或子组件注册引用信息（id的替代者）
2. 应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）
3. 使用方式：
   1. 语法打标识 普通标签<p ref="tagP">一些文字</p>  组件<Son ref="son" />   
   2. 获取：this.$refs.xxx
## 混入 mixin
1. 功能：可以把多个组件共用的配置提取成一个混入对象（类似于封装 提高复用性）
2. 使用方式：
   第一步定义混合：
       {
           data(){....},
           methods:{....}
           ....
       }
   第二步使用混入：
   使用前需要调用文件
  全局混入：Vue.mixin(xxx)
	局部混入：mixins:['xxx']
- 注意事项
  - 如果引入的混入与当前组件发生数据冲突 当前组件的优先级更高
  - 相同的类型 以当前组件数据为主 没有的数据则进行引入

## nextTick
- 语法：this.$nextTick(回调函数)
- 作用：在下一次 DOM 更新结束后执行其指定的回调。
- 什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行

## 基于promise的ajax
- demo
  ```js
        function promiseAjax(url) {
        let pm = new Promise((res, rej) => {
            let xhr = new XMLHttpRequest();
            xhr.onreadystatechange = () => {
                if (xhr.readyState != 4) return; //当状态不等于4的时候 直接退出 
                if (xhr.readyState == 4 && xhr.status == 200) {
                    // 处理正常的情况
                    res(xhr.responseText)
                } else {
                    // 处理异常情况
                    rej('服务器错误！')
                }
            }
            xhr.open('get', url);
            xhr.send();
        })
        return pm;
    }
    promiseAjax('http://localhost:3000/database1')
        .then(function (data) {
            console.log(data);
        }, function (info) {
            console.log(info);
        })
  ```
### 基于promise发送多次ajax
- demo
  ```js
         // 发送多个ajax请求 并保证请求的顺序
    promiseAjax('http://localhost:3000/database')
        .then(function (data) {
            console.log(data);
            // return 的是一个新的Promise实例对象
            // 下一个then的调用者就是上一个then return的promise实例对象
            // data 接收的是上一个异步任务处理完的结果
            return promiseAjax('http://localhost:3000/database1');
        }).then((data) => {
            console.log(data);
            return promiseAjax('http://localhost:3000/database2');
        }).then((data) => {
            console.log(data);
        })
  ```
### 使用Promise对象方法
- demo
  ```js
    // Promise.all() 并发处理多个异步任务，所有任务都执行完成才能得到结果
    // Promise.race() 并发处理多个异步任务， 只要有一个任务执行完成就能得到结果
    let p1 = promiseAjax('http://localhost:3000/a1');
    let p2 = promiseAjax('http://localhost:3000/a2');
    let p3 = promiseAjax('http://localhost:3000/a3');
    let all = Promise.all([p1, p2, p3]).then((data) => {
        console.log(data);
    })
    let ra = Promise.race([p1, p2, p3]).then((data) => {
        console.log(data);
    })
  ```
## 接口调用 fetch 方法
- text() 方法属于 fetch api的一部分 它返回一个Promise实例对象 用于获取后台返回的数据
- json() 方法 接收 JSON格式的数据
- demo 基本用法get
  ```js
   // 默认是发丝get请求
    // 方式1传参方式 传统url
    fetch('http://localhost:3000/fetch2?id=123', {
        method: 'get' //发送请求类型 get post put  delete
    }).then((data) => {
        // text() 方法属于 fetch api的一部分 它返回一个Promise实例对象 用于获取后台返回的数据
        console.log(data);
        return data.text();
    }).then(data => {
        console.log(data);
    })
    // 方式2 需要服务器端设置 接收方式
    /*
    app.get('/fetch3:id', (req, res) => {
    res.send('fetch3 Restful形式的url传递参数 id=' + req.params.id)
        })
    **/
    fetch('http://localhost:3000/fetch3:456', {
        method: 'get' //发送请求类型 get post put  delete
    }).then((data) => {
        // text() 方法属于 fetch api的一部分 它返回一个Promise实例对象 用于获取后台返回的数据
        return data.text();
    }).then(data => {
        console.log(data);
    })
    //接收数据格式
    /* 服务器设置返回数据格式为json app.get('/fetch5', (req, res) => {res.json({name: '张三',sex: '男',age: 18,})})*/
    fetch('http://localhost:3000/fetch5').then((data) => {
    // return data.text();
    return data.json();
    }).then(data => {
        // let jo = JSON.parse(data) //当使用text() 接收返回值的时候为字符串格式 转换为JSON格式
        // console.log(jo);
        console.log(data);
    })
  ```
- demo post请求方式
  ```js
     fetch('http://localhost:3000/fetch4', {
         method: 'post', //发送请求类型 get post put  delete
         body: 'name=张三&age=18',
         headers: {
             'Content-Type': 'application/x-www-form-urlencoded'
         }
     }).then((data) => {
         // text() 方法属于 fetch api的一部分 它返回一个Promise实例对象 用于获取后台返回的数据
         return data.text();
     }).then(data => {
         console.log(data);
     })


    // json 格式 需要改变body 传递方式  和 请求头 改为json

    // 使用JSON时候的报错 Uncaught (in promise) TypeError: Failed to fetch
    // 服务器解决跨域问题 res.header("Access-Control-Allow-Headers", "X-Requested-With,Content-Type,mytoken");
    fetch('http://localhost:3000/fetch4', {
        method: 'post', //发送请求类型 get post put  delete
        body: JSON.stringify({
            name: '李四',
            age: '19',
        }),
        headers: {
            'Content-Type': 'application/json'
        }
    }).then((data) => {
        // text() 方法属于 fetch api的一部分 它返回一个Promise实例对象 用于获取后台返回的数据
        return data.text();
    }).then(data => {
        console.log(data);
    })
  ```
## 接口调用 axios 方法
- demo
  ```js
    //基础使用方法
        axios.get('http://localhost:3000/axios1')
        .then(res => {
            // 注意data属性是固定的用法 用于获取后台的实际数据
            console.log(res.data)
        })
        .catch(err => {
            console.error(err);
        })
        //通过 params 传参
        axios.get('http://localhost:3000/axios2', {
        params: {
            id: 789,
        }
        })
        .then(res => {
            // 注意data属性是固定的用法 用于获取后台的实际数据
            console.log(res.data)
        })
        .catch(err => {
            console.error(err);
        })
    //  传统url传参
    axios.get('http://localhost:3000/axios2?id=123')
        .then(res => {
            console.log(res.data)
        })
        .catch(err => {
            console.error(err);
        })
        // 后台使用 restful 接收参
        /** 后台 app.get('/axios3:id', (req, res) => { res.send('hello axios id=' + req.params.id)})*/
     axios.get('http://localhost:3000/axios3:789')
         .then(res => {
             console.log(res.data)
         })
         .catch(err => {
             console.error(err);
         })
           //  post
        axios.post('http://localhost:3000/axios4', {
            names: '张三',
            age: 18,
        })
            .then(res => {
                // 注意data属性是固定的用法 用于获取后台的实际数据
                console.log(res.data)
            })
            .catch(err => {
                console.error(err);
            })
         // 通过 URlSearchParams 传递参数  (application/x-www-form-urlencoded)格式
        const params = new URLSearchParams();
        params.append('names', '李四')
        params.append('age', 18)
        axios.post('http://localhost:3000/axios4', params)
        .then(res => {
            console.log(res.data)
        })
        .catch(err => {
            console.error(err);
        })

  ```
### axios 配置
- 配置请求的基准url地址
  - ` axios.defaults.baseURL = 'http://localhost:3000/';`
    - 调用的时候  `axios.get('axios5')` 省略前缀
- 设置请求头 `axios.defaults.headers['mytoken'] = 'hello world' //设置请求头`
- 设置响应超时时间 `axios.defaults.timeout=200;`
### 拦截器
- 请求拦截 在请求发出之前设置一些信息
  - demo
    ```js
            axios.interceptors.request.use(config => {
            // 在请求发出之前进行一些信息的设置
            return config;
        }, error => {
            // 处理响应错误的信息
            return Promise.reject(error);
        });
    
        axios.get('http://localhost:3000/axios5')
            .then(res => {
                console.log(res.data)
                console.log(res.data.names)
            })
            .catch(err => {
                console.error(err);
            })
    ```
- 响应拦截 在获取数据之前对数据做一些加工处理
  - demo
    ```js
        axios.interceptors.response.use(res => {
        // 在这里对返回的数据进行处理
        var data = res.data;
        return data; //直接返回data数据 
    }, error => {
        // 处理响应错误的信息
        return Promise.reject(error);
    });
    axios.get('http://localhost:3000/axios5')
        .then(data => {
            // 经过拦截器处理后 可以直接使用data获取数据 不用res.
            console.log(data)
            console.log(data.names)
        })
        .catch(err => {
            console.error(err);
        })
    ```
### async和await
- async 关键字用于函数上 async函数的返回值是promise 实例对象
- await 关键字用于async函数当中 await可以得到异步的结果
- demo
  ```js
    //基础用法
    axios.defaults.baseURL = 'http://localhost:3000/'
    async function tests() {
        let ret = await axios.get('axios5')
        return ret.data
        // console.log(ret.data.names);
    }
    tests().then(ret => {
        console.log(ret.names);
    })

    //async和await多个异步任务处理方式
    axios.defaults.baseURL = 'http://localhost:3000/'
    async function tests() {
        let async1 = await axios.get('async1');
        let async2 = await axios.get('async2?async1=' + async1.data); //将接口返回的值 在传给接口二进行处理
        return async2.data
        // console.log(ret.data.names);
    }
    tests().then(data => {
        console.log(data);
    })
  ```
### 关于响应
- data 实际响应回来的数据
- headers 响应头信息
- status 响应状态码
- statusText 响应状态信息
## promise封装 axios
- demo 举例 
  ```js
  //需求：获取到第一个axios 中回调的数据 在发送请求
       function get(url, data) {
            return new Promise(() => {
                axios.get(url, {
                    prompt: data,
                    headers: {}
                })
            })
        }
        get('url1', { a: 123 })
            .then(res => {
                return get('url2', { a: res.data })
            })
            .then()
        get(url值,data数据)


  ```
## promise封装 async
- demo 举例
  ```js
        //需求：获取到第一个axios 中回调的数据 在发送请求
        async function as(url, data) {
            let res = await axios.get(url, data);
            let req = await axios.get('url2', res);
            return req;
        }
        as(url,data)

  ```


## Vue-Router 的使用
### 模拟前端路由
- SPA (Single Page Application)
  - 后端路由（接口 性能问题）
  - 前端路由 (解决前端页面渲染性能问题)
  - 前端路由的核心
    - 基于URL地址的hash (hash的变化会导致浏览器记录访问历史的变化、
        但是hash的变化不会触发新的URL请求)在实现SPA过程中，最核心的技术点就是前端路由
- :is 属性指定的组件名称 把对应的组件渲染到 component 标签所在位置
- <component></component>  标签可以当做是组件的占位符
-  window.onhashchange  当 一个窗口的 hash （URL 中 # 后面的部分）改变时就会触发 hashchange 事件
-  window.location.hash   获取到最新的hash值
- demo 模拟前端路由的切换效果
  ```html
    <div id='app'>
        <!-- 切换组件的超链接 -->
        <a href="#one">ONE</a>
        <a href="#two">TWO</a>
        <a href="#three">THERR</a>
        <a href="#four">FOUR</a>
        <component :is="Page"> </component>
    </div>
    <script>
        // 组件
        const one = {
            template: '<h1>页面1</h1>'
        }
        const two = {
            template: '<h1>页面2</h1>'
        }
        const three = {
            template: '<h1>页面3</h1>'
        }
        const four = {
            template: '<h1>页面4</h1>'
        }
        var vm = new Vue({
            el: '#app',
            data: { Page: 'one' },
            components: { //注册私有组件
                one,two,three,four
            }
        })
        // 监听window 的 onhashchange  事件 根据获取到的最新的 hash 值 切换要显示的组件名称
        window.onhashchange = function () {
            // 通过location.hash 获取到最新的hash值
            console.log(location.hash);
            //判断当前 url更换 hash值（#xxx） 进行匹配 
            switch (window.location.hash) {
                case '#one': vm.Page = 'one'
                    break;
                case '#two': vm.Page = 'two'
                    break;
                case '#three': vm.Page = 'three'
                    break;
                case '#four': vm.Page = 'four'
                    break;
            }
        }
  ```
### vue-Router vue路由 的使用
- 需要引入 vue-router.js 和vue.js文件 进行使用
- <router-link></router-link> 是vue 中提供的标签 默认会被渲染为a标签
- <router-link to="/one">ONE</router-link> to 属性默认被渲染为href属性
  - to属性的值默认会被 渲染为 以 # 开头的 hash 地址
- <router-view></router-view> 路由占位符 (路由填充位) 通过路由规则匹配到的组件 将会被渲染到 router-view 所在的位置
- `const router = new VueRouter({})` 创建路由实例对象
  - 每个路由规则都是一个配置对象 其中至少包括 path 和 component 两个属性
  - routes 路由规则数组
    - path 表示当前路由 匹配的 hash 地址
    - component 表示当前路由规则对应要展示的组件 
- demo 
  ```html
    <div id='app'>
        <router-link to="/one">ONE</router-link>
        <router-link to="/two">TWO</router-link>
        <router-view></router-view>
    </div>
    <script>
        // 组件
        const One = {
            template: '<h1>页面1</h1>'
        }
        const Two = {
            template: '<h1>页面2</h1>'
        }
        // 创建路由实例对象
        const router = new VueRouter({
            routes: [//routes路由规则数组
                //路由匹配的hash地址  展示的组件
                { path: '/one', component: One },
                { path: '/two', component: Two }
            ],
        })
        var vm = new Vue({
            el: '#app',
            //  为了能够让路由规则生效 必须把路由对象挂载到vue实例对象上
            //router: router,//将路由挂载到vue根实例中
            router, //简写 键值同名
        })
    </script>
  ```
### vue-Router 重定向
- 重定向(Redirect)就是通过各种方法将各种网络请求重新定个方向转到其它位置
- redirect 属性 指定一个新的路由地址 键值对形式 redirect:'/xxx'
- demo
  ```js
    const router = new VueRouter({
        routes: [//routes路由规则数组
            // path 当原地址为 /  使用 redirect 重定向为 /one 地址
            // redirect 属性 指定一个新的路由地址
            { path: '/', redirect: '/one' },
            { path: '/one', component: One },
        ]
    })
  ```
### 路由的嵌套
- children 属性 添加子路由规则 children:[{path:},{}]
- demo
  ```html
    <div id='app'>
        <router-link to="/one">ONE</router-link>
        <router-link to="/two">TWO</router-link>
        <router-view></router-view>
    </div>
    <script>
        // 组件
        const One = {
            template: '<h1>页面1</h1>'
        }
        const Two = {
            template: `
            <div>
                <h1>页面2</h1>
                <!-- 子路由-->
                <router-link to="/two/tab1">tab1</router-link>
                <router-link to="/two/tab2">tab2</router-link>
                <router-view></router-view>    
            </div> `
        }
        //需要插入的子组件
        const TwoTab1 = {
            template: '<h3>子组件1</h3>'
        }
        const TwoTab2 = {
            template: '<h3>子组件2</h3>'
        }
        // 创建路由实例对象
        const router = new VueRouter({
            routes: [//routes路由规则数组
                { path: '/', redirect: '/one' },
                { path: '/one', component: One },
                {
                    path: '/two', component: Two,
                    children: [
                        // 通过 属性 children 添加子路由规则
                        { path: '/two', redirect: '/two/tab1' },
                        { path: '/two/tab1', component: TwoTab1 },
                        { path: '/two/tab2', component: TwoTab2 },
                    ]
                },
            ]
        })
        var vm = new Vue({
            el: '#app',
            router: router,//将路由挂载到vue根实例中
        })
    </script>
  ```
### 动态路由
- 动态的路径参数 以冒号开头 :xxx   
- demo
  ```html
    <div id='app'>
        <router-link to="/one/a">ONE1</router-link>
        <router-link to="/one/b">ONE2</router-link>
        <router-link to="/one/c">ONE3</router-link>
        <router-link to="/one/d">ONE4</router-link>
        <router-link to="/two">TWO</router-link>
        <router-view></router-view>
    </div>
    <script>
        // 组件
        const One = {
            // 在 VueRouter 实例外 使用 route 前面要加 $
            // $route.params.id 获取路由参数
            template: '<h1>页面1 里面的第{{$route.params.abc}} 个</h1>'
        }
        const Two = {
            template: '<h1>页面2</h1>'
        }
        // 创建路由实例对象
        const router = new VueRouter({
            routes: [
                //动态的路径参数 以冒号开头 :xxx  不是固定的 
                { path: '/one/:abc', component: One },
                { path: '/two', component: Two }
            ]
        })
        var vm = new Vue({
            el: '#app',
            router,
        })
    </script>
  ```
### 通过路由组件传参
- props 的值为布尔类型  props:true/false 设置为true时 route.params 将会被设置为组件属性
  - 在组件中同样使用 props:['xxx'] 接收 路由参数（路由通过props 传参 组件通过 props接收参数）
- 传参形式 
  - props 为布尔形式
  - props 值为对象形式  **为对象形式的时候 动态路由的 hash路径值获取不到**
  - props 值为函数形式
- demo
  ```html
    <div id='app'>
        <router-link to="/one/1">ONE1</router-link>
        <router-link to="/one/2">ONE2</router-link>
        <router-link to="/one/3">ONE3</router-link>
        <router-link to="/one/4">ONE4</router-link>
        <router-link to="/two">TWO</router-link>
        <router-view></router-view>
    </div>
    <script>
        // 组件
        const One = {
            props: ['id', 'name', 'age'], //接收路由传递过来的参数
            //使用{{xxx}} 渲染数据 当props为true 时 获取动态的参数 就不使用 $route.params.id 直接使用{{id}}
            // template: '<h1>页面1 里面的第{{$route.params.id}} 个</h1>'
            template: '<h1>页面1 里面的第{{id}} 个 --{{name}}--{{age}}</h1>' 
        }
        const Two = {
            template: '<h1>页面2</h1>'
        }
        // 创建路由实例对象
        const router = new VueRouter({
            routes: [
            { path: '/', redirect: '/one/1' },
        // { path: '/one/:id', component: One, props: true },//传参形式1 props为布尔时
        // { path: '/one/:id', component: One, props: { name: '张三', age: 18 } },//传参形式2 props为对象
                {//传参形式3 函数类型 props是一个函数 这个函数接收 route 对象为自己的形参
                    path: '/one/:id', component: One,
                    //将动态参数对象和静态参数结合使用
                    props: route => ({ name: '张三', age: 18, id: route.params.id })
                },
                { path: '/two', component: Two }
            ]
        })

        var vm = new Vue({
            el: '#app',
            data: {},


            methods: {},
            //  为了能够让路由规则生效 必须把路由对象挂载到vue实例对象上
            router: router,//将路由挂载到vue根实例中
        })
    </script>
  ```
### 命名路由
- 命名路由就是为了更加方便的表示路由的路径 给路由规则起一个别名 
- demo
  ```html
        <div id='app'>
        <router-link to="/one/1">ONE1</router-link>
        <router-link to="/one/2">ONE2</router-link>
        <router-link :to="{name:'four',params:{id:3}}">ONE3</router-link>
        <!-- name 路由名称  params路由需要携带的参数-->
        <router-link to="/two">TWO</router-link>
        <router-view></router-view>
    </div>
    <script>
        // 组件
        const One = {
            props: ['id', 'name', 'age'],
            // template: '<h1>页面1 里面的第{{$route.params.id}} 个</h1>'
            template: '<h1>页面1 里面的第{{id}} 个 --{{name}}--{{age}}</h1>'
        }
        const Two = {
            template: '<h1>页面2</h1>'
        }
        // 创建路由实例对象
        const router = new VueRouter({
            routes: [
                { path: '/', redirect: '/one/1' },
                {
                    name: 'four',
                    path: '/one/:id', component: One,
                    props: route => ({ name: '张三', age: 18, id: route.params.id })
                },
                { path: '/two', component: Two },
            ]
        })
        var vm = new Vue({
            el: '#app',
            router
        })
    </script>
  ```
### 横跨历史 （页面的前进后退）
- this.$router.push('/xxx') 跳转到指定的url路径
- this.$router.go(n) 向前或者向后跳转n个页面,  n 可以为正整数也可以为负整数
- this.$router.replace() 跳转到指定的url 路径, 但是history 栈中不会有记录, 点击返回就会跳转到上上个页面, (就是直接替换了当前的页面)
   
- demo
  ```html
          <div id='app'>
        <router-link to="/one">ONE1</router-link>
        <router-link to="/two">TWO</router-link>
        <router-view></router-view>
    </div>
    <script>
        // 组件
        const One = {
            template: `
            <dvi>
                <h1>页面1</h1>
                <button @click='tiaozhuan'>跳转到Two页面</button>    
            </dvi>
            `,
            methods: {
                tiaozhuan() {
                    //触发该事件的时候 跳转到 指定页面
                    this.$router.push('/two')
                }
            },
        }
        const Two = {
            template: `
            <div>
                <h1>页面2</h1>
                <button @click='pre'> 后退一页</button>
                </div>
            `,
            methods: {
                pre() {
                    //触发当前事件时候 页面回退1次
                    this.$router.go(-1)
                }
            },
        }
        // 创建路由实例对象
        const router = new VueRouter({
            routes: [//routes路由规则数组
                { path: '/', redirect: '/one' },
                { path: '/one', component: One },
                { path: '/two', component: Two },
            ]
        })
        var vm = new Vue({
            el: '#app',
            router
        })
    </script>
  ```

## 其他
- 调试工具中 一个 root 代表一个vue实例对象

### Object.defineProperty(obj, prop, descriptor) 方法详情与案例
- 语法
  - obj：要定义属性的对象
  - prop：要定义或修改的属性的名称或 Symbol
  - descriptor：要定义或修改的属性描述符
    - get(){return value}  属性的  getter方法
    - set(value){}   属性的 setter方法
- demo
    ```js
    // 需求：
    // 1．给p添加一个新的属性: fullName= firstName + '-' + lastName
    // 2．如果修改了firstName/lastName,furllName自动改变为对应的值
    // 3．如果修改了fullName，firstName和lastName也自动改变为对应的值

    const p = {
        firstName: 'A',
        lastName: 'B'
    }

    Object.defineProperty(p, 'fullName', {

        get() {
            //*函数回调的三个问题?  什么时候执行?  用来做什么?  this指向谁 
            // 当读取属性值时自动调用set() ,将函数的返回值作为属性值，this是属性值所在的对象
            console.log(this);
            // return p.firstName + "-" + p.lastName
            return this.firstName + "-" + this.lastName
        },
        set(value) {
            // 当修改了属性值时自动调用set()，用来监视属性值的变化，this是属性所在的对象
            console.log(this);

            console.log(value);

            // 当set()执行说明fullName发生改变 获取到改变值 分割分别赋值
            const names = value.split('-')

            this.firstName = names[0]
            this.lastName = names[1]

        }
    })

    // 完成第一步
    console.log(p.fullName); //A-B
    // 完成第二步
    p.firstName = 'C'
    p.lastName = 'D'
    console.log(p.fullName); //A-B

    // 第三步
    p.fullName = 'Y-Z'

    console.log(p.firstName, p.lastName);

    ```


### event.target 触发事件的对象 (某个DOM元素) 的引用
-  event.target.tagName 返回元素名

###
- methods:{} 
  - 在methods中需要对data内部的数据发生更新 需要获取实例上的属性 才可以修改
  - 在methods中使用es6箭头函数 this指向为 window 使用普通函数 this指向为Vue实例

- el 指定element选择器
  - 提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例

### 全局配置
- 设置使用开发版本vue.js 不显示提示 `Vue.config.productionTip = false`

### 
- vue 中 但凡由vue所管理的函数，都不要写成箭头函数 否则会指向 window 而不指向 vue实例
### 什么是数据响应式？
- 1.data数据发生变化 页面渲染也发生变化 
- 2.页面渲染发生变化 data数据也发生变化
###
- some和every对数组的遍历：some是数组中只要有一个符合条件就返回true，every是每一个元素都符合条件才返回true，否则返回false

# VUEX
## 简述
- Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化
- Vuex 是实现组件全局状态(数据)管理的一种机制,可以方便的实现组件之间数据的共享。
- Vuex其实就是一个为Vue.js设计的数据仓库，就是把各个组件公用的数据放到一个仓库里面进行统一的管理，这样既使得非父子组件间的数据共享变得简单明了，也让程序变得更加可维护（将数据抽离了出来）,而且只要仓库里面的数据发生了变化，在其他组件里面数据被引用的地方也会自动更新。
- 为什么要用vueX
  - 能够在vuex中集中管理共享的数据,易于开发和后期维护
  - 能够高效地实现组件之间的数据共享,提高开发效率存储
  - 在vuex中的数据都是响应式的,能够实时保持数据与页面的同步,
- Vuex适用于开发大型单页的应用上
- Vuex的数据 都是响应式的
## vuex核心
- state 提供唯一的公共数据源,所有共享的数据都要统一放到 $store的state中进行存储。
  - 组件访问 state中的数据 
    - 方式1 ` $store.state.num `
    - 方式2  将当前组件需要的全局数据 映射为当前组件的 computed计算属性
        ` import {mapState} from 'vuex'
          computed:{
          ...mapState(['名称'])
          }
          <templae>{{名称}}</template>
        `
- mutations 用于变更  $store  数据
  - 只能通过 mutation 变更 $store 数据,不可以直接操作 $store 中的数据。
  - 通过这种方式虽然操作起来稍微繁琐一些,但是可以集中监控所有数据的变化。
  - 触发 mutations 的方式
    - 方式1 ` this.$store.commit("add"); ` commit 作用是调用某个 mutation 函数
    - 方式2 通过 导入的 mapMutations 函数 将需要的 mutations 函数 隐射为当前组件的methods的方法
      `
      import {mapMutations} from 'vuex'
      methods: {
        ...mapMutations(["方法1", "方法2"]),
        btn() {
        this.方法1(); 
        //同时也可以传参 
        //this.方法2(123);
        },
      }
      `
        - 方式二可以 进行简化 可以在触发时 直接调用 mapMutations 映射来的函数 进行 使用也可以传参
          - `<button @click="方法1(123)">一个按钮</button>`
- actions 用于处理异步任务
  - actions 中不能直接修改 state的数据
  - 如果通过异步操作变更数据,必须通过action,而不能使用mutation,但是在action中还是要通过触发mutation的方式间接变更数据
  - 触发actions 方式
    - 方式1  使用 dispatch 触发 actions
      - demo 异步带参传递
        ``` js
            this.$store.dispatch("Async",step);

            // store 的action 接收处理
            actions:{
             Async(context, step) {
             setTimeout(() => {
             context.commit("add ", step);
             }, 1000);
            },
            }
        ```
    - 方式2 通过 导入的 mapActions 函数 将需要的action函数 隐射为当前组件的methods的方法 
      - demo
        ```js
        import {mapActions} from 'vuex'
        methods: {
        ...mapActions(["方法1", "方法2"]),
        btn() {
        this.方法1(); 
        //同时也可以传参 
        //this.方法2(123);
        },
      }
        ```
        - 方式二可以 进行简化 可以在触发时 直接调用 mapActions 映射来的函数 进行 使用也可以传参
          - `<button @click="方法1(123)">一个按钮</button>`
- getters 用于对 $store 中的数据进行监听加工处理形成新的数据  可以理解为 computed
  - getters可以对 $store 中已有的数据加工处理之后形成新的数据,类似Vue的计算属性
  -  $store 中数据发生变化, getters的数据也会跟着变化
  -  vue3.0之后 getter 无法像计算属性一样 进行缓存
  - 使用getters 方式1 `this.$store.getters.名称`
  - 使用getters 方式2 将当前组件需要的全局数据 映射为当前组件的 computed计算属性
    ` import {mapGetters} from 'vuex'
      computed:{
      ...mapGetters(['名称'])
      }
      <templae>{{名称}}</template>
     `
- modules 模块化 
  - 通过模块化形式 进行私有化vuex中的四种方法， 通过调用不同模块 去调用模块内部的方法
  - modules 是所有定义的每一个小模块的总和
  - 针对当应用变得非常复杂时，store 对象变得臃肿
  - demo 基础用法
    ```js
    //1. 在store 文件中 进行定义和导入模块
    // 定义一个单独的模块  在export default createStore外定义
    const moduleA = {
    state:{
        abc:123
    },
    };
    //向 modules导入模块
    export default createStore({
    modules: {
    cba:moduleA,
    },
    })

    //2.进行使用 ：组件访问 state中的数据 方式
    //方式1
    <p> {{ this.$store.state.cba }}</p>
    //可以省略this
    //this.$store.state.(modules中定义的模块名称).(state中的数据名)
    <p> {{ $store.state.cba.abc }}</p>

    //方式2
    //引入
    import { mapState } from "vuex";

    export default {
    //模块的使用方式与单个的形式相同 但在引入的时候 不是直接 引入 state中数据 而是模块名称
    //同时 在使用 {{}} 插值表达式时 需要 多一层 {{cba.abc}} 
    computed: {
    //   将当前组件需要的全局数据 映射为当前组件的 computed计算属性
    // 引入模块 时 直接引入 modules 中定义的模块名称 （cba:moduleA）
    ...mapState(["num", "cba"]),
    },
   }
  

    ```

# VUE3
## 选项API和组合API 概念
- vue2 中使用的就是选项api
  - 代码风格：data选项写数据，methods选项写函数...，一个功能逻辑的代码分散。
  - 优点：易于学习和使用，写代码的位置已经约定好
  - 缺点：代码组织性差，相似的逻辑代码不便于复用，逻辑复杂代码多了不好阅读。
  - 补充：虽然提供mixins用来封装逻辑，但是出现数据函数覆盖的概率很大，不好维护。
- vue3 中使用的是组合api
  - 代码风格：一个功能逻辑的代码组织在一起（包含数据，函数...）
  - 优点：功能逻辑复杂繁多情况下，各个功能逻辑代码组织再一起，便于阅读和维护
  - 缺点：需要有良好的代码组织能力和拆分逻辑能力。
  - 补充：在vue3中同时也支持vue2.x选项API写法
- Options API 
  - 问题 使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 
  - 优势 可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。
## 新组件 Fragment
- 在Vue2中: 组件必须有一个根标签
- 在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中
- 好处: 减少标签层级, 减小内存占用
 
## setup函数
- **setup 函数中没有this 指向**
  - 从组件生命周期来看，它的执行在组件实例创建之前执行（vue2的beforeCreate）
  - 意味着在setup函数中 this 还不是组件实例，this 此时是 undefined 
- **setup 是组合API的起点 vue中所有的数据 方法 全部挂载在 setup 函数中**
- **在模版中需要使用的数据和函数，必须在 setup 中使用 return 进行返回**
- 当在vue3 中使用vu2的配置 （vue2中的data、methods、computed） 中可以访问到setup中的属性和方法
- 但是 setup 不能访问 vue2的配置 如果有重名 setup优先 (有语法检测时是不允许冲突的)
- setup 不能是个 async 函数 使用 async 后返回的是promise 模板会找不到return对象中的属性 **可以返回一个Promise实例，但需要Suspense和异步组件的配合**
- setup 函数的两种返回值
  - 方式1 若返回一个对象 则对象中的属性 、方法 在模板中都可以直接使用 
    - demo
    ```js
    <template>
      <div>
      <h1>姓名：{{ name }}</h1>
      <h1>年龄：{{ age }}</h1>
      <button @click="syhi">按钮</button>
      </div>
    </template>
    <script>
      import { h } from 'vue'
      export default {
      name: 'App',
      setup () {
        const name = '张三'
        const age = 18
        function syhi () {
          console.log(`${name}${age}岁`)
        }
        return {
          name,
          age,
          syhi
        }
      }
      }
    </script>
    ```
    - 方式2 返回一个渲染函数  可以自定义渲染内容
    - demo
      ```js
      <template>
        <div>  </div>
      </template>
      <script>
      import { h } from 'vue'
      export default {
        name: 'App',
        setup () {
          return () => {
            return h('h1', '返回一个渲染函数的参数')
          }
        }
      }
      </script>
      ```
- setup 中不能使用 let 全变为const原因 大哥说 let 定义的数据不是响应式
  - const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了
- setup 执行机制 setup 在beforeCreate 之前执行一次 this是undefined
- setup 的参数 两个
  - props 值为对象 包括 组件外部传递过来且组件内部声明接收了的属性
  - context 上下文对象
    - .attrs 值为对象 包括组件外部传递过来 但没有在 props配置中声明的属性 相当于 vue2 的 this.$attrs
    - .slots 收到的插槽内容 相当于 vue2 的this.slots (**vue3 中 使用 v-slots:xxx 不在 使用vue slots="xxx"**) 
    - .emit 分发自定义事件的函数 相当于 this.$emit
## ref 定义一个响应式的数据
- 语法 `const xxx=ref(value)`
- **操作数据时 需要 xxx.value   在模板中读取数据时 不需要**
- 接收的数据类型可以是基本类型也可以是对象类型
  - 基本类型的数据 响应式依然靠的是 Object.defineProperty()的get与set完成
  - 对象类型的数据 内部 求助了vue3 中的一个新函数 reactive 函数
- demo
  ```js
    <template>
    <div>
      <h1>姓名：{{ name }}</h1>
      <h1>年龄：{{ age }}</h1>
      <h1>职业：{{ obj.type }}</h1>
      <h1>薪资：{{ obj.money }}</h1>
      <button @click="change">按钮</button>
    </div>
    </template>
    <script>
    // 引入ref 实现响应式 ref 将数据加工成 引用对象
    import { ref } from 'vue'
    export default {
      name: 'App',
      setup () {
        const name = ref('张三')
        const age = ref(18)
        const obj = ref({
          type: '前端工程师',
          money: '10k'
        })
        function change () {
          name.value = '李四'
          age.value = 19
          obj.value.type = 'ui设计'
          obj.value.money = '20k'
        }
        return { name,  age, change,  obj}
      }
    }
    </script>
  ```
## reactive 定义一个对象类型的响应数据 （基本类型不能使用）
- 语法`const xxx 代理对象= reactive({}|[] 源对象)` 接收一个对象或数组 返回一个代理对象 （Proxy的实例对象 简称proxy对象） 
- reactive 定义的响应式数据是深层次的
- 内部基于 es6的Proxy 实现 通过代理对象操作源对象个内部的数据进行操作
- demo
  ```js
    <template>
      <div>
        <h1>姓名：{{ preson.name }}</h1>
        <h1>年龄：{{ preson.age }}</h1>
        <h1>职业：{{ preson.obj.type }}</h1>
        <h1>薪资：{{ preson.obj.money }}</h1>
        <h1>{{ preson.arr }}</h1>
        <button @click="change">按钮</button>
      </div>
    </template>
        <script>
        import { reactive } from 'vue'
        export default {
          name: 'App',
          setup () {
            const preson = reactive({
              name: '张三',
              age: 18,
              obj: {
                type: '前端',
                money: '10k'
              },
              arr: ['a', 'b', 'c']
            })
            function change () {
              preson.name = '李四'
              preson.obj.type = 'ui'
              person.arr[0] = 'abc'
            }
            return {
              preson,
              change
            }
          }
        }
        </script>
  ```
## reactive与ref的对比
- 定义数据角度
  - ref 用来 定义 基本数据类型
  - reactive 用来定义 引用数据类型  （对象 数组）
  - ref 也可以用来定义 引用类型数据 ref的内部 会自动通过 reactive 转为代理对象
- 从原理角度
  - ref 通过 Object.defineProperty() 的get与set来实现响应式 （数据劫持）
  - reactive 通过使用 Proxy来实现响应式 （数据劫持），并通过Reflect 操作源对象内部的数据
- 从使用角度
  - ref 定义的数据 操作数据需要 .value  读取数据时模板中直接读取不需要 .value
  - reactive 定义的数据 操作数据与读取数据 都不需要 .value 
## vue 响应式原理
### vue2 响应式原理
- 实现原理
  - 对象类型 通过 Object.defineProperty() 对属性的读取 修改 进行拦截 （数据劫持）
    - demo
      ```js
       let person = { name: '张三'}
        // 模拟vue2中实现响应式
        let p = {};
        Object.defineProperty(p, 'name', {
          configurable: true,// 配置后可以进行删除
          // 当有人读取了name 时调用
          get () {
            return person.name
          },
          // 当有人修改了name时调用
          set (value) {
            console.log("有人修改了name");
            return person.name = value
          }
        })
        // 折叠
        //#region
        console.log(p);
        console.log(person);
        console.log(p.name = "李四");
        console.log(p.sex = '男');
        console.log(p); //{sex: '男'}
        console.log(delete p.name); //false  无法删除  配置 configurable: true 后 可以进行删除
        console.log(person);
         //#endregion
      ```
  - 数组类型 通过重写更新数组的一系列方法来实现拦截 （对数组的变更进行了包裹）
- 存在问题
  - 新增属性 删除属性 界面不会更新
  - 直接通过下标修改数组 界面不会自动更新
- demo
  ```js
    <template>
      <div id="app">
      <h1>姓名：{{ preson.name }}</h1>
      <h1 v-show="preson.age">年龄：{{ preson.age }}</h1>
      <h1 v-show="preson.sex">性别：{{ preson.sex }}</h1>
      <h1>爱好：{{ preson.hoop }}</h1>
      <button @click="addSex">添加sex</button>
      <button @click="delAge">删除age</button>
      <button @click="updArray">下标修改数组</button>
      </div>
    </template>
    
    <script>
    import Vue from 'vue'
    export default {
    name: 'App',
    data () { return {preson: {name: '张三',age: 18,hoop: ['吃饭', '睡觉'] } } },
    methods: {
    // 添加
    addSex () {
      console.log(this.preson.sex, '添加前') // undefined '添加前'
      // this.preson.sex = '男' //实际数据改变但页面没变
      // 解决办法1 $set追加一个响应式的数据 sex 为追加属性 男为追加值
      // this.$set(this.preson, 'sex', '男')
      // 解决办法2 sex 为追加属性 男为追加值
      Vue.set(this.preson, 'sex', '男')
      console.log(this.preson.sex, '添加后') // 男 添加后
    },
    // 删除
    delAge () {
      console.log(this.preson.age, '删除前')
      // delete this.preson.age
      // 删除一个响应式的数据
      // this.$delete(this.preson, 'age')
      Vue.delete(this.preson, 'age')
      console.log(this.preson.age, '删除后')
    },
    // 修改数组
    updArray () {
      console.log(this.preson.hoop, '处理前')
      // this.preson.hoop[0] = '打豆豆'
      // 0 为数组下标 打豆豆为 修改的值
      // this.$set(this.preson.hoop, 0, '打豆豆')
      //Vue.set(this.preson.hoop, 0, '打豆豆')
      this.preson.hoop.splice(0, 1, '打豆豆')
      console.log(this.preson.hoop, '处理后')
    }}}
    </script>
   
  ```
### vue3 响应式原理
- 通过 Proxy 代理 ：拦截对象中任意属性的变化，值的增删改查
  - demo
    ```js
            // 全部到控制台输入 才能看到响应式
      let person = {
        name: '张三',
        age: 18
      }
      // 模拟 vue3 的实现响应式
      // 第二个参数一定要写 否则报错 空对象也ok 
      // person 为源数据  p为代理对象 
      let p = new Proxy(person, {
        // 访问触发
        // 第一个参数为 被访问的源数据 person 第二个参数为访问的具体属性
        get (target, propName) {
          console.log('有人读取了p身上的属性', target, propName);
          // 源数据[源数据中的属性] 返回 对应的值
          return target[propName]
        },
        // 修改触发 或 追加 触发
        // 参数3 为修改后的值
        set (target, propName, value) {
          console.log('有人修改或添加', target, propName, value);
          // 将修改的值真正的赋值给 源数据
          return target[propName] = value
        },
        // 删除触发
        // 参数 源 源属性
        deleteProperty (target, propName) {
          console.log('有人删除', target, propName);

          // 返回是否删除 成功  true/false
          return delete target[propName]
        }
      })

    ```
- 通过 Reflect 反射 ：对源对象的属性进行操作
  - demo
    ```js
            // Reflect 反射对象 
      let obj = {
        name: '张三',
        age: 18
      }
      // 查找
      console.log(window.Reflect.get(obj, "name"));
      // 修改
      console.log(window.Reflect.set(obj, "name", "李四"));
      // 添加
      console.log(window.Reflect.set(obj, "sex", "男"));
      // 删除
      console.log(window.Reflect.deleteProperty(obj, "age"));

      console.log(obj);
    ```
- Proxy 结合 Reflect
  - demo
    ```js
    let person = {
    name: '张三',
    age: 18
    }
    // 模拟 vue3 的实现响应式 雏形
    let p = new Proxy(person, {
      // 查
      get (target, propName) {
        console.log('有人读取了p身上的属性', target, propName);
        return Reflect.get(target, propName)
      },
      // 修改 或 添加
      set (target, propName, value) {
        console.log('有人修改或添加', target, propName, value);
        return Reflect.set(target, propName, value)
      },
      // 删除触发
      deleteProperty (target, propName) {
        console.log('有人删除', target, propName);
        return Reflect.deleteProperty(target, propName)
      }
    })
    ```
## computed 计算属性 同vue2
- demo
  ```js
    <template>
      <div>
        <h1>姓名：<input type="text" v-model="person.firstName"> </h1>
        <h1>年龄：<input type="text" v-model="person.lastName"> </h1>
        <h1>全名：<input type="text" v-model="person.fullName"></h1>
      </div>
    </template>
    <script>
    import { reactive, computed } from 'vue'
    export default {
      name: 'appDemo1',
      // vue2
      // computed: {
      //   fullName () {
      //     return this.person.firstName + '-' + this.person.lastName
      //   }
      // },
      setup () {
        const person = reactive({ firstName: '张', lastName: '三'  })
        // 只考虑计算属性的读取操作
        // person.fullName = computed(() => {
        //   return person.firstName + '-' + person.lastName
        // })
        // 考虑计算属性读取 和修改操作 当计算属性返回的值也被改变时的情况
        // computed 为对象形式
        person.fullName = computed({
          get () {
            return person.firstName + '-' + person.lastName
          },
          set (value) {
            // 切割为两个数组 内容全部对应
            const chai = value.split('-')
            person.firstName = chai[0]
            person.lastName = chai[1]
          }
        })
        return { person  } }  }
    </script>
  ```
## watch 监视
- 监视reactive 定义的响应式数据时  
  - 旧数据无法正确获取
  - 强制开启了深度监视 deep配置失效
- 监视reactive 定义的响应式数据中某个属性时 deep配置有效 （案例6）
### vue2 的监视
- vue2中两种监视方式 简写监视（函数形式）  和可配置监视 （对象形式）
- 语法
  - 简写 `watch:{被监视的数据xxx(new新值,old旧值){return 一些列操作}}`
  - 全写 `watch:{被监视的数据xxx{deep: true,配置,handler(new新值,old旧值){return 一些列操作}}}`
- 可以配置的监视 可以配置 属性
  - deep: true/false  是否深度监视  默认为false
  - immediate:true /false  是否立即监视 在未触发前 先进行监视
- demo
  ```js
    <template>
    <div>
    <h1>数值{{ num }}</h1>
    <button @click="num++">加加</button>
    <h1>{{ msg }}</h1>
    <button @click="msg += 'world'">同时监听多个</button>
    <hr />
    <h1>ref深层数据：{{ per.type.web.money }}</h1>
    <button @click="per.type.web.money++">监视改变ref深层数据</button>
     </div>
    </template>
    <script>
    import { ref, watch, reactive } from 'vue'
    export default {
    name: 'appDemo1',
    // vue2 中的监视
    watch: {
    // 方式1 简写方式
     num (newValue, oldValue) {
       console.log(`新值：${newValue} 旧值：${oldValue}`)
     }
    // 方式2 带配置
      num: {
      // 立即监视 在黑没有触发前就监视一次
      immediate: true,
      // 深度监视 默认是浅层监视 开启后可以监视 嵌套多层的数据
      deep: true,
      handler (newValue, oldValue) {
        console.log(`新值：${newValue} 旧值：${oldValue}`)
      }
    } 
    // 深层 不开deep 无法监视到
    per: {
      // 立即监视 在黑没有触发前就监视一次
      immediate: true,
      // 深度监视 默认是浅层监视 开启后可以监视 嵌套多层的数据
      deep: false,
      handler (newValue, oldValue) { console.log('新值：', newValue, '旧值：', oldValue) } } },
        
    setup () {
      const num = ref(0)
      const per = ref({type: {web: { money: 100 }}})
      const msg = ref('hello')
      return { num, msg, per }}}
    </script>
  ```
### vue3 的监视 **需要重听**
- 语法
- 1.监听reactive定义的全部响应式数据 或者 ref 定义的的单个响应式数据 `watch(num, (newValue, oldValue) => {一些列操作},{配置})`
- 2.监听一些ref数据 `watch([数据1,数据2], (newValue, oldValue) => {一些列操作},{配置})`
- 3.监听reactive中的一些数据 `watch([() => person.name数据1,() => person.name数据2], (newValue, oldValue) => {一些列操作},{配置})`
  - 监听单个 `() => person.name数据1`
- demo
  ```js
      <template>
    <div>
     <h1>数值{{ num }}</h1>
    <button @click="num++">加加</button>
    <h1>{{ msg }}</h1>
    <button @click="msg += 'world'">同时监听多个</button>
    <h1>{{ person.name }}</h1>
    <h1>{{ person.age }}</h1>
    <button @click="person.name += '牛逼'">reactive 改变 name</button>
    <button @click="person.age++">reactive 改变 age</button>

    <h1>薪资：{{ person.type.web.money }}</h1>
    <button @click="person.type.web.money++">reactive 改变 money</button>
     </div>
    /template>
    script>
    mport { ref, reactive } from 'vue'
    xport default {
    name: 'appDemo1',
  setup () {
    const num = ref(0)
    const msg = ref('hello')
    const person = reactive({
      name: '张三',
      age: 18,
      type: {
        web: {
          money: 20
        }
      }
    })
    // vue3 中的 watch
    // 情况1 监视 一个 ref 定义的响应式数据
    /*  watch(num, (newValue, oldValue) => {
      console.log(`新值：${newValue} 旧值：${oldValue}`)
    }, { immediate: true, deep: true }) */
    // 情况2 监视 多个 ref 定义的响应式数据 （可以同时出现多个watch 但可以简写）
    /*  watch([num, msg], (newValue, oldValue) => {
      console.log(`新值：${newValue} 旧值：${oldValue}`)
    }) */

    // 情况3 监听 reactive 定义的响应数据中的全部数据
    // 问题 监视 reactive定义的响应式数据时 oldValue无法正确获取
    // 自动开启了 深度监视 deep配置失效
    /*  watch(person, (newValue, oldValue) => {
      console.log('新值：', newValue, '旧值：', oldValue)
    }, { deep: false }) */

    // 情况 4 监听 reactive 定义的响应数据中的单个属性
    /*  watch(() => person.name, (newValue, oldValue) => {
      console.log('新值：', newValue, '旧值：', oldValue)
    }) */

    // 情况 5 监听 reactive 定义的响应数据中的一些属性
    /* watch([() => person.name, () => person.age], (newValue, oldValue) => {
      console.log('新值：', newValue, '旧值：', oldValue)
    }) */
    // 情况 6 监听 reactive 定义的响应数据中的单个属性
    // 改变了 person.type.web.money 但是无法触发 需要开启 deep 深度监视
     watch(() => person.type, (newValue, oldValue) => {
      console.log('新值：', newValue, '旧值：', oldValue)
    }, { deep: true }) 

    return { num, msg, person }
      }
    }
    </script>
  ```
### watch 监视 ref的value问题
- 当watch监听 使用 ref定义的基础数据类型 不用点value 否则监听的 具体值 而不是当前属性
- 当watch监听 使用 ref定义的复杂数据类型 **1.需要点value 否则无法监听 或者2.开启深度监听** （因为ref定义的复杂类型 同样是通过 reactive 代理完成的）  
## watchEffect 监视 
- watchEffect 未发生改变前也会触发一次 同 watch 开启了  immediate
- watchEffect 不用指定监视属性 **监视的回调中用到了哪些属性 那就监视哪些属性**
- watch 既要指定监视属性 也要指定监视回调
- watchEffect 所指定的回调中用到的数据只要发生变化 则直接重新执行回调
- watchEffect 类似于 computed 但 computed 注重计算的结果 必须要有返回值 而 watchEffect注重过程 所以不用写返回值
## vue3 生命周期
- vue3 中可以使用vue2的生命周期 以配置项形式抒写 需要注意的是 卸载前和卸载后 语法进行了改变
- vue3中同时出现 vue3 vue2生命周期时 vue3的生命周期优先级高于 vue2
### **4个阶段 7个生命周期** 
- **不在有创建实例后 vue2创建实例前 也改为setup**
- **vue2中生命周期钩子 beforeDestroy 和 destroyed(销毁前销毁后) 已经被重命名为beforeUnmount和unmouted**
- setup 创建实例前
- onBeforeMount 挂载DOM前
- onMounted 挂载DOM后
- onBeforeUpdate 更新组件前
- onUpdated 更新组件后
- onBeforeUnmount 卸载销毁前
- onUnmounted 卸载销毁后
  - demo
    ```js
    <template>
    <div id="app">
    {{ msg }}
    {{ texts }}
    {{ os }}
    <button @click="btn">进行更改</button>
    <button @click="del">进行销毁</button>
    </div>
    </template>
    <script>
    import { onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted, reactive, ref, toRef, toRefs } from 'vue'
    export default {
    name: 'App',
    setup () {
    let msg = reactive(
      {
        name: '张三',
        age: 18,
        sex: '男'
      }
    )
    // ref
    let texts = ref(123)
    // toRef
    let os = toRef(msg, 'age')
    // toRefs
    let refs_text = toRefs(msg)
    const btn = () => {
      msg.name = '李四'
      texts.value = 456
      os.value = 99
      refs_text.sex.value = '女'

    }
    const del = () => {
      console.log(1);
      // this.$destroy();
      // 销毁没做
    }
    // 生命周期
    onBeforeMount(() => {
      console.log('挂载DOM前')
    })
    onMounted(() => {
      console.log('挂载DOM后')
    })
    onBeforeUpdate(() => {
      console.log('更新组件前')
    })
    onUpdated(() => {
      console.log('更新组件后')
    })
    onBeforeUnmount(() => {
      console.log('卸载销毁前')
    })
    onUnmounted(() => {
      console.log('卸载销毁后')
    })
    return { msg, btn, texts, os, del }
    }
    }
    </script>
    ```
### vu3其他生命周期
- activated
- deactivated
- errorCaptured
- renderTracked
- renderTriggered
## 自定义 hook 函数
- 把setup 函数中使用的 Composition API（组合api） 进行封装  
- 作用：复用代码让setup中的逻辑更清楚易懂 
- demo
  ```js
  // hook/useGetPoint.js
    import { reactive, onMounted, onBeforeUnmount } from 'vue'
    export default function () {
      const point = reactive({
        y: 0,
        x: 0
      })
      function getPoint (event) {
        console.log(event.pageX, event.pageY)
        point.x = event.pageX
        point.y = event.pageY
      }
      onMounted(() => {
        // 挂载实例后
        window.addEventListener('click', getPoint)
      })
      // 销毁实例前
      onBeforeUnmount(() => {
        // 在销毁实例前 将这个事件清除 如果不进行清除 事件依然会存在
        window.removeEventListener('click', getPoint)
      })
      // 返回
      return point
    }

    // 需要调用的
     <template>
      <div>
        <h1>{{ `x:${point.x} y:${point.y}` }}</h1>
      </div>
    </template>
    <script>
    import { ref } from 'vue'
    // 引入获取位置的hook的函数
    import useGetPoint from '../hooks/useGetPoint'
    export default {
      name: 'appDemo1',
      setup () {
        const num = ref(0)
        // 进行赋值
        const point = useGetPoint()   

        return { num, point }
      }
    }
    </script>
  ```
## toRef 和 toRefs 的使用
- 创建一个ref 对象 其value值指向另一个对象中的某个属性值
- 将响应式对象中的某个属性（多个属性）提供给外部使用
- toRef 同于 toRefs 一个是单个创建一个是多个创建
- 需要注意的是 只能省略掉当前对象的最外层对象名 多级嵌套还是需要逐次写上才能获取到
- demo
  ```js
        <template>
      <div>
        <h3>{{ person }}</h3>
        <h1>姓名：{{ name }}</h1>
        <h1>年龄：{{ age }}</h1>
        <h1>城市：{{ cityss }}</h1>
        <h1>工资：{{ money }} K</h1>
        <button @click="person.city.citys.money++">money加加</button>
        <hr />
        <h4>{{ person2 }}</h4>
        <h1>姓名：{{ name2 }}</h1>
        <h1>年龄：{{ age2 }}</h1>
        <h1>工资：{{ money2.moneys2.moneyss2 }}</h1>
        <button @click="money2.moneys2.moneyss2++">money加加</button>
      </div>
    </template>
    <script>
    import { reactive, toRef, toRefs } from 'vue'
    export default {
      name: 'appDemo1',
      setup (context) {
        const person = reactive({name: '张三',age: 18,city: { citys: { cityss: '南昌',money: 10}}})
        const person2 = reactive({ name2: '李四', age2: 20, money2: { moneys2: { moneyss2: 100}}})
        return {
          person,
          // toRef
          name: toRef(person, 'name'),
          age: toRef(person, 'age'),
          money: toRef(person.city.citys, 'money'),
          cityss: toRef(person.city.citys, 'cityss'),
          person2,
          //toRefs 
          //因为拿到的是对象所以需要解构 
          ...toRefs(person2)
        }
      }
    }
    </script>
  ```
##  shallowReactive 和 shallowRef  (了解)
- shallowReactive 只处理对象最外层属性的响应式 （浅层响应式）
- shallowRef 只处理基本数据类型的响应式 不进行对象的响应式处理
- 应用场景
  - 如果一个对象数据 结构比较深 但变化时只是外层属性变化 那就使用 shallowReactive
  - 如果一个对象数据 后续功能不会修改对象中的属性 或改变时是替代 那就使用 shallowRef
- demo
  ```js
        <template>
      <div>
        <h4>{{ person }}</h4>
        <h1>姓名：{{ name }}</h1>
        <h1>年龄：{{ age }}</h1>
        <h1>工资：{{ money.moneys.moneyss }}</h1>
        <!-- 使用了 shallowReactive 深层数据无法改变  （待定：有bug当点击年龄时在点击money有时候也会莫名奇妙加了） -->
        <button @click="money.moneys.moneyss++">money加加</button>
        <button @click="age++">年龄加加</button>
        <hr />
        <h4>{{ test1 }}</h4>
        <h4>{{ test2 }}</h4>
        <button @click="test1.b++">test1</button>
        <button @click="test2.a++">test</button>
      </div>
    </template>
    <script>
    import { toRefs, shallowReactive, ref, shallowRef } from 'vue'
    export default {
      name: 'appDemo1',
      setup (context) {
        // const person = reactive({
        const person = shallowReactive({ name: '李四', age: 0, money: {moneys: {  moneyss: 100} } })
        const test1 = ref({b: 456 })
        const test2 = shallowRef({   a: 123})
        console.log(test1)
        console.log(test2)
        // 因为拿到的是对象所以需要解构
        return {person,...toRefs(person), test1,test2}}
    }
    </script>
  ```
## readonly 和 shallowReadonly
- readonly 让一个响应式数据变为只读的 （深层只读）
- shallowReadonly 让一个响应式数据变为只读的 （浅层只读）意味着深层次的数据 可以被改变
- 应用场景 不希望数据被改变
- demo
  ```js
        <template>
    <div>
      <h1>姓名：{{ name }}</h1>
      <h1>年龄：{{ age }}</h1>
      <h1>工资：{{ money.moneys.moneyss }}</h1>
      <!-- 使用了 shallowReactive 深层数据无法改变  （待定：有bug当点击年龄时在点击money有时候也会莫名奇妙加了） -->
      <button @click="money.moneys.moneyss++">money加加</button>
      <button @click="age++">年龄加加</button>
      <hr />
      <h4>{{ sum }}</h4>
      <button @click="sum++">sum++</button>
    </div>
  </template>
  <script>
  import { toRefs, ref, reactive, shallowReadonly, readonly } from 'vue'
  export default {
    name: 'appDemo1',
    setup (context) {
      let person = reactive({
        name: '李四',
        age: 10,
        money: {
          moneys: {
            moneyss: 100
          }
        }
      })
      let sum = ref(0)
      // person = readonly(person)
      person = shallowReadonly(person)
      sum = readonly(sum)
      return {
        ...toRefs(person),
        sum
      }
    }
  }
  </script>
  ```
## toRaw 和 markRaw
- toRaw 
  - 作用：将一个由reactive生成的响应式对象转为普通对象。
  - 使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。
- markRaw：
  - 作用：标记一个对象，使其永远不会再成为响应式对象。
  - 应用场景:
    1. 有些值不应被设置为响应式的，例如复杂的第三方类库等。
    2. 当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。

- demo
  ```js
        <template>
      <div>
        <h1>姓名：{{ name }}</h1>
        <h1>年龄：{{ age }}</h1>
        <h1>工资：{{ money.moneys.moneyss }}</h1>
        <h1 v-show="person.car">{{ person.car }}</h1>
        <button @click="money.moneys.moneyss++">money加加</button>
        <button @click="age++">年龄加加</button>
        <hr />
        <button @click="showRawPerson">输出原始数据</button>
        <button @click="addcar">添加其他信息</button>
        <button @click="person.car.carMoney++">修改car价格</button>
      </div>
    </template>
    <script>
    import { toRefs, reactive, toRaw, markRaw } from 'vue'
    export default {
      name: 'appDemo1',
      setup (context) {
        const person = reactive({
          name: '李四',
          age: 10,
          money: {
            moneys: {
              moneyss: 100
            }
          }
        })
        function showRawPerson () {
          // 将一个由reactive 生成的响应式对象转为普通对象
          const p = toRaw(person)
          console.log(p)
          console.log(person)
        }
        // 添加一条数据
        // 在添加的时候 因为setup只会执行一次 所以还是需要将 person整个数据return 这样可以监测到整个数据的变化
        function addcar () {
          const car = { type: 'audioRs7', carMoney: 200 }
          // person.car = car
          // 标记当前当前对象 永远不在称为响应式对象
          person.car = markRaw(car)
        }
        return {
          person,
          ...toRefs(person),
          showRawPerson,
          addcar
        }
      }
    }
    </script>
  ```
## customRef 创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制

- demo 实现防抖效果
  ```js
          <template>
      <div>
        <input type="text" v-model="keyWord" />
        <h3>{{ keyWord }}</h3>
      </div>
    </template>
    <script>
    // customRef
    import { customRef } from 'vue'
    export default {
      name: 'App',
      setup () {
        function myRef (value, delay) {
          let timer
          return customRef((track, trigger) => {
            return {
              get () {
                console.log(`数据被读取了 ${value}`)
                track() // 通知vue追踪value的变化 提前跟get商量 让他认为value是有用的
                return value
              },
              set (newValue) {
                // 防抖 当改变数据时 当前函数就会被触发 在进入前先将上一次的定时器清除掉 最后只会执行一次
                clearTimeout(timer)
                console.log(`数据改变了 ${newValue}`)

                // 过500ms 后进行渲染改变后的数据
                timer = setTimeout(() => {
                  value = newValue
                  trigger() // 告诉Vue去更新界面
                }, delay)
              }
            }
          })
        }
        const keyWord = myRef('hello', 500)
        return { keyWord }
      }
    }
    </script>
  ```
## provide 与 inject 祖组件给与后代组件间的传值
- 作用：实现祖与后代组件间通信
- 父组件有一个 provide 选项来提供数据，后代组件有一个 inject 选项来开始使用这些数据
- 具体写法：
  1. 祖组件中：
    ```js
        setup(){
         	......
             let car = reactive({name:'奔驰',price:'40万'})
             provide('car',car)
             ......
         }
    ```
  2. 后代组件中：
    ```js
         setup(props,context){
    	......
       const car = inject('car')
       return {car}
    	......
    }
    ```
## 响应式数据的判断  isRef isReactive isReadonly isProxy
- isRef: 检查一个值是否为一个 ref 对象
- isReactive: 检查一个对象是否是由 reactive 创建的响应式代理
- isReadonly: 检查一个对象是否是由 readonly 创建的只读代理
- isProxy: 检查一个对象是否是由 reactive 或者 readonly 方法创建的代理
- demo
  ```js
    <template>
      <div class="App-box">根组件</div>
    </template>
    <script>
    import { reactive, toRefs, ref, readonly, isProxy, isReactive, isReadonly, isRef } from 'vue'
    export default {
      name: 'AppPage',
      setup () {
        const car = reactive({ name: 'audioRS7', price: 200 })
        const sum = ref(0)
        const car2 = readonly(car) // true
        console.log(isRef(sum)) // true
        console.log(isReactive(car)) // true
        console.log(isProxy(car)) // true
        console.log(isReadonly(car2)) // true
        console.log(isProxy(car2)) // true
        return {...toRefs(car),sum,car2}}
    }
    </script>
  ```
## teleport 标签
- teleport 标签 能够将vue的组件 html结构移动到指定位置的技术
- <teleport to="移动位置"> 可以填写标签名 和一系列css选择器 （提前在主html中定义）
- demo
  ```html
      <teleport to="移动位置">
  	<div v-if="isShow" class="mask">
  		<div class="dialog">
  			<h3>我是一个弹窗</h3>
  			<button @click="isShow = false">关闭弹窗</button>
  		</div>
  	</div>
  </teleport>
  ```
## defineAsyncComponent  异步引入组件
- demo
  ```js
    // 静态引入
    // import Father from './components/father.vue'

    import { reactive, toRefs, defineAsyncComponent } from 'vue'
    // 异步引入 配合 defineAsyncComponent使用
    const Father = defineAsyncComponent(() => import('./components/father'))
  ```
## VUE3 中的其他改变
 - 将全局的API，即：```Vue.xxx```调整到应用实例（```app```）上

    | 2.x 全局 API（```Vue```） | 3.x 实例 API (`app`)                        |
    | ------------------------- | ------------------------------------------- |
    | Vue.config.xxxx           | app.config.xxxx                             |
    | Vue.config.productionTip  | <strong style="color:#DD5145">移除</strong> |
    | Vue.component             | app.component                               |
    | Vue.directive             | app.directive                               |
    | Vue.mixin                 | app.mixin                                   |
    | Vue.use                   | app.use                                     |
    | Vue.prototype             | app.config.globalProperties                 |
- 移除keyCode作为 v-on 的修饰符，同时也不再支持config.keyCodes
- 移除v-on.native修饰符
- 移除了过滤器（filter）
- 移除 Vue.config.productionTip  （提示）
## 
- triggerRef 手动执行与 shallowRef 关联的任何作用(shallowRef 无法实现对象的数据成为响应式) triggerRef可以强制响应
  - demo
    ```js
      import { shallowRef, triggerRef } from "vue";
      let msg = shallowRef({ name: "小八嘎" });
      const changeMsg = () => {
        msg.value.name = "大八嘎";
        triggerRef(msg);
      };
    ```
- customRef 创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制
  - 它需要一个工厂函数，该函数接收 track 和 trigger 函数作为参数，并且应该返回一个带有 get 和 set 的对象
# 其他
## 查看vue 版本 vue -V 或者 vue --version
## vite 构建工具 是一种新型前端构建工具，能够显著提升前端开发体验 
- 它是一个更加轻量（热更新速度快，打包构建速度快）的vue项目脚手架工具。
- 相对于vue-cli它默认安装的插件非常少，随着开发过程依赖增多，需要自己额外配置。
- 按需编译 不用等待整个应用编译完成
### 创建以及使用
- 创建项目 npm init vite-app 项目名称 或者 yarn create vite-app 项目名称
- 安装依赖 npm i 或者 yarn
- 启动项目 npm run dev 或者 yarn dev
## 重点知识 destroyed
- 生命周期执行顺序 ？
  - init->beforeCreate->created->beformMounted->mounted->init->beforeUpdate->updated->beforeDestroy->destroyed
  - init 为初始化
- Vue双向数据的原理？
  - VUE2是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调、
  - VUE3.0 通过 Proxy 来劫持数据，在数据变动时发布消息给订阅者，触发相应的监听回调
- v-for循环中的key值的作用？
  - key的作用主要是为了高效的更新虚拟dom，使用key来给每一个节点做唯一的标识
## 创键vue-cli脚手架方式
- 终端
  - vue create xxx项目名
  - Please pick a preset (预设配置)  Manually select features （手动选择功能）
  - Use history mode for router? 路由器是否使用历史模式？ y/n
  - Pick a linter / formatter config 选择一个linter/formatter配置 (ESLint配置)
    - ESLint with error prevention only  仅带错误预防的ESLint
    - ESLint + Airbnb config    ESLint+Airbnb配置
    - ESLint + Standard config  ESLint+标准配置
    - ESLint + Prettier         ESLint+更漂亮
  - Pick additional lint features: Lint on save 默认
  - Where do you prefer placing config for Babel, ESLint, etc.? 您更喜欢将Babel、ESLint等的配置放在哪里。？
  - Save this as a preset for future projects?   是否将其保存为未来项目的预设？

- ui界面创建vue项目
  - `vue ui`
## 组件 插件 包 
- 富文本 包  `vue-quill-editor`
  - 基于 Quill、适用于 Vue 的富文本编辑器，支持服务端渲染和单页应用。
# DEMO
- 通过路由传值到另一个页面 实现页面跳转并携带数据
  - demo
    ```js
    //传值页面
    updateShop (id) {
      this.$router.push({
        path: '/goods/update',
        query: {
          id
        }
      })
    }
    //接收页面
    const id = this.$route.query.id
    ```